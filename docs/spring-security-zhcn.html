
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5.dev">
<meta name="author" content="Ben Alex, Luke Taylor, Rob Winch, Gunnar Hillert">
<title>Spring Security 参考手册|Spring Security中文版</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Spring Security 参考手册</h1>
<div class="details">
<span id="author" class="author">Ben Alex</span><br>
<span id="author2" class="author">Luke Taylor</span><br>
<span id="author3" class="author">Rob Winch</span><br>
<span id="author4" class="author">Gunnar Hillert</span><br>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#true-">前言</a></li>
<li><a href="#getting-started">入门</a></li>
<li><a href="#introduction">简介</a>
<ul class="sectlevel2">
<li><a href="#what-is-acegi-security">Spring Security是什么?</a></li>
<li><a href="#history">历史</a></li>
<li><a href="#release-numbering">发布版本号</a></li>
<li><a href="#get-spring-security">Getting Spring Security</a></li>
</ul>
</li>
<li><a href="#new">Spring Security 4.1新特性</a>
<ul class="sectlevel2">
<li><a href="#truejava">Java 配置提升</a></li>
<li><a href="#trueweb">Web应用程序安全性提升</a></li>
<li><a href="#true--2">授权改进</a></li>
<li><a href="#true--3">密码模块的改进</a></li>
<li><a href="#true--4">测试的改进</a></li>
<li><a href="#true--5">一般的改进</a></li>
</ul>
</li>
<li><a href="#samples">样品和指南 (Start Here)</a></li>
<li><a href="#jc">Java 配置</a>
<ul class="sectlevel2">
<li><a href="#true-java">基础的网站安全java配置</a></li>
<li><a href="#jc-httpsecurity">HttpSecurity</a></li>
<li><a href="#jc-form">Java配置和表单登录</a></li>
<li><a href="#true--6">验证请求</a></li>
<li><a href="#jc-logout">处理登出</a></li>
<li><a href="#jc-authentication">验证</a></li>
<li><a href="#true-httpsecurity">多个HttpSecurity</a></li>
<li><a href="#jc-method">方法安全</a></li>
<li><a href="#true--7">已配置对象的后续处理</a></li>
</ul>
</li>
<li><a href="#ns-config">安全命名空间配置</a>
<ul class="sectlevel2">
<li><a href="#true--8">简介</a></li>
<li><a href="#ns-getting-started">开始使用安全命名空间配置</a></li>
<li><a href="#ns-web-advanced">高级web功能</a></li>
<li><a href="#ns-method-security">方法安全</a></li>
<li><a href="#ns-access-manager">默认的 AccessDecisionManager</a></li>
<li><a href="#ns-auth-manager">验证管理器和命名空间</a></li>
</ul>
</li>
<li><a href="#sample-apps">应用程序示例</a>
<ul class="sectlevel2">
<li><a href="#tutorial-sample">Tutorial 示例</a></li>
<li><a href="#contacts-sample">Contacts 示例</a></li>
<li><a href="#ldap-sample">LDAP 示例</a></li>
<li><a href="#openid-sample">OpenID 示例</a></li>
<li><a href="#cas-sample">CAS 示例</a></li>
<li><a href="#jaas-sample">JAAS 示例</a></li>
<li><a href="#preauth-sample">Pre-Authentication 示例</a></li>
</ul>
</li>
<li><a href="#community">Spring Security 社区</a>
<ul class="sectlevel2">
<li><a href="#jira">问题跟踪</a></li>
<li><a href="#becoming-involved">成为参与者</a></li>
<li><a href="#further-info">更多信息</a></li>
</ul>
</li>
<li><a href="#overall-architecture">架构与实现</a>
<ul class="sectlevel1">
<li><a href="#technical-overview">技术概述</a>
<ul class="sectlevel2">
<li><a href="#runtime-environment">运行环境</a></li>
<li><a href="#core-components">核心组件</a></li>
<li><a href="#tech-intro-authentication">验证</a></li>
<li><a href="#tech-intro-web-authentication">在Web应用程序中的身份验证</a></li>
<li><a href="#tech-intro-access-control">Spring Security的访问控制(授权)</a></li>
<li><a href="#localization">Localization</a></li>
</ul>
</li>
<li><a href="#core-services">核心服务</a>
<ul class="sectlevel2">
<li><a href="#core-services-authentication-manager">The AuthenticationManager, ProviderManager and AuthenticationProvider</a></li>
<li><a href="#trueuserdetailsservice">UserDetailsService实现</a></li>
<li><a href="#core-services-password-encoding">Password Encoding</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#test">Testing</a>
<ul class="sectlevel1">
<li><a href="#test-method">Testing Method Security</a>
<ul class="sectlevel2">
<li><a href="#test-method-setup">Security Test Setup</a></li>
<li><a href="#test-method-withmockuser">@WithMockUser</a></li>
<li><a href="#test-method-withanonymoususer">@WithAnonymousUser</a></li>
<li><a href="#test-method-withuserdetails">@WithUserDetails</a></li>
<li><a href="#test-method-withsecuritycontext">@WithSecurityContext</a></li>
<li><a href="#test-method-meta-annotations">Test Meta Annotations</a></li>
</ul>
</li>
<li><a href="#test-mockmvc">Spring MVC Test Integration</a>
<ul class="sectlevel2">
<li><a href="#test-mockmvc-setup">Setting Up MockMvc and Spring Security</a></li>
<li><a href="#test-mockmvc-smmrpp">SecurityMockMvcRequestPostProcessors</a></li>
<li><a href="#truesecuritymockmvcrequestbuilders">SecurityMockMvcRequestBuilders</a></li>
<li><a href="#truesecuritymockmvcresultmatchers">SecurityMockMvcResultMatchers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#web-app-security">Web应用程序的安全性</a>
<ul class="sectlevel1">
<li><a href="#security-filter-chain">The Security Filter Chain</a>
<ul class="sectlevel2">
<li><a href="#delegating-filter-proxy">DelegatingFilterProxy</a></li>
<li><a href="#filter-chain-proxy">FilterChainProxy</a></li>
<li><a href="#truefilter-ordering">Filter Ordering</a></li>
<li><a href="#request-matching">Request Matching and HttpFirewall</a></li>
<li><a href="#true--17">与其它过滤器-基于框架使用</a></li>
<li><a href="#filter-chains-with-ns">高级的命名空间配置</a></li>
</ul>
</li>
<li><a href="#core-web-filters">核心安全过滤器</a>
<ul class="sectlevel2">
<li><a href="#filter-security-interceptor">FilterSecurityInterceptor</a></li>
<li><a href="#exception-translation-filter">ExceptionTranslationFilter</a></li>
<li><a href="#security-context-persistence-filter">SecurityContextPersistenceFilter</a></li>
<li><a href="#form-login-filter">UsernamePasswordAuthenticationFilter</a></li>
</ul>
</li>
<li><a href="#servletapi">Servlet API的集成</a>
<ul class="sectlevel2">
<li><a href="#servletapi-25">Servlet 2.5+ 集成</a></li>
<li><a href="#servletapi-3">Servlet 3+ 集成</a></li>
<li><a href="#servletapi-31">Servlet 3.1+ 集成</a></li>
</ul>
</li>
<li><a href="#basic">Basic和Digest认证</a>
<ul class="sectlevel2">
<li><a href="#basic-processing-filter">BasicAuthenticationFilter</a></li>
<li><a href="#digest-processing-filter">DigestAuthenticationFilter</a></li>
</ul>
</li>
<li><a href="#remember-me">Remember-Me Authentication</a>
<ul class="sectlevel2">
<li><a href="#remember-me-overview">Overview</a></li>
<li><a href="#remember-me-hash-token">Simple Hash-Based Token Approach</a></li>
<li><a href="#remember-me-persistent-token">Persistent Token Approach</a></li>
<li><a href="#remember-me-impls">Remember-Me的接口和实现</a></li>
</ul>
</li>
<li><a href="#csrf">Cross Site Request Forgery (CSRF)</a>
<ul class="sectlevel2">
<li><a href="#truecsrf">CSRF攻击</a></li>
<li><a href="#true--18">同步器标记模式</a></li>
<li><a href="#true-csrf">何时使用CSRF保护</a></li>
<li><a href="#csrf-using">Using Spring Security CSRF Protection</a></li>
<li><a href="#csrf-caveats">CSRF警告</a></li>
<li><a href="#true--19">重写默认值</a></li>
</ul>
</li>
<li><a href="#cors">CORS</a></li>
<li><a href="#headers">安全HTTP响应头</a>
<ul class="sectlevel2">
<li><a href="#true--20">默认的安全头</a></li>
<li><a href="#headers-custom">Custom Headers</a></li>
</ul>
</li>
<li><a href="#session-mgmt">会话管理</a>
<ul class="sectlevel2">
<li><a href="#true--21">会话管理过滤器</a></li>
<li><a href="#true--22">会话的身份验证策略</a></li>
<li><a href="#concurrent-sessions">并发控制</a></li>
</ul>
</li>
<li><a href="#anonymous">匿名身份验证</a>
<ul class="sectlevel2">
<li><a href="#anonymous-overview">概述</a></li>
<li><a href="#anonymous-config">配置</a></li>
<li><a href="#anonymous-auth-trust-resolver">验证信任解析器</a></li>
</ul>
</li>
<li><a href="#websocket">WebSocket Security</a>
<ul class="sectlevel2">
<li><a href="#websocket-configuration">WebSocket Configuration</a></li>
<li><a href="#websocket-authentication">WebSocket Authentication</a></li>
<li><a href="#websocket-authorization">WebSocket Authorization</a></li>
<li><a href="#websocket-sameorigin">Enforcing Same Origin Policy</a></li>
<li><a href="#websocket-sockjs">Working with SockJS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#authorization">授权</a>
<ul class="sectlevel1">
<li><a href="#authz-arch">授权体系结构</a>
<ul class="sectlevel2">
<li><a href="#authz-authorities">授权</a></li>
<li><a href="#authz-pre-invocation">Pre-Invocation处理</a></li>
<li><a href="#authz-access-decision-manager">访问决策管理器</a></li>
<li><a href="#authz-after-invocation-handling">调用处理</a></li>
<li><a href="#authz-hierarchical-roles">层次的角色</a></li>
</ul>
</li>
<li><a href="#secure-object-impls">安全对象的实现</a>
<ul class="sectlevel2">
<li><a href="#aop-alliance">AOP联盟(方法调用)安全拦截器</a></li>
<li><a href="#aspectj">AspectJ(连接点)安全拦截器</a></li>
</ul>
</li>
<li><a href="#el-access">表达式的访问控制</a>
<ul class="sectlevel2">
<li><a href="#true--23">概述</a></li>
<li><a href="#el-access-web">Web Security Expressions</a></li>
<li><a href="#truemethod-security-expressions">Method Security Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#advanced-topics">额外的话题</a>
<ul class="sectlevel1">
<li><a href="#domain-acls">域对象的安全(acl)</a>
<ul class="sectlevel2">
<li><a href="#domain-acls-overview">概述</a></li>
<li><a href="#domain-acls-key-concepts">关键概念</a></li>
<li><a href="#domain-acls-getting-started">开始</a></li>
</ul>
</li>
<li><a href="#preauth">Pre-Authentication场景</a>
<ul class="sectlevel2">
<li><a href="#truepre-authentication">Pre-Authentication框架类</a></li>
<li><a href="#true--27">具体实现</a></li>
</ul>
</li>
<li><a href="#ldap">LDAP 身份验证</a>
<ul class="sectlevel2">
<li><a href="#ldap-overview">概述</a></li>
<li><a href="#true-ldap-spring-security">使用LDAP Spring Security</a></li>
<li><a href="#ldap-server">配置LDAP服务器</a></li>
<li><a href="#true--30">实现类</a></li>
<li><a href="#ldap-active-directory">活动目录的认证</a></li>
</ul>
</li>
<li><a href="#taglibs">JSP 标签库</a>
<ul class="sectlevel2">
<li><a href="#true-taglib">宣布Taglib</a></li>
<li><a href="#taglibs-authorize">授权标签</a></li>
<li><a href="#true--33">身份验证标记</a></li>
<li><a href="#truethe-accesscontrollist-tag">The accesscontrollist Tag</a></li>
<li><a href="#truecsrfinput">csrfInput标签</a></li>
<li><a href="#truecsrfmetatags">csrfMetaTags标签</a></li>
</ul>
</li>
<li><a href="#jaas">Java Authentication and Authorization Service (JAAS) Provider</a>
<ul class="sectlevel2">
<li><a href="#true--34">概述</a></li>
<li><a href="#jaas-abstractjaasauthenticationprovider">Jaas远程准入Provider摘要</a></li>
<li><a href="#jaas-defaultjaasauthenticationprovider">默认Jaas身份验证提供</a></li>
<li><a href="#jaas-jaasauthenticationprovider">Jaas Provider准入</a></li>
<li><a href="#jaas-apiprovision">项目运行</a></li>
</ul>
</li>
<li><a href="#cas">CAS 身份验证</a>
<ul class="sectlevel2">
<li><a href="#cas-overview">Overview</a></li>
<li><a href="#cas-how-it-works">CAS如何工作</a></li>
<li><a href="#cas-client">配置客户案件</a></li>
</ul>
</li>
<li><a href="#x509">X.509 Authentication</a>
<ul class="sectlevel2">
<li><a href="#x509-overview">概述</a></li>
<li><a href="#true-x-509-web">增加X.509认证您的Web应用程序</a></li>
<li><a href="#x509-ssl-config">在Tomcat中设置SSL</a></li>
</ul>
</li>
<li><a href="#runas">run - as验证替换</a>
<ul class="sectlevel2">
<li><a href="#runas-overview">概述</a></li>
<li><a href="#runas-config">Configuration</a></li>
</ul>
</li>
<li><a href="#crypto">Spring Security Crypto模块</a>
<ul class="sectlevel2">
<li><a href="#spring-security-crypto-introduction">引言</a></li>
<li><a href="#spring-security-crypto-encryption">加密器</a></li>
<li><a href="#spring-security-crypto-keygenerators">keygenerators</a></li>
<li><a href="#spring-security-crypto-passwordencoders">passwordencoders</a></li>
</ul>
</li>
<li><a href="#concurrency">并发支持</a>
<ul class="sectlevel2">
<li><a href="#truedelegatingsecuritycontextrunnable">DelegatingSecurityContextRunnable</a></li>
<li><a href="#truedelegatingsecuritycontextexecutor">DelegatingSecurityContextExecutor</a></li>
<li><a href="#truespring-security-concurrency">Spring Security Concurrency 并发类</a></li>
</ul>
</li>
<li><a href="#mvc">Spring MVC 整合</a>
<ul class="sectlevel2">
<li><a href="#mvc-enablewebmvcsecurity">@EnableWebMvcSecurity</a></li>
<li><a href="#mvc-requestmatcher">MvcRequestMatcher</a></li>
<li><a href="#mvc-authentication-principal">@AuthenticationPrincipal</a></li>
<li><a href="#mvc-async">Spring MVC 异步集成</a></li>
<li><a href="#mvc-csrf">Spring MVC 和 CSRF 整合</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#data">Spring Data 整合</a>
<ul class="sectlevel1">
<li><a href="#data-configuration">Spring 数据 &amp; Spring 安全配置</a></li>
<li><a href="#data-query">安全的表达 @Query</a></li>
</ul>
</li>
<li><a href="#trueappendix">Appendix</a>
<ul class="sectlevel1">
<li><a href="#appendix-schema">安全数据库模式</a>
<ul class="sectlevel2">
<li><a href="#true--36">用户模式</a></li>
<li><a href="#true-schema">持续登录 (记住我) Schema</a></li>
<li><a href="#dbschema-acl">ACL Schema</a></li>
</ul>
</li>
<li><a href="#appendix-namespace">安全空间</a>
<ul class="sectlevel2">
<li><a href="#nsa-web">Web应用安全</a></li>
<li><a href="#nsa-websocket-security">WebSocket 安全</a></li>
<li><a href="#nsa-authentication">认证服务</a></li>
<li><a href="#nsa-method-security">方法安全性</a></li>
<li><a href="#nsa-ldap">LDAP命名空间选项</a></li>
</ul>
</li>
<li><a href="#appendix-dependencies">Spring Security依赖关系</a>
<ul class="sectlevel2">
<li><a href="#truespring-security-core">spring-security-core</a></li>
<li><a href="#truespring-security-remoting">spring-security-remoting</a></li>
<li><a href="#truespring-security-web">spring-security-web</a></li>
<li><a href="#truespring-security-ldap">spring-security-ldap</a></li>
<li><a href="#truespring-security-config">spring-security-config</a></li>
<li><a href="#truespring-security-acl">spring-security-acl</a></li>
<li><a href="#truespring-security-cas">spring-security-cas</a></li>
<li><a href="#truespring-security-openid">spring-security-openid</a></li>
<li><a href="#truespring-security-taglibs">spring-security-taglibs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring security 是一个强大的和高度可定制的身份验证和访问控制框架。它是确保基于Spring的应用程序的标准。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true-"><a class="anchor" href="#true-"></a>前言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 为基于javaEE的企业应用程序提供一个全面的解决方案。正如你将从这个参考指南发现的，我们试图为你提供一个有用的并且高度可配置的安全系统。</p>
</div>
<div class="paragraph">
<p>安全是一个不断移动的目标，采取一个全面的全系统的方法很重要。在安全领域，我们鼓励你采取"layers of security"(安全层)，这样每一层尽可能的在自己范围内诶保证安全，连续的层提供额外的安全性。安全层更密集你的程序将更加健壮更加安全。在最底层，你需要处理传输安全和系统识别这些问题，以减少中间人攻击。接下来，你讲通常利用防火墙，或许使用VPN或者IP担保以确保只有授权的系统能够尝试连接。在企业环境中你可以部署一个DMZ将面向公众的服务器和数据库以及应用服务器分隔开来。你的操作系统也将扮演重要的部分，解决问题，类似，使用非特权用户运行进程和提高文件系统安全性。操作系统通常会配置自己的防火墙。但愿在某处前进的道路上，你会试图阻止拒绝服务和暴力攻击。一个入侵检测系统将在监视和相应攻击时非常有用，这种系统能采取保护动作，比如实时阻断违规的TCP/IP地址。在更高的层，你的java虚拟机希望被配置为尽量减少不同的java类型授予的权限，然后将你的应用程序增加到器自身的制定域特定的安全配置。Spring Security 使后者 ，应用程序将更加安全更加容易。</p>
</div>
<div class="paragraph">
<p>当然你需要妥善处理上面提到的所有安全层，连同各层的管理因素。这样的管理因素答题包括安全公告监测、补丁、人员审查、审计、变更控制、工程管理系统、数据备份、灾难恢复、性能基准测试、负载监控、集中式日志记录、事件相应程序等。</p>
</div>
<div class="paragraph">
<p>Spring Secruity 致力于在企业应用程序安全层对你进行帮助，你会发现这里有如此不同的需求正如业务问题的领域。一个银行应用程序具有与电子商务应用不同的需求。电子商务应用程序同企业销售自订花工具具有不同的需求。这些定制需求使得应用安全有趣、有挑战性和有回报。</p>
</div>
<div class="paragraph">
<p>请阅读<a href="#getting-started">入门</a>第二部分, 从“入门”开始。 这一章将为你介绍的框架和基于命名空间的配置系统，你可以配置好应用，来了解Spring Security 如何工作和一些你可能 需要使用的类 。你需要阅读 <a href="#overall-architecture">架构与实现</a>。本指南的其余部分是更传统的引用样式结构，设计用于按需进行阅读。我们也建议你尽可能于都完一般的应用安全问题。Spring Secruity 不是万能的，不能解决所有的安全问题。重要的实在应用设计开始之初就考虑到安全性。后期改造不是一个好的主意。特别是，如果你正在构件一个Web应用程序，你应该知道许多潜在的漏洞，比如跨站脚本、请求伪造和会话劫持。这些你一开始就应该考虑。这个网站 (<a href="http://www.owasp.org/" class="bare">http://www.owasp.org/</a>) 维护了一个大网站应用漏洞列表和一些有用的参考信息。</p>
</div>
<div class="paragraph">
<p>我希望这个参考手册对你来说比较有用，欢迎你的反馈和建议。 <a href="#jira">suggestions</a>.</p>
</div>
<div class="paragraph">
<p>最后欢迎你来到Spring Security 社区。 <a href="#community">community</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>入门</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本指南的稍后张杰会对框架的架构和实现类进行一个深度的讨论，如果你的相对Spring Security进行一个深度定制没这一章节将会包含你需要了解的内容。在本章我们将会介绍Spring Security 3.0 给项目的历史进行简要的概述，简单的讲讲如何开始使用设个框架。尤其是我们将看看命名空间配置，他提供与传统Spring Bean你必须连接所有实现类的途径更简单的方式保护你的应用程序。</p>
</div>
<div class="paragraph">
<p>我们也会看看实例应用。在你阅读后面的章节之前你指的试着运行体验它。当时你对框架连接更多的时候你还可以汇过来回顾一下。 <a href="http://spring.io/spring-security">project website</a> 同时请参阅项目的网站，因为他有创建这个项目的有用的信息，以及文章、视频和教程。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>简介</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="what-is-acegi-security"><a class="anchor" href="#what-is-acegi-security"></a>Spring Security是什么?</h3>
<div class="paragraph">
<p>Spring Security 提供了基于javaEE的企业应有个你软件全面的安全服务。这里特别强调支持使用SPring框架构件的项目，Spring框架是企业软件开发javaEE方案的领导者。如果你还没有使用Spring来开发企业应用程序，我们热忱的鼓励你仔细的看一看。熟悉Spring特别是一来注入原理两帮助你更快更方便的使用Spring Security。</p>
</div>
<div class="paragraph">
<p>人们使用Spring Secruity的原因有很多，单大部分都发现了javaEE的Servlet规范或EJB规范中的安全功能缺乏典型企业应用场景所需的深度。提到这些规范，重要的是要认识到他们在WAR或EAR级别无法移植。因此如果你更换服务器环境，这里有典型的大量工作去重新配置你的应用程序员安全到新的目标环境。使用Spring Security 解决了这些问题，也为你提供许多其他有用的，可定制的安全功能。</p>
</div>
<div class="paragraph">
<p>正如你可能知道的两个应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是Spring Security 的两个目标。“认证”，是建立一个他声明的主题的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）。“授权”指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立。这个概念是通用的而不只在Spring Security中。</p>
</div>
<div class="paragraph">
<p>在身份验证层，Spring Security 的支持多种认证模式。这些验证绝大多数都是要么由第三方提供，或由相关的标准组织，如互联网工程任务组开发。另外Spring Security 提供自己的一组认证功能。具体而言，Spring Security 目前支持所有这些技术集成的身份验证：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTP BASIC 认证头 (基于 IETF RFC-based 标准)</p>
</li>
<li>
<p>HTTP Digest 认证头 ( IETF RFC-based 标准)</p>
</li>
<li>
<p>HTTP X.509 客户端证书交换 ( IETF RFC-based 标准)</p>
</li>
<li>
<p>LDAP (一个非常常见的方法来跨平台认证需要, 尤其是在大型环境)</p>
</li>
<li>
<p>Form-based authentication (用于简单的用户界面)</p>
</li>
<li>
<p>OpenID 认证</p>
</li>
<li>
<p>Authentication based on pre-established request headers (such as Computer Associates Siteminder) 根据预先建立的请求有进行验证</p>
</li>
<li>
<p>JA-SIG Central Authentication Service (CAS，一个开源的SSO系统 )</p>
</li>
<li>
<p>Transparent authentication context propagation for Remote Method Invocation (RMI) and HttpInvoker (Spring远程协议)</p>
</li>
<li>
<p>Automatic "remember-me" authentication (你可以勾选一个框以避免预定的时间段再认证)</p>
</li>
<li>
<p>Anonymous authentication (让每一个未经验证的访问自动假设为一个特定的安全标识)</p>
</li>
<li>
<p>Run-as authentication (在一个访问应该使用不同的安全标识时非常有用)</p>
</li>
<li>
<p>Java Authentication and Authorization Service (JAAS)</p>
</li>
<li>
<p>JEE container autentication (所以如果愿你以可以任然使用容器管理的认证)</p>
</li>
<li>
<p>Kerberos</p>
</li>
<li>
<p>Java Open Source Single Sign On (JOSSO) *</p>
</li>
<li>
<p>OpenNMS Network Management Platform *</p>
</li>
<li>
<p>AppFuse *</p>
</li>
<li>
<p>AndroMDA *</p>
</li>
<li>
<p>Mule ESB *</p>
</li>
<li>
<p>Direct Web Request (DWR) *</p>
</li>
<li>
<p>Grails *</p>
</li>
<li>
<p>Tapestry *</p>
</li>
<li>
<p>JTrac *</p>
</li>
<li>
<p>Jasypt *</p>
</li>
<li>
<p>Roller *</p>
</li>
<li>
<p>Elastic Path *</p>
</li>
<li>
<p>Atlassian Crowd *</p>
</li>
<li>
<p>Your own authentication systems (see below)</p>
</li>
<li>
<p>表示由第三方提供</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>很多独立软件供应商，因为灵活的身份验证模式二选择Spring Security。这样做允许他们快速的集成到他们的终端客户需求的解决方案而不用进行大量工程或者改变客户的环境。如果上面的验证机制不符合你的需求，Spring Security 是一个开放的平台，要实现你 自己的验证机制检查。Spring Security 的许多企业用户需要与不遵循任何安全标准的“遗留”系统集成，Spring Security可以很好的与这类系统集成。</p>
</div>
<div class="paragraph">
<p>无论何种身份验证机制，Spring Security提供一套的授权功能。这里有三个主要的热点区域，授权web请求、授权方法是否可以被调用和授权访问单个域对象的实例。为了帮助让你分别了解这些差异，认识在Servlet规范网络模式安全的授权功能，EJB容器管理的安全性和文件系统的安全。Spring Security在这些重要的区域提供授权功能，我们将在手册后面进行介绍。</p>
</div>
</div>
<div class="sect2">
<h3 id="history"><a class="anchor" href="#history"></a>历史</h3>
<div class="paragraph">
<p>Spring Security 以“The Acegi Secutity System for Spring” 的名字始于2013年晚些时候。一个问题提交到Spring 开发者的邮件列表，询问是否已经有考虑一个机遇Spring 的安全性社区实现。那时候Spring 的社区相对较小（相对现在）。实际上Spring自己在2013年只是一个存在于ScourseForge的项目，这个问题的回答是一个值得研究的领域，虽然目前时间的缺乏组织了我们对它的探索。</p>
</div>
<div class="paragraph">
<p>考虑到这一点，一个简单的安全实现建成但是并没有发布。几周后，Spring社区的其他成员询问了安全性，这次这个代码被发送给他们。其他几个请求也跟随而来。到2014年一月大约有20万人使用了这个代码。这些创业者的人提出一个SourceForge项目加入是为了，这是在2004三月正式成立。</p>
</div>
<div class="paragraph">
<p>在早些时候，这个项目没有任何自己的验证模块，身份验证过程依赖于容器管理的安全性和Acegi安全性。而不是专注于授权。开始的时候这很适合，但是越来越多的用户请求额外的容器支持。容器特定的认证领域接口的基本限制变得清晰。还有一个相关的问题增加新的容器的路径，这是最终用户的困惑和错误配置的常见问题。</p>
</div>
<div class="paragraph">
<p>Acegi安全特定的认证服务介绍。大约一年后，Acegi安全正式成为了Spring框架的子项目。1.0.0最终版本是出版于2006 -在超过两年半的大量生产的软件项目和数以百计的改进和积极利用社区的贡献。</p>
</div>
<div class="paragraph">
<p>Acegi安全2007年底正式成为了Spring组合项目，更名为"Spring Security"。</p>
</div>
<div class="paragraph">
<p>如今Spring Security有一个强大的和积极的开源社区。在支持论坛上有成千上万的关于Spring Security的消息。有一个活跃的核心的开发人员，他们的代码本身和一个活跃的社区，也经常分享补丁和支持他们的同龄人。</p>
</div>
</div>
<div class="sect2">
<h3 id="release-numbering"><a class="anchor" href="#release-numbering"></a>发布版本号</h3>
<div class="paragraph">
<p>了解Spring Security发布版本号如何工作是很有用的，他可以帮助你识别出工作（或缺乏的功能）设计到参与迁移到项目的未来版本，每个发布使用3个整数，MAJOR.MINOR.PATCH（主版本、次要版本、补丁版本）.这样做的目的是主版本是不兼容的，API大范围的升级。次要版本应该保留大部分源代码和二进制兼容旧版本的次要版本，认为可能有一些设计变更和不兼容的更新。补丁版本应该向前向后完美兼容。包含一些bug和缺陷修复这些意外的改变。</p>
</div>
<div class="paragraph">
<p>在某种程度上，你受到变化的影响取决于你的代码是如何紧密集成的。如果你正在做大量定制，你更可能受到比简单的命名空间配置更大的影响。</p>
</div>
<div class="paragraph">
<p>你应该总是推出一个新版本之前彻底测试你的应用程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="get-spring-security"><a class="anchor" href="#get-spring-security"></a>Getting Spring Security</h3>
<div class="paragraph">
<p>你可以通过几种方式获取Spring Security。你可以从 <a href="http://spring.io/spring-security">Spring Security</a> 页面下载一个分发包。从Maven库下载分离的jar文件。另外你也可以从源代码自己编译。</p>
</div>
<div class="sect3">
<h4 id="maven"><a class="anchor" href="#maven"></a>使用Maven</h4>
<div class="paragraph">
<p>一个最小的SPring Security Maven 依赖通常和下面的类似:</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
&lt;!-- ... other dependency elements ... --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
	&lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;
	&lt;version&gt;{spring-security-version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
	&lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;
	&lt;version&gt;{spring-security-version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用的额外的功能比如LDAP，OpenID，等等，你需要包含适当的模块，查阅Section 1.4.3,"Project Modules" <a href="#modules">项目模块</a>.</p>
</div>
<div class="sect4">
<h5 id="maven-repositories"><a class="anchor" href="#maven-repositories"></a>Maven 仓库</h5>
<div class="paragraph">
<p>所有GA发布版本（版本号以.RELEASE结尾）都被部署到Maven Central ，所以不需要在你的pom里设置额外的库</p>
</div>
<div class="paragraph">
<p>如果你使用了一个 SNAPSHOT 版本，你需要确认你设置了Snapshot库，如下:</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
&lt;!-- ... possibly other repository elements ... --&gt;
&lt;repository&gt;
	&lt;id&gt;spring-snapshot&lt;/id&gt;
	&lt;name&gt;Spring Snapshot Repository&lt;/name&gt;
	&lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;
&lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你正在使用一个里程碑或者发布候选版本，你需要确保你所定义的Spring里程碑库，如下图所示:</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
&lt;!-- ... possibly other repository elements ... --&gt;
&lt;repository&gt;
	&lt;id&gt;spring-milestone&lt;/id&gt;
	&lt;name&gt;Spring Milestone Repository&lt;/name&gt;
	&lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;
&lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maven-bom"><a class="anchor" href="#maven-bom"></a>Spring 框架 Bom</h5>
<div class="paragraph">
<p>Spring Security是针对Spring 框架 4.1.6RELEASE 建立的{spring-version}, 但是快要与4.0.x正常工作。很多用户都会有这个问题，Spring Security 传递依赖解析到Spring框架4.1.6 RELEASE这可能导致奇怪的classpath问题。{spring-version}</p>
</div>
<div class="paragraph">
<p>规避这个问题的一种方式是在你的pom文件的 <a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management">&lt;dependencyManagement&gt;</a> 的部分.另一种办法是像下面这样在<code>pom.xml</code>中包含<code>spring-framework-bom</code>  <code>&lt;dependencyManagement&gt;</code>  :</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework&lt;/groupId&gt;
		&lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;
		&lt;version&gt;{spring-version}&lt;/version&gt;
		&lt;type&gt;pom&lt;/type&gt;
		&lt;scope&gt;import&lt;/scope&gt;
	&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样将确保Spring Security传递的所有依赖都使用 Spring 4.16.RELEASE {spring-version} 模块.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这种但是使用了 Maven&#8217;s "bill of materials" (BOM) 概念， Maven 2.0.9+可用. 如果想了解Maven如何解析依赖请参考Maven的依赖机制文档的介绍。 <a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">Maven&#8217;s Introduction to the Dependency Mechanism documentation</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gradle"><a class="anchor" href="#gradle"></a>Gradle</h4>
<div class="paragraph">
<p>最小的Gradle一组典型的依赖如下:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">dependencies {
	compile 'org.springframework.security:spring-security-web:{spring-security-version}'
	compile 'org.springframework.security:spring-security-config:{spring-security-version}'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用了 LDAP, OpenID, 等等. 你需要包含相应的模块，请参阅“Project Modules” <a href="#modules">项目模块</a>.</p>
</div>
<div class="sect4">
<h5 id="gradle-repositories"><a class="anchor" href="#gradle-repositories"></a>Gradle Repositories</h5>
<div class="paragraph">
<p>所有的GA版本 (以.RELEASE结尾)都部署到了Maven Central库, 所以使用mavenCentral()库就足够了 .</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">repositories {
	mavenCentral()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你正在使用SNAPSHOT版本，你需要确保你使用了Spring的Snapshot库，定义如下:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">repositories {
	maven { url 'https://repo.spring.io/snapshot' }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你正在使用里程碑或者发布候选版。你需要确认你使用了SPring的里程碑仓库，定义如下:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">repositories {
	maven { url 'https://repo.spring.io/milestone' }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="gradle-resolutionStrategy"><a class="anchor" href="#gradle-resolutionStrategy"></a>使用 Spring 4.0.x 和 Gradle</h5>
<div class="paragraph">
<p>解析依赖传递是Gradle默认会使用最新的版本。这意为这当在Spring4.1.6RELEASE 下使用Spring Security 4.0.2RELEASE我们不需要做额外的工作。 {spring-security-version} {spring-version} 然而有时出现一些问题，最好适应Gradle的ResolutionStrategy 按照下面这种方式处理 <a href="http://www.gradle.org/docs/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html">Gradle&#8217;s ResolutionStrategy</a>:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">configurations.all {
	resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
		if (details.requested.group == 'org.springframework') {
			details.useVersion '{spring-version}'
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样将确保Spring Security 传递的依赖使用Spring 4.1.6.RELEASE {spring-version}模块.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这个例子使用 Gradle 1.9,但可能需要在gradle的未来版本中进行修改，因为这是在一个Gradle的孵化功能.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="modules"><a class="anchor" href="#modules"></a>项目模块</h4>
<div class="paragraph">
<p>在 Spring Security 3.0, 代码库被分割到单独的jar，这样可以更清楚的分隔不用功能区域和第三方依赖。如果你使用Maven构建你的项目，那么这些都是需要你添加到你的<code>pom.xml</code>中的. 甚至你没有使用Maven，我们建议你请求<code>pom.xml</code>文件来获取第三方依赖和版本。另一个好办法是检查实例应用程序的库。</p>
</div>
<div class="sect4">
<h5 id="spring-security-core"><a class="anchor" href="#spring-security-core"></a>核心模块 - spring-security-core.jar</h5>
<div class="paragraph">
<p>包含核心的验证和访问控制类和接口，远程支持和基本的配置API。任何使用Spring Security的应用程序都需要这个模块。支持独立应用程序、远程客户端、服务层方法安全和JDBC用户配置。包含以下顶层包:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.security.core</code></p>
</li>
<li>
<p><code>org.springframework.security.access</code></p>
</li>
<li>
<p><code>org.springframework.security.authentication</code></p>
</li>
<li>
<p><code>org.springframework.security.provisioning</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="spring-security-remoting"><a class="anchor" href="#spring-security-remoting"></a>远程调用 - spring-security-remoting.jar</h5>
<div class="paragraph">
<p>提供与Spring Remoting的集成，通常你不需要这个模块，除非你挣使用Spring Remoting编写远程客户端。主要的包是
<code>org.springframework.security.remoting</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-security-web"><a class="anchor" href="#spring-security-web"></a>网页 - spring-security-web.jar</h5>
<div class="paragraph">
<p>包括锅炉汽和网站安全相关的基础代码。使用Servlet API的任何应用依赖他。如果你需要Spring Security网页验证服务和基于URL的访问控制你需要这个模块。主包名为 <code>org.springframework.security.web</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-security-config"><a class="anchor" href="#spring-security-config"></a>配置 - spring-security-config.jar</h5>
<div class="paragraph">
<p>包含安全命令空间的解析代码。如果你使用Spring Security XML命令空间进行配置你需要包含这个模块。
主包名为<code>org.springframework.security.config</code>.
没有类需要被应用程序直接使用.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-security-ldap"><a class="anchor" href="#spring-security-ldap"></a>LDAP - spring-security-ldap.jar</h5>
<div class="paragraph">
<p>LDAP验证和配置代码，如果你需要使用LDAP验证和管理LDAP用户实体，你需要这个模块。主包名为 <code>org.springframework.security.ldap</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-security-acl"><a class="anchor" href="#spring-security-acl"></a>ACL访问控制表 - spring-security-acl.jar</h5>
<div class="paragraph">
<p>ACL专门的领域对象的实现。用来在你的应用程序中应用安全特定的领域对象实例。主包名为 <code>org.springframework.security.acls</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-security-cas"><a class="anchor" href="#spring-security-cas"></a>CAS - spring-security-cas.jar</h5>
<div class="paragraph">
<p>Spring Security的CAS客户端集成。如果你想用CAS的SSO服务器使用Spring Security网页验证需要该模块。顶层的包是 <code>org.springframework.security.cas</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-security-openid"><a class="anchor" href="#spring-security-openid"></a>OpenID - spring-security-openid.jar</h5>
<div class="paragraph">
<p>OpenID 网页验证支持。使用外部的OpenID服务器验证用户。 <code>org.springframework.security.openid</code>. 需要 OpenID4Java.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-security-test"><a class="anchor" href="#spring-security-test"></a>Test - spring-security-test.jar</h5>
<div class="paragraph">
<p>支持Spring Security的测试。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="get-source"><a class="anchor" href="#get-source"></a>签出源代码</h4>
<div class="paragraph">
<p>因为Spring Security是一个开源项目，我们强烈建议您使用Git签出源代码。这可以让你完全访问所有势力应用程序，你可以轻松地构建最先进的最新版本的项目。有了项目的源代码对debug有非常大的帮助。异常堆栈跟踪不再是模糊的黑盒问题，你可以沿着他找出到底发生了什么。源代码是中级文档，通常也是最简答的项目实际是如何工作的地方。</p>
</div>
<div class="paragraph">
<p>要获取项目源代码，请使用一下git命令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt" data-lang="txt">git clone https://github.com/spring-projects/spring-security.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以让你在本地机器上访问到整个项目的历史记录（包括所有版本和分支）.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="new"><a class="anchor" href="#new"></a>Spring Security 4.1新特性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 4.1 新特性有关的链接 <a href="https://github.com/spring-projects/spring-security/issues?utf8=%E2%9C%93&amp;q=milestone%3A%224.1.0+RC1%22">100+ RC1 issues</a> and <a href="https://github.com/spring-projects/spring-security/issues?utf8=%E2%9C%93&amp;q=milestone%3A%224.1.0+RC2%22">60+ RC2 issues</a>
这里是新特性的列表:</p>
</div>
<div class="sect2">
<h3 id="truejava"><a class="anchor" href="#truejava"></a>Java 配置提升</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#jc-authentication-userdetailsservice">Simplified UserDetailsService Java Configuration</a></p>
</li>
<li>
<p><a href="#jc-authentication-authenticationprovider">Simplified AuthenticationProvider Java Configuration</a></p>
</li>
<li>
<p>通过 <code>LogoutConfigurer</code>配置内容谈判 <code>LogoutSuccessHandler</code>(s)</p>
</li>
<li>
<p>通过<code>SessionManagementConfigurer</code>可配置<code>InvalidSessionStrategy</code></p>
</li>
<li>
<p>使用<code>HttpSecurity.addFilterAt</code>在链中的特定位置添加一个<code>Filter</code>的能力</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="trueweb"><a class="anchor" href="#trueweb"></a>Web应用程序安全性提升</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#mvc-requestmatcher">MvcRequestMatcher</a></p>
</li>
<li>
<p><a href="#headers-csp">Content Security Policy (CSP)</a></p>
</li>
<li>
<p><a href="#headers-hpkp">HTTP Public Key Pinning (HPKP)</a></p>
</li>
<li>
<p><a href="#cors">CORS</a></p>
</li>
<li>
<p><a href="#csrf-cookie">CookieCsrfTokenRepository</a> 提供简单的 AngularJS 与 CSRF 整合</p>
</li>
<li>
<p>添加 <code>ForwardAuthenticationFailureHandler</code> 和 <code>ForwardAuthenticationSuccessHandler</code></p>
</li>
<li>
<p><a href="#mvc-authentication-principal">AuthenticationPrincipal</a> 支持表达式属性从而支持转换 <code>Authentication.getPrincipal()</code> 对象 (即处理不可变的自定义的<code>User</code>域对象)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="true--2"><a class="anchor" href="#true--2"></a>授权改进</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#el-access-web-path-variables">Path Variables in Web Security Expressions</a></p>
</li>
<li>
<p><a href="#method-security-meta-annotations">Method Security Meta Annotations</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="true--3"><a class="anchor" href="#true--3"></a>密码模块的改进</h3>
<div class="ulist">
<ul>
<li>
<p>SCrypt 支持 <code>SCryptPasswordEncoder</code></p>
</li>
<li>
<p>PBKDF2 支持 <a href="#spring-security-crypto-passwordencoders">Pbkdf2PasswordEncoder</a></p>
</li>
<li>
<p>BouncyCastle 中新改进的 <code>BytesEncryptor</code> 使用 <em>AES/CBC/PKCS5Padding</em> 和 <em>AES/GCM/NoPadding</em> 算法</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="true--4"><a class="anchor" href="#true--4"></a>测试的改进</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#test-method-withanonymoususer">@WithAnonymousUser</a></p>
</li>
<li>
<p><a href="#test-method-withuserdetails">@WithUserDetails</a> 允许指定 <code>UserDetailsService</code> bean 名称</p>
</li>
<li>
<p><a href="#test-method-meta-annotations">Test Meta Annotations</a></p>
</li>
<li>
<p>模拟一个列表的能力<code>GrantedAuthority</code> 使用 <code>SecurityMockMvcResultMatchers.withAuthorities</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="true--5"><a class="anchor" href="#true--5"></a>一般的改进</h3>
<div class="ulist">
<ul>
<li>
<p>重新组织样本项目</p>
</li>
<li>
<p>移动到GitHub的问题</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="samples"><a class="anchor" href="#samples"></a>样品和指南 (Start Here)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您想从Spring Security开始，最好的从我们的示例应用程序开始。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Sample Applications</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">源</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">指南</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{gh-samples-url}/javaconfig/helloworld[Hello Spring Security]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">演示如何整合Spring Security和基于java的配置的现有应用程序。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接:../../guides/html5/helloworld-javaconfig.html[Hello Spring Security Guide]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{gh-samples-url}/boot/helloworld[Hello Spring Security Boot]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">演示如何整合Spring Security和 Spring Boot应用程序。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接:../../guides/html5/helloworld-boot.html[Hello Spring Security Boot Guide]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{gh-samples-url}/xml/helloworld[Hello Spring Security XML]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">演示如何整合Spring Security和基于XML配置使用的现有应用程序。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接:../../guides/html5/helloworld-xml.html[Hello Spring Security XML Guide]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{gh-samples-url}/javaconfig/hellomvc[Hello Spring MVC Security]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">演示如何整合Spring Security和Spring MVC 应用程序。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接:../../guides/html5/hellomvc-javaconfig.html[Hello Spring MVC Security Guide]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{gh-samples-url}/javaconfig/form[Custom Login Form]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">演示如何创建自定义表单。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接:../../guides/html5/form-javaconfig.html[Custom Login Form Guide]</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="jc"><a class="anchor" href="#jc"></a>Java 配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>java配置的支持主要在Spring框架的3.1加入. <a href="http://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java">Java Configuration</a>. Spring Security 从3.2开始加入java配置支持。这让用户不使用任何XML用更简单方式配置Spring Security。</p>
</div>
<div class="paragraph">
<p>如果你熟悉第四章，安全命名空间配置，<a href="#ns-config">安全命名空间配置</a> 你应该找到它和java的安全配置支持之间的相当多的相似之处.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security 提供大量的示例应用 <a href="https://github.com/spring-projects/spring-security/tree/master/samples">lots of sample applications</a> 使用<code>-jc</code>参数演示使用java配置Spring Security。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="true-java"><a class="anchor" href="#true-java"></a>基础的网站安全java配置</h3>
<div class="paragraph">
<p>第一步是创建我们的java配置。这个配置在你的应用程序中创建一个springSecurityFilterChain 的Servlet的过滤器 <code>springSecurityFilterChain</code>负责所有安全（例如 保护应用程序的URL，验证提交的用户名和密码，重定向到登陆的表单等等）。你可以在下面找到大部分java配置项的例子:</p>
</div>
<div id="jc-hello-wsca" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.*;
import org.springframework.security.config.annotation.authentication.builders.*;
import org.springframework.security.config.annotation.web.configuration.*;

@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		auth
			.inMemoryAuthentication()
				.withUser("user").password("password").roles("USER");
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
configureGlobal方法的名字不重要，然而，重要的是只在一个被<code>@EnableWebSecurity</code>, <code>@EnableGlobalMethodSecurity</code>，或者<code>@EnableGlobalAuthentication</code>注解的类中配置AuthenticationManagerBuilder，否则会有不可预知的后果。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>真的是没有太多的配置，但它确实有很多功能，你可以在下面找到功能摘要:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在你的应用程序中对每个URL进行验证</p>
</li>
<li>
<p>为你生成一个登陆表单</p>
</li>
<li>
<p>允许使用用户名 <strong>Username</strong> <em>user</em> 和密码 <strong>Password</strong> <em>password</em> 使用验证表单进行验证。</p>
</li>
<li>
<p>允许用户登出</p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF attack</a> CSPF攻击防范</p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Session_fixation">Session Fixation</a> Session保护</p>
</li>
<li>
<p>安全 Header 集成</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HTTP Strict Transport Security</a> 对安全要求严格的HTTP传输安全</p>
</li>
<li>
<p><a href="http://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx">X-Content-Type-Options</a> X-Content-Type-Options集成</p>
</li>
<li>
<p>缓存控制（稍后可以允许你缓存静态资源）</p>
</li>
<li>
<p><a href="http://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx">X-XSS-Protection</a> X-XSS-Protection集成</p>
</li>
<li>
<p>X-Frame-Options 集成防止点击劫持 <a href="http://en.wikipedia.org/wiki/Clickjacking">Clickjacking</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>和以下 Servlet API 方法集成</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()">HttpServletRequest#getRemoteUser()</a></p>
</li>
<li>
<p><a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()">HttpServletRequest.html#getUserPrincipal()</a></p>
</li>
<li>
<p><a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)">HttpServletRequest.html#isUserInRole(java.lang.String)</a></p>
</li>
<li>
<p><a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String,%20java.lang.String)">HttpServletRequest.html#login(java.lang.String, java.lang.String)</a></p>
</li>
<li>
<p><a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout()">HttpServletRequest.html#logout()</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="trueabstractsecuritywebapplicationinitializer"><a class="anchor" href="#trueabstractsecuritywebapplicationinitializer"></a>AbstractSecurityWebApplicationInitializer</h4>
<div class="paragraph">
<p>下一步是在war里注册<code>springSecurityFilterChain</code>。这可以通过Spring在Servlet 3.0+环境中对  <a href="http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-container-config">Spring&#8217;s WebApplicationInitializer support</a>WebApplicationInitializer的支持进行了java配置，Spring Security提供了基本的抽象类 <code>AbstractSecurityWebApplicationInitializer</code>这可以确保<code>springSecurityFilterChain</code> 已经被注册。我们使用<code>AbstractSecurityWebApplicationInitializer</code> 的不同方式取决于你是已经在使用Spring框架还是只是用了Spring Security。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#abstractsecuritywebapplicationinitializer-without-existing-spring">[abstractsecuritywebapplicationinitializer-without-existing-spring]</a> - 如果你没有使用框架就使用这个说明</p>
</li>
<li>
<p><a href="#abstractsecuritywebapplicationinitializer-with-spring-mvc">[abstractsecuritywebapplicationinitializer-with-spring-mvc]</a> - 如果你正在使用Spring框架使用这个说明</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="trueabstractsecuritywebapplicationinitializer-spring"><a class="anchor" href="#trueabstractsecuritywebapplicationinitializer-spring"></a>AbstractSecurityWebApplicationInitializer 不与Spring一起使用</h4>
<div class="paragraph">
<p>如果你没有使用Spring MVC 或Spring，你需要传递 <code>WebSecurityConfig</code> 到超类来确保配置被使用，你可以参考下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

	public SecurityWebApplicationInitializer() {
		super(WebSecurityConfig.class);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>SecurityWebApplicationInitializer</code> 将会做下面的事情:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自动为你的应用程序的每个URL注册 <code>springSecurityFilterChain</code>过滤器</p>
</li>
<li>
<p>添加一个<code>ContextLoadListener</code> 用来载入 <a href="#jc-hello-wsca">WebSecurityConfig</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="trueabstractsecuritywebapplicationinitializer-spring-mvc"><a class="anchor" href="#trueabstractsecuritywebapplicationinitializer-spring-mvc"></a>AbstractSecurityWebApplicationInitializer 与 Spring MVC一起使用</h4>
<div class="paragraph">
<p>如果我们在应用程序的其他地方已经使用了Spring，那么我们已经有了一个 <code>WebApplicationInitializer</code>用来载入Spring的配置。如果我们使用上面的配置将会得到一个错误。所以我们应该使用已经存在的 <code>ApplicationContext</code> 注册Spring Security。举个例子，如果我们使用Spring MVC我们的 <code>SecurityWebApplicationInitializer</code> 应该看起来和下面差不多:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这回简单的只为你的应用程序的所有URL注册springSecurityChain过滤器。然后我们需要确保这个Security配置被载入到我们已经存在的 <code>WebSecurityConfig</code>。例如，如果你使用Spring MVC 它应该被加入到 <code>getRootConfigClasses()</code></p>
</div>
<div id="message-web-application-inititializer-java" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MvcWebApplicationInitializer extends
		AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class&lt;?&gt;[] getRootConfigClasses() {
		return new Class[] { WebSecurityConfig.class };
	}

	// ... other overrides ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jc-httpsecurity"><a class="anchor" href="#jc-httpsecurity"></a>HttpSecurity</h3>
<div class="paragraph">
<p>到目前为止我们的<a href="#jc-hello-wsca">WebSecurityConfig</a>只包含了关于如何验证我们的用户的信息。Spring Security怎么知道我们相对所有的用户进行验证？Spring Securityn怎么知道我们需要支持基于表单的验证？原因是<code>WebSecurityConfigurerAdapter</code>在<code>configure(HttpSecurity http)</code>方法中提供了一个默认的配置，看起来和下面类似:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.and()
		.formLogin()
			.and()
		.httpBasic();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的默认配置:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保我们应用中的所有请求都需要用户被认证</p>
</li>
<li>
<p>允许用户进行基于表单的认证</p>
</li>
<li>
<p>允许用户使用HTTP基于验证进行认证</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以看到这个配置和下面的XML命名配置相似:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/**" access="authenticated"/&gt;
	&lt;form-login /&gt;
	&lt;http-basic /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>java配置使用<code>and()</code>方法相当于XML标签的关闭。 这样允许我们继续配置父类节点。如果你阅读代码很合理，想配置请求验证， 并使用表单和HTTP基本身份验证进行登录。</p>
</div>
<div class="paragraph">
<p>然而，java配置有不同的默认URL和参数，当你自定义用户登录页是需要牢记这一点。让我们的URL冯家RESTful，另外不要那么明显的观察出我么你在使用Spring Security这样帮助我们避免信息泄露。 <a href="https://www.owasp.org/index.php/Information_Leak_(information_disclosure)">information leaks</a>。比如：</p>
</div>
</div>
<div class="sect2">
<h3 id="jc-form"><a class="anchor" href="#jc-form"></a>Java配置和表单登录</h3>
<div class="paragraph">
<p>你可能会想知道系统提示您登录表单从哪里来的，因为我们都没有提供任何的HTML或JSP文件。由于Spring Security的默认配置并没有明确设定一个登录页面的URL，Spring Security自动生成一个，基于这个功能被启用，使用默认URL处理登录的提交内容，登录后跳转的URL等等。</p>
</div>
<div class="paragraph">
<p>自动生成的登录页面可以方便应用的快速启动和运行，大多数应用程序都需要提供自己的登录页面。要做到这一点，我们可以更新我们的配置，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.and()
		.formLogin()
			.loginPage("/login") <i class="conum" data-value="1"></i><b>(1)</b>
			.permitAll();        <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>指定登录页的路径</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们必须允许所有用户访问我们的登录页（例如为验证的用户），这个<code>formLogin().permitAll()</code>方法允许基于表单登录的所有的URL的所有用户的访问。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一个我么当前配置使用的JSP实现的页面如下：</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
下面这个登陆页是我们的当前配置，如果不符合我们的要求我们可以很容易的更新我们的配置。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html" data-lang="html">&lt;c:url value="/login" var="loginUrl"/&gt;
&lt;form action="${loginUrl}" method="post"&gt;       <i class="conum" data-value="1"></i><b>(1)</b>
	&lt;c:if test="${param.error != null}"&gt;        <i class="conum" data-value="2"></i><b>(2)</b>
		&lt;p&gt;
			Invalid username and password.
		&lt;/p&gt;
	&lt;/c:if&gt;
	&lt;c:if test="${param.logout != null}"&gt;       <i class="conum" data-value="3"></i><b>(3)</b>
		&lt;p&gt;
			You have been logged out.
		&lt;/p&gt;
	&lt;/c:if&gt;
	&lt;p&gt;
		&lt;label for="username"&gt;Username&lt;/label&gt;
		&lt;input type="text" id="username" name="username"/&gt;	<i class="conum" data-value="4"></i><b>(4)</b>
	&lt;/p&gt;
	&lt;p&gt;
		&lt;label for="password"&gt;Password&lt;/label&gt;
		&lt;input type="password" id="password" name="password"/&gt;	<i class="conum" data-value="5"></i><b>(5)</b>
	&lt;/p&gt;
	&lt;input type="hidden"                        <i class="conum" data-value="6"></i><b>(6)</b>
		name="${_csrf.parameterName}"
		value="${_csrf.token}"/&gt;
	&lt;button type="submit" class="btn"&gt;Log in&lt;/button&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>一个POST请求到<code>/login</code>用来验证用户</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果参数有<code>error</code>, 验证尝试失败</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果请求蚕食<code>logout</code>存在则登出</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>登录名参数必须被命名为<em>username</em></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>密码参数必须被命名为<em>password</em></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>CSRF参数，了解更多查阅后续 <a href="#csrf-include-csrf-token">包括CSRF令牌</a> 和<a href="#csrf">Cross Site Request Forgery (CSRF)</a> 相关章节</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="true--6"><a class="anchor" href="#true--6"></a>验证请求</h3>
<div class="paragraph">
<p>我们的例子中要求用户进行身份验证并且在我们应用程序的每个URL这样做。我么你可以通过给<code>http.authorizeRequests()</code>添加多个子节点来指定多个定制需求到我们的URL。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()                                                                <i class="conum" data-value="1"></i><b>(1)</b>
			.antMatchers("/resources/**", "/signup", "/about").permitAll()                  <i class="conum" data-value="2"></i><b>(2)</b>
			.antMatchers("/admin/**").hasRole("ADMIN")                                      <i class="conum" data-value="3"></i><b>(3)</b>
			.antMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')")            <i class="conum" data-value="4"></i><b>(4)</b>
			.anyRequest().authenticated()                                                   <i class="conum" data-value="5"></i><b>(5)</b>
			.and()
		// ...
		.formLogin();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>http.authorizeRequests()</code>方法有多个子节点，每个macher按照他们的声明顺序执行。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们指定任何用户都可以通过访问的多个URL模式。任何用户都可以访问URL以"/resources/", equals "/signup", 或者 "/about"开头的URL。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>以 "/admin/" 开头的URL只能由拥有 "ROLE_ADMIN"角色的用户访问。请注意我们使用 <code>hasRole</code> 方法，没有使用 "ROLE_" 前缀.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>任何以"/db/" 开头的URL需要用户同时具有 "ROLE_ADMIN" 和 "ROLE_DBA"。和上面一样我们的 <code>hasRole</code> 方法也没有使用 "ROLE_" 前缀.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>尚未匹配的任何URL要求用户进行身份验证</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jc-logout"><a class="anchor" href="#jc-logout"></a>处理登出</h3>
<div class="paragraph">
<p>当使用<code><a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.html">WebSecurityConfigurerAdapter</a></code>,
注销功能会自动应用。默认是访问URL`/logout`将注销登陆的用户：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使HTTP Session 无效</p>
</li>
<li>
<p>清楚所有已经配置的 RememberMe 认证</p>
</li>
<li>
<p>清除<code>SecurityContextHolder</code></p>
</li>
<li>
<p>跳转到 <code>/login?logout</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>和登录功能类似，你也有不同的选项来定制你的注销功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		.logout()                                                                <i class="conum" data-value="1"></i><b>(1)</b>
			.logoutUrl("/my/logout")                                                 <i class="conum" data-value="2"></i><b>(2)</b>
			.logoutSuccessUrl("/my/index")                                           <i class="conum" data-value="3"></i><b>(3)</b>
			.logoutSuccessHandler(logoutSuccessHandler)                              <i class="conum" data-value="4"></i><b>(4)</b>
			.invalidateHttpSession(true)                                             <i class="conum" data-value="5"></i><b>(5)</b>
			.addLogoutHandler(logoutHandler)                                         <i class="conum" data-value="6"></i><b>(6)</b>
			.deleteCookies(cookieNamesToClear)                                       <i class="conum" data-value="7"></i><b>(7)</b>
			.and()
		...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>提供注销支持，使用<code>WebSecurityConfigurerAdapter</code>会自动被应用。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置触发注销操作的URL (默认是<code>/logout</code>). 如果CSRF内启用（默认是启用的）的话这个请求的方式被限定为POST。 请查阅相关信息 <a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutUrl(java.lang.String)">JavaDoc</a>相关信息.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>注销之后跳转的URL。默认是<code>/login?logout</code>。具体查看 the <a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessUrl(java.lang.String)">JavaDoc</a>文档.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>让你设置定制的 <code>LogoutSuccessHandler</code>。如果指定了这个选项那么<code>logoutSuccessUrl()</code>的设置会被忽略。请查阅 <a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessHandler(org.springframework.security.web.authentication.logout.LogoutSuccessHandler)">JavaDoc</a>文档.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>指定是否在注销时让<code>HttpSession</code>无效。 默认设置为 <strong>true</strong>。 在内部配置<code>SecurityContextLogoutHandler</code>选项。 请查阅 <a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#invalidateHttpSession(boolean)">JavaDoc</a>文档.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>添加一个<code>LogoutHandler</code>.默认<code>SecurityContextLogoutHandler</code>会被添加为最后一个<code>LogoutHandler</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>允许指定在注销成功时将移除的cookie。这是一个现实的添加一个<code>CookieClearingLogoutHandler</code>的快捷方式。</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注销也可以通过XML命名空间进行配置，请参阅Spring Security XML命名空间相关文档获取更多细节<a href="#nsa-logout">logout element</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一般来说，为了定制注销功能，你可以添加
<code><a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/logout/LogoutHandler.html">LogoutHandler</a></code>和<code><a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html">LogoutSuccessHandler</a></code>的实现。 对于许多常见场景，当使用流食式API时，这些处理器会在幕后进行添加。</p>
</div>
<div class="sect3">
<h4 id="jc-logout-handler"><a class="anchor" href="#jc-logout-handler"></a>LogoutHandler</h4>
<div class="paragraph">
<p>一般来说，<code><a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/logout/LogoutHandler.html">LogoutHandler</a></code>的实现类可以参阅到注销处理中。他们被用来执行必要的清理，因而他们不应该抛出错误，我们提供您各种实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.html">PersistentTokenBasedRememberMeServices</a></p>
</li>
<li>
<p><a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/rememberme/TokenBasedRememberMeServices.html">TokenBasedRememberMeServices</a></p>
</li>
<li>
<p><a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/logout/CookieClearingLogoutHandler.html">CookieClearingLogoutHandler</a></p>
</li>
<li>
<p><a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/csrf/CsrfLogoutHandler.html">CsrfLogoutHandler</a></p>
</li>
<li>
<p><a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html">SecurityContextLogoutHandler</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请查看 <a href="#remember-me-impls">Remember-Me的接口和实现</a> 获取详情。</p>
</div>
<div class="paragraph">
<p>流式API提供了调用相应的<code>LogoutHandler</code> 实现的快捷方式, 而不是直接提供<code>LogoutHandler</code> 的实现。例如：<code>deleteCookies()</code> 允许指定注销成功时要删除一个或者多个cookie。这是一个添加 <code>CookieClearingLogoutHandler</code>的快捷方式。</p>
</div>
</div>
<div class="sect3">
<h4 id="jc-logout-success-handler"><a class="anchor" href="#jc-logout-success-handler"></a>LogoutSuccessHandler</h4>
<div class="paragraph">
<p><code>LogoutSuccessHandler</code>被<code>LogoutFilter</code>在成功注销后调用，用来进行重定向或者转发相应的目的地。注意这个借口与<code>LogoutHandler</code>几乎一样，但是可以抛出异常。</p>
</div>
<div class="paragraph">
<p>下面是提供的一些实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/logout/SimpleUrlLogoutSuccessHandler.html">SimpleUrlLogoutSuccessHandler</a></p>
</li>
<li>
<p>HttpStatusReturningLogoutSuccessHandler</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>和前面提到的一样，你不需要直接指定<code>SimpleUrlLogoutSuccessHandler</code>。而使用流式API通过设置<code>logoutSuccessUrl()</code>快捷的进行设置<code>SimpleUrlLogoutSuccessHandler</code>。注销成功 后将重定向到设置的URL地址。默认的地址是 <code>/login?logout</code>.</p>
</div>
<div class="paragraph">
<p>在REST API场景中<code>HttpStatusReturningLogoutSuccessHandler</code>会进行一些有趣的改变。<code>LogoutSuccessHandler</code>允许你设置一个返回给客户端的HTTP状态码（默认返回200）来替换重定向到URL这个动作。</p>
</div>
</div>
<div class="sect3">
<h4 id="jc-logout-references"><a class="anchor" href="#jc-logout-references"></a>进一步的注销相关的参考（TODO）</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#ns-logout">处理注销</a></p>
</li>
<li>
<p><a href="#test-logout">测试注销</a></p>
</li>
<li>
<p><a href="#servletapi-logout">HttpServletRequest.logout()</a></p>
</li>
<li>
<p><a href="#remember-me-impls">章节"Remember-Me接口和实现"</a></p>
</li>
<li>
<p><a href="#csrf-logout">注销的CSRF说明</a></p>
</li>
<li>
<p><a href="#cas-singlelogout">点点注销（CAS协议）</a></p>
</li>
<li>
<p><a href="#nsa-logout">注销的XML命名空间章节</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jc-authentication"><a class="anchor" href="#jc-authentication"></a>验证</h3>
<div class="paragraph">
<p>到现在为止我们只看了一下基本的验证配置，让我们看看一些稍微高级点的身份验证配置选项。</p>
</div>
<div class="sect3">
<h4 id="jc-authentication-inmememory"><a class="anchor" href="#jc-authentication-inmememory"></a>内存中的身份验证</h4>
<div class="paragraph">
<p>我们已经看到了一个单用户配置到内存验证的示例，下面是配置多个用户的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	auth
		.inMemoryAuthentication()
			.withUser("user").password("password").roles("USER").and()
			.withUser("admin").password("password").roles("USER", "ADMIN");
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jc-authentication-jdbc"><a class="anchor" href="#jc-authentication-jdbc"></a>JDBC 验证</h4>
<div class="paragraph">
<p>你可以找一些更新来支持JDBC的验证。下面的例子假设你已经在应用程序中定义好了<code>DataSource</code>， <a href="https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig/jdbc">jdbc-javaconfig</a> 示例提供了一个完整的基于JDBC的验证。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	auth
		.jdbcAuthentication()
			.dataSource(dataSource)
			.withDefaultSchema()
			.withUser("user").password("password").roles("USER").and()
			.withUser("admin").password("password").roles("USER", "ADMIN");
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueldap"><a class="anchor" href="#trueldap"></a>LDAP 验证</h4>
<div class="paragraph">
<p>你可以找一些更新来支持LDAP的身份验证，
<a href="https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig/ldap">ldap-javaconfig</a> 提供了一个完成的使用基于LDAP的身份验证的示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	auth
		.ldapAuthentication()
			.userDnPatterns("uid={0},ou=people")
			.groupSearchBase("ou=groups");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的例子中使用一下LDIF和前如何Apache DS LDAP示例。</p>
</div>
<div class="listingblock">
<div class="title">users.ldif</div>
<div class="content">
<pre>dn: ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: groups

dn: ou=people,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: people

dn: uid=admin,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Rod Johnson
sn: Johnson
uid: admin
userPassword: password

dn: uid=user,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Dianne Emu
sn: Emu
uid: user
userPassword: password

dn: cn=user,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: user
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
uniqueMember: uid=user,ou=people,dc=springframework,dc=org

dn: cn=admin,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: admin
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jc-authentication-authenticationprovider"><a class="anchor" href="#jc-authentication-authenticationprovider"></a>AuthenticationProvider</h4>
<div class="paragraph">
<p>您可以通过一个自定义的<code>AuthenticationProvider</code>为bean定义自定义身份验证。
例如， 下面这个例子假设自定义身份验证<code>SpringAuthenticationProvider</code>实现了<code>AuthenticationProvider</code>:</p>
</div>
<div class="paragraph">
<p>NOTE:`AuthenticationManagerBuilder`如果还不密集这将仅被使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public SpringAuthenticationProvider springAuthenticationProvider() {
	return new SpringAuthenticationProvider();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jc-authentication-userdetailsservice"><a class="anchor" href="#jc-authentication-userdetailsservice"></a>UserDetailsService</h4>
<div class="paragraph">
<p>你可以通过一个自定义的<code>UserDetailsService</code>为bean定义自定义身份验证。
例如，下面这个例子假设自定义身份验证<code>SpringDataUserDetailsService</code>实现了<code>UserDetailsService</code>:</p>
</div>
<div class="paragraph">
<p>NOTE:`AuthenticationManagerBuilder`如果还不密集这将被仅被使用并且没有<code>AuthenticationProviderBean</code>申明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public SpringDataUserDetailsService springDataUserDetailsService() {
	return new SpringDataUserDetailsService();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以通过让<code>passwordencoder</code>为bean自定义密码如何编码。
例如，如果你使用BCrypt，你可以添加一个bean定义如下图所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public BCryptPasswordEncoder passwordEncoder() {
	return new BCryptPasswordEncoder();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueldap-2"><a class="anchor" href="#trueldap-2"></a>LDAP 验证</h4>

</div>
</div>
<div class="sect2">
<h3 id="true-httpsecurity"><a class="anchor" href="#true-httpsecurity"></a>多个HttpSecurity</h3>
<div class="paragraph">
<p>我们可以配置多个HttpSecurity实例，就像我们可以有多个<code>&lt;http&gt;</code>块. 关键在于对<code>WebSecurityConfigurationAdapter</code>进行多次扩展。例如下面是一个对<code>/api/</code>开头的URL进行的不同的设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class MultiHttpSecurityConfig {
	@Autowired
	public void configureGlobal(AuthenticationManagerBuilder auth) { <i class="conum" data-value="1"></i><b>(1)</b>
		auth
			.inMemoryAuthentication()
				.withUser("user").password("password").roles("USER").and()
				.withUser("admin").password("password").roles("USER", "ADMIN");
	}

	@Configuration
	@Order(1)                                                        <i class="conum" data-value="2"></i><b>(2)</b>
	public static class ApiWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
		protected void configure(HttpSecurity http) throws Exception {
			http
				.antMatcher("/api/**")                               <i class="conum" data-value="3"></i><b>(3)</b>
				.authorizeRequests()
					.anyRequest().hasRole("ADMIN")
					.and()
				.httpBasic();
		}
	}

	@Configuration                                                   <i class="conum" data-value="4"></i><b>(4)</b>
	public static class FormLoginWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests()
					.anyRequest().authenticated()
					.and()
				.formLogin();
		}
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>配置正常的验证。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建一个<code>WebSecurityConfigurerAdapter</code>，包含一个<code>@Order</code>注解，用来指定个哪一个<code>WebSecurityConfigurerAdapter</code>更优先。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>http.antMatcher</code>指出，这个<code>HttpSecurity</code>只应用到以<code>/api/</code>开头的URL上。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>创建另外一个<code>WebSecurityConfigurerAdapter</code>实例。用于不以<code>/api/</code>开头的URL，这个配置的顺序在<code>ApiWebSecurityConfigurationAdapter</code>之后，因为他没有指定<code>@Order</code>值为<code>1</code>(没有指定<code>@Order</code>默认会被放到最后).</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jc-method"><a class="anchor" href="#jc-method"></a>方法安全</h3>
<div class="paragraph">
<p>从2.0 开始Spring Security对服务层的方法的安全有了实质性的改善。他提供对JSR-250的注解安全支持像框架原生<code>@Secured</code>注解一样好。从3.0开始你也可以使用新的基于表达式的注解 <a href="#el-access">expression-based annotations</a>。你可以应用安全到单独的bean，使用拦截方法元素去修饰Bean声明，或者你可以在整个服务层使用 AspectJ风格的切入点保护多个bean。</p>
</div>
<div class="sect3">
<h4 id="trueenableglobalmethodsecurity"><a class="anchor" href="#trueenableglobalmethodsecurity"></a>EnableGlobalMethodSecurity</h4>
<div class="paragraph">
<p>我们可以在任何使用<code>@Configuration</code>的实例上，使用<code>@EnableGlobalMethodSecurity</code>注解来启用基于注解的安全性。例如下面会启用Spring的<code>@Secured</code>注解。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableGlobalMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>添加一个注解到一个方法（或者一个类或者接机）会限制对相应方法的访问。Spring Security的原生注解支持定义了一套用于该方法的属性。这些将被传递<code>AccessDecisionManager</code>到来做实际的决定：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用如下代码启用JSR-250注解的支持</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些都是基于标准的，并允许应有个你简单的基于角色的约束，但是没有Spring Security的本地注解的能力。要使用基于表达书的语法，你可以使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>和响应Java代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueglobalmethodsecurityconfiguration"><a class="anchor" href="#trueglobalmethodsecurityconfiguration"></a>GlobalMethodSecurityConfiguration</h4>
<div class="paragraph">
<p>有时候你可能需要执行一些比<code>@EnableGlobalMethodSecurity</code>注解允许的更复杂的操作。对于这些情况，你可以扩展<code>GlobalMethodSecurityConfiguration</code>确保<code>@EnableGlobalMethodSecurity</code>注解出现在你的子类。例如如果你想提供一个定制的<code>MethodSecurityExpressionHandler</code>，你可以使用下面的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
	@Override
	protected MethodSecurityExpressionHandler createExpressionHandler() {
		// ... create and return custom MethodSecurityExpressionHandler ...
		return expressionHandler;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于可以被重写的方法的更多信息，请参考<code>GlobalMethodSecurityConfiguration</code>的java文档。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true--7"><a class="anchor" href="#true--7"></a>已配置对象的后续处理</h3>
<div class="paragraph">
<p>Spring Security的Java配置没有公开每个配置对象的每一个属性，这简化了广大用户的配置。毕竟如果要配置每一个属性，用户可以使用标准的Bean配置。</p>
</div>
<div class="paragraph">
<p>虽然有一些很好的理由不直接暴露所有属性，用户可能仍然需要更多高级配置，为了解决这个Spring Security引入了<code>ObjectPostProcessor</code>概念，用来替换java配置的对象实例。例如：如果你想在<code>filterSecurityPublishAuthorizationSuccess</code>里配置<code>FilterSecurityInterceptor</code>属性，你可以想下面一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() {
				public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(
						O fsi) {
					fsi.setPublishAuthorizationSuccess(true);
					return fsi;
				}
			});
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ns-config"><a class="anchor" href="#ns-config"></a>安全命名空间配置</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="true--8"><a class="anchor" href="#true--8"></a>简介</h3>
<div class="paragraph">
<p>命名空间配置在Spring框架的2.0版本就可以使用了，他允许你通过额外的XML架构元素补充传统的Spring bean应用程序上下文。你可以从Spring的参考文档找到更多信息 <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/">Reference Documentation</a>.。命名空间元素可以简单的允许配置单个bean，或者更强大的，定义一个可选的配置语法，这样更贴近问题域并且对用户隐藏背后的复杂性。一个简单的元素可以隐藏多个bean和添加到应用程序上下文的多个处理步骤。例如：从安全命名空间添加后面的元素到应用程序上下文将开始一个LDAP服务到应用程序内用于测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;security:ldap-server /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这比配置一个Apache木服务器bean简单的多。最常见的替代配置需求是<code>ldap-server</code>元素的属性支持，用户不用担心他们要创建的bean属名称:[你可以从:specialcharacters,macros[<a href="#ldap">LDAP 身份验证</a>]找到如何使用<code>ldap-server</code>元素的更多的信息. ] 。当编译应用的Context文件时良好的XML编译器应该可以提供您可用的属性和元素的信息。我们建议你尝试使用 <a href="http://spring.io/tools/sts">Spring Tool Suite</a>，它具有与标准Spring命名空间工作的特别的功能。</p>
</div>
<div class="paragraph">
<p>为了在你的应用程序上下文中使用安全命名空间，你需要将<code>spring-security-config</code>包含到你的classpath中。然后在你的上下文文件中加入以下的结构声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
xmlns:security="http://www.springframework.org/schema/security"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/security
		http://www.springframework.org/schema/security/spring-security.xsd"&gt;
	...
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在很多示例（包括示例应用程序）中你将会看到，我们经常使用security作为默认的命名空间而不是使用beans，这样我们可以在所有安全命名空间中忽略前缀，使得内容更加容易阅读。如果你的应用程序上下文被分割成单独的文件，大部分的安全配置被放到一个文件中，你可能也想这样做。你的安全应用上下文文件应该像下面的一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans:beans xmlns="http://www.springframework.org/schema/security"
xmlns:beans="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/security
		http://www.springframework.org/schema/security/spring-security.xsd"&gt;
	...
&lt;/beans:beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们假设在这一章节我们都使用这种语法。</p>
</div>
<div class="sect3">
<h4 id="true--9"><a class="anchor" href="#true--9"></a>命名空间的设计</h4>
<div class="paragraph">
<p>命名空间是设计用来捕捉框架最常见用途和提供一个简化和简介的语法用来在应用程序中打开他们。设计师基于框架中的大规模依赖，并且可以划分为以下几个方面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Web/HTTP 安全</em> - 最复杂的部分，设置过滤器和应用框架验证机制的相关服务bean，渲染登录和错误页面等等。</p>
</li>
<li>
<p><em>业务对象（方法）安全</em> - 业务层安全选项。</p>
</li>
<li>
<p><em>AuthenticationManager</em> - 处理来自框架其他部分的认证请求。</p>
</li>
<li>
<p><em>AccessDecisionManager</em> - 为网页和方法安全提供访问决策，会注册一个默认的但是你可以使用一个定制的来取代他，使用一般的Spring bean语法即可定义。</p>
</li>
<li>
<p><em>AuthenticationProvider</em>- 认证管理器认证用户的机制，命名空间提供多种标准选项的支持，同时使用传统语法添加自定义bean的方法。</p>
</li>
<li>
<p><em>UserDetailsService</em> - 和AuthenticationProviders密切相关，但往往也被其他bean需要。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们将在后续章节查看怎么配置他们。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-getting-started"><a class="anchor" href="#ns-getting-started"></a>开始使用安全命名空间配置</h3>
<div class="paragraph">
<p>在这一章，我们将看看怎么创建一个命名空间配置来使用框架的主要功能。让我们假设你想要快速的使用命名空间配置添加验证支持和访问控制和一些测试的登录到一个已经存在的网站应用程序。然后我们看看如何验证数据库和其他的安全仓库。在后续章节我们将介绍更多高级的命名空间配置选项。</p>
</div>
<div class="sect3">
<h4 id="ns-web-xml"><a class="anchor" href="#ns-web-xml"></a>web.xml 配置</h4>
<div class="paragraph">
<p>你需要做的第一件事情是添加下面的过滤器定义到你的<code>web.xml</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这提供了一个钩子到Spring Security的网页基础设施。<code>DelegatingFilterProxy</code>是一个委托了在应用的Context中定义为bean的过滤器实现的一个Spring框架类，在这种情况下，bean的名字是<code>springSecurityFilterChain</code>，这是网络安全命名空间创建的一个基础类。注意你不能自己使用这个bean名字。一旦你添加这个到你的<code>web.xml</code>，你就可以开始编辑你的应用程序上下文文件，网络安全服务被配置到<code>&lt;http&gt;</code>元素。</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-minimal"><a class="anchor" href="#ns-minimal"></a>最小&lt;http&gt;配置</h4>
<div class="paragraph">
<p>开始开启网页安全你只需要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;intercept-url pattern="/**" access="hasRole('USER')" /&gt;
&lt;form-login /&gt;
&lt;logout /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这表示，我们想要对我们应用程序中的所有URL进行性检测。需要角色<code>ROLE_USER</code>访问他们，我们使用一个包含username和password的表单登录到应用程序，我们希望有一个注销的URL，让我们可以登出应用程序。<code>&lt;http&gt;</code>元素是所有网站相关的命名空间功能的父元类。<code>&lt;intercept-url&gt;</code>元素定义了一个规则使用ant语法去匹配传入的请求的URL。 （在网站应用基础设施章节，查看 <a href="#request-matching">Request Matching and HttpFirewall</a>来了解匹配是如何执行的）  你也可以环衬正则表达式语法（查看附录了解更多）。这个<code>access</code>属性定义了这个匹配的规则需要的访问需求。默认是一个典型的用逗号分隔的角色列表，有其中一个符合则允许执行这个请求。 前缀"ROLE_" 是一个标记，只是一个和用户的授权进行简单的比较。换句话说，一个简单的基于角色的检查会被应用。Spring Security的访问控制不仅限于简单角色(因此使用前缀来区分不同类型的)。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你可以使用多个<code>&lt;intercept-url&gt;</code>元素来为不同的URL定于不同的访问需求，他是他们将按照顺序计算，第一个匹配的会被使用，说以你必须将最特别的匹配放到最上面，你也可以添加一个<code>method</code>属性 用来限制HTTP方法(<code>GET</code>, <code>POST</code>, <code>PUT</code> 等等).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了添加一些用户，你可以直接在命名空间直接定义一组测试数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;authentication-manager&gt;
&lt;authentication-provider&gt;
	&lt;user-service&gt;
	&lt;user name="jimi" password="jimispassword" authorities="ROLE_USER, ROLE_ADMIN" /&gt;
	&lt;user name="bob" password="bobspassword" authorities="ROLE_USER" /&gt;
	&lt;/user-service&gt;
&lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>如果你熟悉框架的预命名空间版本，你很可能已经猜到这里怎么回事了。<code>&lt;http&gt;</code>元素负责创建<code>FilterChainProxy</code>和它使用的过滤器bean。像不正确过滤排序常见的问题是不再是一个问题，因为过滤器的位置都是预定义的。</p>
</div>
<div class="paragraph">
<p><code>&lt;authentication-provider&gt;</code>元素创建<code>DaoAuthenticationProvider</code> bean并且<code>&lt;user-service&gt;</code>元素创建了一个<code>InMemoryDaoImpl</code>。所有的验证供应商元素必须是<code>&lt;authentication-manager&gt;</code>元素的子元素。他创建一个<code>ProviderManager</code>并注册为验证供应商。你可以在 <a href="#appendix-namespace">namespace appendix</a>找到更多信息。如果你想了解框架的重要的一些类了解他们如何使用特别是后面你想定制一些事情，你值得去查看一下。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的配置定义了两个用户，他们的密码和在这个应用程序里的角色（这将用于访问控制）。也可以使用用户服务从标准的属性文件<code>properties</code>载入用户信息<code>user-service</code>。查看内存认证部分文件格式的更多细节<a href="#core-services-in-memory-service">in-memory authentication</a> 。使用 <code>&lt;authentication-provider&gt;</code>元素意思是这些用户信息将被认证管理器使用到请求验证。你可以设置多个<code>&lt;authentication-provider&gt;</code>元素来定义不同的验证源每一个都会被一次访问到。</p>
</div>
<div class="paragraph">
<p>此时你应该可以开始你的应用程序，你将被要求登录。尝试一下或者尝试使用附带的项目教程实例。</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-form-and-basic"><a class="anchor" href="#ns-form-and-basic"></a>表单和基本登录选项</h4>
<div class="paragraph">
<p>你可能会想当系统提示你登录这些登录表单哪里来的，因为我们都没有提供任何HTML和JSP文件。事实上我们并没有明确的设定一个登陆页的URL，Spring Security自动生成了一个，基于处理登录的URL标准值。以及登录后跳转的URL然后命名空间提供了大量的支持，让你可以自定义这些选项，例如如果你想自己设计登录页面，你可以使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;intercept-url pattern="/login.jsp*" access="IS_AUTHENTICATED_ANONYMOUSLY"/&gt;
&lt;intercept-url pattern="/**" access="ROLE_USER" /&gt;
&lt;form-login login-page='/login.jsp'/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外请注意一个额外的<code>intercept-url</code>元素，来指定登录页的请求可以被任何匿名用户访问:[AuthenticatedVoter 类可以提供更多 <a href="#anonymous">匿名身份验证</a>]  <a href="#authz-authenticated-voter">AuthenticatedVoter</a>  <code>IS_AUTHENTICATED_ANONYMOUSLY</code>被处理的细节]. 否则请求会被/**规则匹配这将是不可能访问到登录页面。这是一个常见的配置错误，将导致应用无限循环。Spring Security会产生一条经过到日志中如果你的登录页被保护了。它也可以设置让所有请求完全匹配特定模式而绕过安全过滤器，通过定义像这样单独<code>http</code>元素的规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http pattern="/css/**" security="none"/&gt;
&lt;http pattern="/login.jsp*" security="none"/&gt;

&lt;http use-expressions="false"&gt;
&lt;intercept-url pattern="/**" access="ROLE_USER" /&gt;
&lt;form-login login-page='/login.jsp'/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从Spring Security 3.1开始允许使用多个<code>http</code>元素来为不用的请求规则分别定义<a href="#filter-chains-with-ns">Security Filter Chain</a>配置。如果<code>http</code>元素的<code>pattern</code>属性为设置则匹配所有请求。创建不进行安全检查的规则是这个语法的一个简答的例子，这个规则会被映射到一个空的过滤链。我们将会在后面的安全过滤链章节找到更多细节。[多个<code>&lt;http&gt;</code>元素的使用时一个非常重要的功能，例如它允许命名空间在一个应用程序中同时支持有状态和无状态的相同URL之前的语法，使用<code>filters="none"</code>属性到一个<code>intercept-url</code>元素与这一变化相抵触，在3.1将不再支持 。</p>
</div>
<div class="paragraph">
<p>重要的一点需要认识到，这些不安全的请求将完全无视任何Spring Security 的web相关的配置或附加属性，例如<code>requires-channel</code>通道的限定，所以在请求期间你将无法访问当前用户信息，或调用需要进行安全验证的方法。如果你想让安全过滤链被应用另外也可以使用 <code>access='IS_AUTHENTICATED_ANONYMOUSLY'</code>。</p>
</div>
<div class="paragraph">
<p>如果你想使用基本验证来替换掉表单的登录，你可以将配置修改如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http use-expressions="false"&gt;
&lt;intercept-url pattern="/**" access="ROLE_USER" /&gt;
&lt;http-basic /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当用户访问被保护的资源时，基本身份验证将优先弹出提示框来进行登录。在这总配置如果想使用基于表单的登录，他仍然有效。例如，将登录嵌入另外一个网页。</p>
</div>
<div class="sect4">
<h5 id="ns-form-target"><a class="anchor" href="#ns-form-target"></a>设置默认的登录后地址</h5>
<div class="paragraph">
<p>如果不是由试图访问受保护的资源促成的登录，默认目标URL就会起作用。这是一个当用户成功登录后会被带去的URL默认是"/"，你也可以通过配置<code>default-target-target</code>为<code>true</code>让用户一直跳转到这个地址而无论用户是按需还是明确的选择登录。这在你的应用程序需要用户一直从主页开始时很有用。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http pattern="/login.htm*" security="none"/&gt;
&lt;http use-expressions="false"&gt;
&lt;intercept-url pattern='/**' access='ROLE_USER' /&gt;
&lt;form-login login-page='/login.htm' default-target-url='/home.htm'
		always-use-default-target='true' /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了对跳转目标进行更多控制，你可以使用<code>authentication-success-handler-ref</code> 来替代<code>default-target-url</code>。这个bean的引用应该是<code>AuthenticationSuccessHandler</code>的一个实例。你可以在 <a href="#form-login-flow-handling">Core Filters</a> 章节和命名空间附录找到如何定制认证失败的流程的更多信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ns-logout"><a class="anchor" href="#ns-logout"></a>处理登出</h4>
<div class="paragraph">
<p><code>logout</code>元素，增加了一个登出导航到一个特定URL的支持，默认的登出URL是 <code>/logout</code>。但是你可以使用<code>logout-url</code>属性指定为其他的URL。更多的属性你可以从附录找到。</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-auth-providers"><a class="anchor" href="#ns-auth-providers"></a>使用其他的验证供应商</h4>
<div class="paragraph">
<p>在实践中，你将需要将一些名字添加到应用程序上下文文件中更具扩展性的数据源。你有可能想把用户信息存放在注入数据库或者LDAP服务器中。LDAP命名空间的配置在<a href="#ldap">LDAP chapter</a>章节，这里就不说了。,如果你的应用程序上下文中有一个Spring Security的 <code>UserDetailsService</code>的实现叫做"myUserDetailsService"，你可以这样使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;authentication-manager&gt;
	&lt;authentication-provider user-service-ref='myUserDetailsService'/&gt;
&lt;/authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想用一个数据库，你可以这样用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;authentication-manager&gt;
&lt;authentication-provider&gt;
	&lt;jdbc-user-service data-source-ref="securityDataSource"/&gt;
&lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在应用程序上下文中，"securityDataSource"是<code>DataSource</code> bean的名字，指明一个数据库包含标准的 Spring Security <a href="#user-schema">user data tables</a>. 另外， 你可以配置一个Spring Security <code>JdbcDaoImpl</code> bean 并且指明它使用<code>user-service-ref</code>属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;authentication-manager&gt;
&lt;authentication-provider user-service-ref='myUserDetailsService'/&gt;
&lt;/authentication-manager&gt;

&lt;beans:bean id="myUserDetailsService"
	class="org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"&gt;
&lt;beans:property name="dataSource" ref="dataSource"/&gt;
&lt;/beans:bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以像下面一样使用标准的<code>AuthenticationProvider</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;authentication-manager&gt;
	&lt;authentication-provider ref='myAuthenticationProvider'/&gt;
&lt;/authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>myAuthenticationProvider</code>是应用程序上下文的一个bean名字 。他实现了<code>AuthenticationProvider</code>接口。 你可以设置多个验证供应商，这样这些供应商就会按照定义的顺序被查询。看看 <a href="#ns-auth-manager">验证管理器和命名空间</a> 章节“验证管理器和命名空间”连接<code>AuthenticationManager</code>在命名空间中怎么被配置。</p>
</div>
<div class="sect4">
<h5 id="ns-password-encoder"><a class="anchor" href="#ns-password-encoder"></a>添加密码编码器</h5>
<div class="paragraph">
<p>密码应该一直使用一个尽可能安全的哈希算法进行编码（非标准的算法，例如SHA或者MD5）。这在<code>&lt;password-encoder&gt;</code>中进行支持，使用<code>bcrypt</code>编码密码，原始的供应商配置应该类似这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans:bean name="bcryptEncoder"
	class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/&gt;

&lt;authentication-manager&gt;
&lt;authentication-provider&gt;
	&lt;password-encoder ref="bcryptEncoder"/&gt;
	&lt;user-service&gt;
	&lt;user name="jimi" password="d7e6351eaa13189a5a3641bab846c8e8c69ba39f"
			authorities="ROLE_USER, ROLE_ADMIN" /&gt;
	&lt;user name="bob" password="4e7421b1b8765d8f9406d87e7cc6aa784c4ab97f"
			authorities="ROLE_USER" /&gt;
	&lt;/user-service&gt;
&lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bcrypt 在大部分时候是一个好的选择。除非你有一个旧系统强迫你使用一个不用的算法。如果你正在使用一个简单的哈希算法或者更糟糕存储了明文密码，你应该考虑迁移到<code>bcrypt</code>这个更安全的选项。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-web-advanced"><a class="anchor" href="#ns-web-advanced"></a>高级web功能</h3>
<div class="sect3">
<h4 id="ns-remember-me"><a class="anchor" href="#ns-remember-me"></a>Remember-Me 验证</h4>
<div class="paragraph">
<p>查看独立的<a href="#remember-me">Remember-Me chapter</a>章节来查看该功能的配置。</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-requires-channel"><a class="anchor" href="#ns-requires-channel"></a>添加 HTTP/HTTPS 通道安全</h4>
<div class="paragraph">
<p>如果你的应用程序同时支持HTTP和HTTPS，你要求特定的URL只能使用HTTPS，这是可以直接使用<code>&lt;intercept-url&gt;</code>的<code>requires-channel</code>属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;intercept-url pattern="/secure/**" access="ROLE_USER" requires-channel="https"/&gt;
&lt;intercept-url pattern="/**" access="ROLE_USER" requires-channel="any"/&gt;
...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个配置,如果用户试图访问任何匹配的"/secure/**"模式使用HTTP,他们将首先被重定向到一个HTTPS URL脚注:[想要了解channel-processing 如何实现，请查阅java文档<code>ChannelProcessingFilter</code>以及相关的类]。可用的选项是“http”、“https”或“任何”。使用价值“任何”意味着可以使用HTTP或HTTPS。</p>
</div>
<div class="paragraph">
<p>该选项可选值为"http","https"或者"any"，使用"any"意思是使用HTTP或者HTTPS均可。如果应用程序使用HTTP和HTTPS非标准的端口，你可以指定如下端口映射的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
&lt;port-mappings&gt;
	&lt;port-mapping http="9080" https="9443"/&gt;
&lt;/port-mappings&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意,为了真正的安全,应用程序不应该使用HTTP或HTTP和HTTPS之间切换。它应该开始在HTTPS(与用户进入一个HTTPS URL)使用安全连接,以避免任何中间人攻击的可能性。</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-session-mgmt"><a class="anchor" href="#ns-session-mgmt"></a>Session 管理</h4>
<div class="sect4">
<h5 id="true--10"><a class="anchor" href="#true--10"></a>检测超时</h5>
<div class="paragraph">
<p>你可以配置Spring Security检测无效的Session ID提交并且将用户重定向到一个适当的URL，这通过<code>session-management</code>元素来达到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
&lt;session-management invalid-session-url="/invalidSession.htm" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果你使用这个机制来检测会话超时，如果用户注销，然后重新登录，但不关闭浏览器它可能会错误地抛出一个错误。这是因为当你让Session失效时，Cookie没有被清理干净，就算用户已注销还是会重新提交session的cookie而不会清除。你可以在注销时明确的删除JSESSIONID的cookie，例如：通过在注销处理程序使用一下语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;logout delete-cookies="JSESSIONID" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不幸的是这个不保证在所有servlet容器都会正常工作，所以你需要在你的环境下进行测试。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你的应用程序运行在代理后面，你还可以配置代理服务器去删除session的cookie。例如，使用Apache httpd的mod_headers模块。下面的指令可以通过在注销请求的响应头删除<code>JSESSIONID</code>的cookie。(假设应用程序部署在 <code>/tutorial</code>路径下):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;LocationMatch "/tutorial/logout"&gt;
Header always set Set-Cookie "JSESSIONID=;Path=/tutorial;Expires=Thu, 01 Jan 1970 00:00:00 GMT"
&lt;/LocationMatch&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ns-concurrent-sessions"><a class="anchor" href="#ns-concurrent-sessions"></a>并发Session控制</h5>
<div class="paragraph">
<p>如果你想限制单个用户访问你的应用程序的能力。Spring Security通过后面简单的配置马上启用。首先你需要添加后面的监听器到你的<code>web.xml</code>文件。让Spring Security获得session的生存事件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;listener&gt;
&lt;listener-class&gt;
	org.springframework.security.web.session.HttpSessionEventPublisher
&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后添加后面的行到你的应用程序上下文：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
&lt;session-management&gt;
	&lt;concurrency-control max-sessions="1" /&gt;
&lt;/session-management&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将放置用户登录多次。第二次登录将导致第一次登录变成无效。通常我们更想放置第二次登录，在这种情况下，你可以使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
&lt;session-management&gt;
	&lt;concurrency-control max-sessions="1" error-if-maximum-exceeded="true" /&gt;
&lt;/session-management&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二次登录将被拒绝，如果基于表单的验证被启用这个用户将会被发送到 <code>authentication-failure-url</code>。如果第二次登录是通过其他非交互的机制，比如“记住我”功能，进行登录的。那么一个“unauthorized”(401)错误将会被发送给客户端。如果你想替换成一个错误页面，你可以为<code>session-management</code>添加一个<code>session-authentication-error-url</code>属性。</p>
</div>
<div class="paragraph">
<p>如果你正在使用基于表单的登录定制验证过滤器，那么你必须明确地配置同步会话控制的支持。更多的细节可以在 <a href="#session-mgmt">Session Management chapter</a>章节中找到。</p>
</div>
</div>
<div class="sect4">
<h5 id="ns-session-fixation"><a class="anchor" href="#ns-session-fixation"></a>Session Fixation 攻击保护</h5>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Session_fixation">Session fixation</a>完成攻击是一个潜在的威胁。攻击者访问网站生成一个Session，然后诱使其他用户用同一个会话登录（例如：通过发送包含会话标识符作为一个参数链接）。Spring Security通过在登录时创建新的Session或者修改Session ID来应对这种情况。如果你不需要这个保护或者与一些其他需求冲入你可以通过 <code>&lt;session-management&gt;</code>的<code>session-fixation-protection</code>属性来控制这个行为。它有4个选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>none</code> - 什么都不做，原来的会话将会保留</p>
</li>
<li>
<p><code>newSession</code> - 创建一个新的干净的Session，不会复制已经存在的Session属性到新的Session，这是Servlet3.0及之前的容器的默认设置</p>
</li>
<li>
<p><code>migrateSession</code> - 创建一个新的Session并且拷贝所有已经存在的Session属性到新的Session，这是Servlet3.0及之前的容器的默认设置。</p>
</li>
<li>
<p><code>changeSessionId</code> - 不创建新的Session，使用Servlet容器提供的Session完成攻击保护（<code>HttpServletRequest#changeSessionId()</code>）。这个选项只有在Servlet3.1（java EE 7）和更新的容器下可用。在旧的容器设置这个选项会产生一个异常。在Servlet3.0和更新的容器就默认该选项。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当会话完成保护发生时，它会产生<code>SessionFixationProtectionEvent</code>发布到应用程序上下文，如果使用<code>changeSessionId</code>, 这种保护也将导致 任何<code>javax.servlet.http.HttpSessionIdListener</code>被通知,所以如果你的代码监听这两个事件要特别小心。查看<a href="#session-mgmt">Session Management</a> 管理章节查看更多信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ns-openid"><a class="anchor" href="#ns-openid"></a>OpenID 支持</h4>
<div class="paragraph">
<p>通过一个简单的改变，命名空间可支持用 <a href="http://openid.net/">OpenID</a> 替换或者添加到普通的基于表单登录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;intercept-url pattern="/**" access="ROLE_USER" /&gt;
&lt;openid-login /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，你应该将自己注册为一个OpenID供应商（如myopenid.com），并添加用户信息到你的基于内存的<code>&lt;user-service&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;user name="http://jimi.hendrix.myopenid.com/" authorities="ROLE_USER" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你应该能够使用<code>myopenid.com</code>网站登录来进行验证。另外，也可以通过设置 <code>openid-login</code>元素的<code>user-service-ref</code>属性来指定一个<code>UserDetailsService</code> bean来使用OpenID。查看前面的<a href="#ns-auth-providers">authentication providers</a>章节了解更多信息请注意，我们省略从上述用户配置中的密码属性，由于该组的用户数据只被用于加载当前的用户。内部会产生一个随机密码，放置你意外的将这个用户数据用作验证源到你的配置中的其他地方。</p>
</div>
<div class="sect4">
<h5 id="true--11"><a class="anchor" href="#true--11"></a>属性交换</h5>
<div class="paragraph">
<p>OpenID 的属性交换支持 <a href="http://openid.net/specs/openid-attribute-exchange-1_0.html">attribute exchange</a>。下面的例子尝试接受从OpenID供应商接收邮件和全名，用于应用程序中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;openid-login&gt;
&lt;attribute-exchange&gt;
	&lt;openid-attribute name="email" type="http://axschema.org/contact/email" required="true"/&gt;
	&lt;openid-attribute name="name" type="http://axschema.org/namePerson"/&gt;
&lt;/attribute-exchange&gt;
&lt;/openid-login&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个OpenID属性的“type”是一个URI，有一种特定的模式来确定，这个例子中是 <a href="http://axschema.org/">http://axschema.org/</a>。如果属性必须在成功认证后接收，可以设置<code>required</code> 属性。确切的模式和属性的支持将取决于你的OpenID提供商。该属性值返回作为认证过程的一部分，随后可以使用下面的代码访问：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">OpenIDAuthenticationToken token =
	(OpenIDAuthenticationToken)SecurityContextHolder.getContext().getAuthentication();
List&lt;OpenIDAttribute&gt; attributes = token.getAttributes();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>OpenIDAttribute</code>包含了属性类型和接收到的值（在有多个属性值的情况下包含多个值），通过查看Spring Security核心组件的<a href="#core-components">technical overview</a>章节我们可以了解更多的<code>SecurityContextHolder</code>类的使用方法。如果希望使用多个身份提供者方，多重属性交换配置也被支持。你可以提供多个<code>attribute-exchange</code>元素。在每个上面使用<code>identifier-matcher</code>属性。它包含一个正则表达式，会匹配由用户提供的OpenID标识符。查看代码库的OpenID示例应用的一个示例配置。对 Google, Yahoo 和MyOpenID 提供了不同的属性列表。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ns-headers"><a class="anchor" href="#ns-headers"></a>相应头</h4>
<div class="paragraph">
<p>查看如何定制头元素的更多信息请查看<a href="#headers">安全HTTP响应头</a>章节。</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-custom-filters"><a class="anchor" href="#ns-custom-filters"></a>添加自己的过滤器</h4>
<div class="paragraph">
<p>如果你以前使用过Spring Security，你就会知道，这个 框架维护一个过滤器链，以便应用它的服务。你可能想要添加自己的过滤器到过滤器堆栈的特定位置，或者使用一个Spring Security还没有一个命名空间配置的选项的过滤器（比如CAS）。或者你想使用一个标准命名空间过滤器的定制化版本，比如<code>UsernamePasswordAuthenticationFilter</code>是由 <code>&lt;form-login&gt;</code>元素显式的使用Bean来获取一些额外的高级配置选项，在过滤器链不直接暴露的情况下，你怎么使用命名空间配置这一点？</p>
</div>
<div class="paragraph">
<p>使用命名空间时过滤器的顺序始终严格执行，当创建应用程序上下文，过滤器Bean被命名空间处理代码进行排序，标准的Spring Security过滤器都具有的命名空间和一个众所周知的位置的别名。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在以前的版本中，排序发生在过滤器实例创建之后，在应用程序上下文后处理中。语法在3.0有一些轻微的改变，这会影响到解析<code>&lt;http&gt;</code>元素时，你自己的过滤器如何被添加到整个过滤器列表中</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#filter-stack">标准过滤器别名和顺序</a>，别名和创建的命名空间元素/属性在下表列出，按照过滤器在链中出现的顺序列出：</p>
</div>
<table id="filter-stack" class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. 标准过滤器别名和顺序</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Alias</th>
<th class="tableblock halign-left valign-top">Filter Class</th>
<th class="tableblock halign-left valign-top">Namespace Element or Attribute</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHANNEL_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ChannelProcessingFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/intercept-url@requires-channel</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SECURITY_CONTEXT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SecurityContextPersistenceFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONCURRENT_SESSION_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConcurrentSessionFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>session-management/concurrency-control</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HEADERS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HeaderWriterFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/headers</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSRF_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CsrfFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/csrf</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOGOUT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LogoutFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/logout</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X509_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X509AuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/x509</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PRE_AUTH_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AbstractPreAuthenticatedProcessingFilter</code> Subclasses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CAS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CasAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FORM_LOGIN_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UsernamePasswordAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/form-login</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BASIC_AUTH_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BasicAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/http-basic</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SERVLET_API_SUPPORT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SecurityContextHolderAwareRequestFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/@servlet-api-provision</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JAAS_API_SUPPORT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JaasApiIntegrationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/@jaas-api-provision</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">REMEMBER_ME_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RememberMeAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/remember-me</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANONYMOUS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnonymousAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/anonymous</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SESSION_MANAGEMENT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionManagementFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>session-management</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXCEPTION_TRANSLATION_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExceptionTranslationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FILTER_SECURITY_INTERCEPTOR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FilterSecurityInterceptor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SWITCH_USER_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SwitchUserFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>你可以添加自己的过滤器到列表中，使用<code>custom-filter</code>过滤元件和这些名字来指定你的过滤器应该出现在的位置之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myFilter" /&gt;
&lt;/http&gt;

&lt;beans:bean id="myFilter" class="com.mycompany.MySpecialAuthenticationFilter"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以使用<code>after</code>和<code>before</code>属性来让你的过滤器插入到列表中的其他过滤器的前面和后面。<code>FIRST</code>和<code>LAST</code>可以用在<code>position</code>属性来设置你希望将你的过滤器插入到整个列表的前面或者后面。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Avoiding filter position conflicts</div>
<div class="paragraph">
<p>如果你插入的定制的过滤器可能会占用由命名空间创建的标准过滤器相同的位置，很重要的一点是不要错误的包含了命名空间的版本。移除所有你想替换的功能的过滤器元素。注意，你不能移除有<code>&lt;http&gt;</code>本身创建的过滤器，<code>SecurityContextPersistenceFilter</code>, <code>ExceptionTranslationFilter</code> 和 <code>FilterSecurityInterceptor</code>，一些其他的过滤器是默认被添加的，但是你可以禁止他们。除非你禁用<a href="#ns-session-fixation">session-fixation protection</a> ，一个<code>AnonymousAuthenticationFilter</code> 会默认被添加，一个<code>SessionManagementFilter</code>也会被添加到过滤器链。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你替换的命名空间过滤器需要一个验证入口点（例如：在认证过程是通过尝试触发未认证用户访问以受保护资源）你也需要添加一个定制的入口点Bean。</p>
</div>
<div class="sect4">
<h5 id="ns-entry-point-ref"><a class="anchor" href="#ns-entry-point-ref"></a>创建自定义的 AuthenticationEntryPoint</h5>
<div class="paragraph">
<p>如果你没有使用表单登录，OpenID或基本验证，你可能想像我们之前看到的一样，使用传统的bean语法，定义一个验证过滤器和入口点链接到命名空间。相应的<code>AuthenticationEntryPoint</code>可以使用<code>&lt;http&gt;</code>元素的<code>entry-point-ref</code>属性进行设置。</p>
</div>
<div class="paragraph">
<p>CAS示例应用是一个很好的示例，展示命名空间的定制bean的使用。如果你不熟悉认证的入口点，可以在<a href="#tech-intro-auth-entry-point">technical overview</a>章节看到相关讨论。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-method-security"><a class="anchor" href="#ns-method-security"></a>方法安全</h3>
<div class="paragraph">
<p>从2.0版本开始Spring Security改进了对服务层方法的安全支持，它提供了对JSR-250注解安全支持以及框架的原生<code>@Secured</code>注解支持。从3.0开始你也可以使用新的<a href="#el-access">expression-based annotations</a>。你可以将安全应用到单个bean。使用<code>intercept-methods</code>元素装饰Bean的声明。或者你可以在使用AspectJ风格的切入点应用安全到整个服务层的多个Bean类。</p>
</div>
<div class="sect3">
<h4 id="ns-global-method"><a class="anchor" href="#ns-global-method"></a>The &lt;global-method-security&gt; 元素</h4>
<div class="paragraph">
<p>这个元素用来在你的应用程序中启用基于安全性（通过设置元素的<code>appropriate</code>属性），同时分组将应用到整个应用程序上下文的安全切入点声明。你应该只定义一个<code>&lt;global-method-security&gt;</code>元素。下面的定义可以开启Spring Security的<code>@Secured</code>支持:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security secured-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>添加一个注解到类或者接口的方法中可以限制对相应方法的访问。Spring Security的原生注解支持定义了一套用于该方法的属性。这些将被传递到<code>AccessDecisionManager</code>用来做实际的决定：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>启用 JSR-250 注解使用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security jsr250-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些都是基于标准的，并允许应用简单的基于角色的约束，但是没有Spring Security的原生注解强大。要使用新的基于表达式的语法，你可以使用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security pre-post-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价的Java代码如下</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>基于表达式的注解是一个很好的选择，如果你需要定义超过一个检查当前用户列表中的角色名称的简单的规则。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>被注解的方法将仅在被定义为Spring 的Bean的实例时才能确保安全（在相同的应用程序的上下文中该方法-启用方法安全检查）。如果你想确保非Sprign创建的实例的安全性（比如使用<code>new</code>操作符创建的）那么你需要使用 AspectJ.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你可以在同一个应用程序中启用多种注解，但是在一个借口或者类中只能使用一种类型的注解，否则会出现不明确的行为。如果对特定的方法使用了两个注解，只有其中的一个会被应用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="ns-protect-pointcut"><a class="anchor" href="#ns-protect-pointcut"></a>使用 protect-pointcut</h5>
<div class="paragraph">
<p>使用<code>protect-pointcut</code>非常有用, 因为它允许你只用简单的声明就能对很多bean添加安全性。看看下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security&gt;
&lt;protect-pointcut expression="execution(* com.mycompany.*Service.*(..))"
	access="ROLE_USER"/&gt;
&lt;/global-method-security&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将保护在应用程序上下文定义的所有在<code>com.mycompany</code>包下类名以“service”结尾的类的方法。只有拥有<code>ROLE_USER</code>角色用户才能执行这些方法。和URL匹配一样，列表中多个匹配的话将会使用第一个匹配的安全注解，比切入点有更高的优点级。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-access-manager"><a class="anchor" href="#ns-access-manager"></a>默认的 AccessDecisionManager</h3>
<div class="paragraph">
<p>这一章节假设你有一些Spring Security中访问控制的底层架构的知识。如果没有，你可以跳过它，后面再来看，这部分针对那些真正需要进行一些定制而不是简单的基于角色的安全用户。</p>
</div>
<div class="paragraph">
<p>当你使用命名空间配置时，一个<code>AccessDecisionManager</code>实例将会自动创建并注册用来按照你在<code>intercept-url</code>和<code>protect-pointcut</code>（还有如果你使用了方法注解安全也包含在内）定义的访问属性进行访问决策。</p>
</div>
<div class="paragraph">
<p>默认的策略是使用一个<code>AffirmativeBased</code>、<code>AccessDecisionManager</code>和<code>RoleVoter``AuthenticatedVoter</code>，你也可以从<a href="#authz-arch">authorization</a>章节找到更多信息.</p>
</div>
<div class="sect3">
<h4 id="ns-custom-access-mgr"><a class="anchor" href="#ns-custom-access-mgr"></a>自定义 AccessDecisionManager</h4>
<div class="paragraph">
<p>如果你需要使用一个更复杂的访问控制策略，那么很容易的为方法和Web安全设置替代方案。</p>
</div>
<div class="paragraph">
<p>对于方法安全，通过在<code>access-decision-manager-ref</code>上设置<code>global-method-security</code> 属性来为应用程序指导适当的 <code>AccessDecisionManager</code>的Bean <code>ID</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security access-decision-manager-ref="myAccessDecisionManagerBean"&gt;
...
&lt;/global-method-security&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>网站安全的语法一样，但是是在<code>http</code>元素上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http access-decision-manager-ref="myAccessDecisionManagerBean"&gt;
...
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-auth-manager"><a class="anchor" href="#ns-auth-manager"></a>验证管理器和命名空间</h3>
<div class="paragraph">
<p>Spring Security中主要的提高验证服务的借口是<code>AuthenticationManager</code>，这通常是一个Spring Security的<code>ProviderManager</code>类的实例。如果你以前用过框架你可能已经熟悉了。如果不是后面的  <a href="#tech-intro-authentication">technical overview chapter</a>章节会讲到。这个bean是通过<code>authentication-manager</code>命名空间来注册。你不能使用自定义的<code>AuthenticationManager</code>如果通过命名空间使用HTTP或方法安全，但是这不应该是一个问题，因为你可以完全控制所使用的好的<code>AuthenticationProvider</code>。</p>
</div>
<div class="paragraph">
<p>你可能需要使用<code>ProviderManager</code>注册其他的<code>AuthenticationProvider</code> Bean，你可以使用<code>&lt;authentication-provider&gt;</code>元素的<code>ref</code>属性，属性的值是你要添加的bean的名字，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;authentication-manager&gt;
&lt;authentication-provider ref="casAuthenticationProvider"/&gt;
&lt;/authentication-manager&gt;

&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
...
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个常见的需求是，上下文中的另一个bean可能需要引用<code>AuthenticationManager</code>，你可以注册一个<code>AuthenticationManager</code>的别名在应用程序上下文中的其他地方使用这个名字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;security:authentication-manager alias="authenticationManager"&gt;
...
&lt;/security:authentication-manager&gt;

&lt;bean id="customizedFormLoginFilter"
	class="com.somecompany.security.web.CustomFormLoginFilter"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
...
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sample-apps"><a class="anchor" href="#sample-apps"></a>应用程序示例</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这里有几个可用的网站应用程序示例。为了避免大量的下载。只有"totorial""contacts"示例包含到了分发的zip文件。其他的可用按照<a href="#get-source">the introduction</a>从源代码构建。你可以很容易的自己构建项，通过 <a href="http://spring.io/spring-security/">http://spring.io/spring-security/</a>网站可以获取更多信息。本章中提到的所有路径是相对于项目的源目录。</p>
</div>
<div class="sect2">
<h3 id="tutorial-sample"><a class="anchor" href="#tutorial-sample"></a>Tutorial 示例</h3>
<div class="paragraph">
<p>本教程样本是一个让你入门的很好的基础的例子。它完全使用而来简单命名空间配置。编译好的应用程序包含在分发的zip包中。随时可以部署到你的Web容器(<code>spring-security-samples-tutorial-3.1.x.war</code>)。 <a href="#ns-form-and-basic">form-based</a>的认证机制结合<a href="#remember-me">remember-me</a> 功能，验证供应商提供使用cookie自动基础登录。</p>
</div>
<div class="paragraph">
<p>我们建议你从本示例开始，因为XML非常小，易于遵循。最重要的是，你可以把这个XML文件（和它对应的<code>web.xml</code>入口）轻松地添加到现有的应用程序中。在这个基本集成成功的时候，我们建议你试着添加方法验证和领域对象安全。</p>
</div>
</div>
<div class="sect2">
<h3 id="contacts-sample"><a class="anchor" href="#contacts-sample"></a>Contacts 示例</h3>
<div class="paragraph">
<p>该示例是一个高级的例子，它展示除了基本的应用程序安全领域对象的访问控制列表（ACL）的更强大的功能。本申请提供了一个接口让用户能够管理简单的联系人数据库（域对象）。</p>
</div>
<div class="paragraph">
<p>拷贝WAR问价你从Spring Security 分发包到你自己的容器的<code>webapps</code> 目录来部署它。war名字是<code>spring-security-samples-contacts-3.1.x.war</code>(扩展的版本号取决于你的版本号)。</p>
</div>
<div class="paragraph">
<p>开始你的容器后检查应用程序是否可用载入，访问 <a href="http://localhost:8080/contacts" class="bare">http://localhost:8080/contacts</a> (或者其他适合你的容器URL)。</p>
</div>
<div class="paragraph">
<p>接下来，单击"Debug"。系统将提示你进行身份验证，以及页面提示的一系列用户名和密码。简单验证，显示一个结果页面。它应该包含类似于一下成功信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Security Debug Information

Authentication object is of type:
org.springframework.security.authentication.UsernamePasswordAuthenticationToken

Authentication object as a String:

org.springframework.security.authentication.UsernamePasswordAuthenticationToken@1f127853:
Principal: org.springframework.security.core.userdetails.User@b07ed00: Username: rod; \
Password: [PROTECTED]; Enabled: true; AccountNonExpired: true;
credentialsNonExpired: true; AccountNonLocked: true; \
Granted Authorities: ROLE_SUPERVISOR, ROLE_USER; \
Password: [PROTECTED]; Authenticated: true; \
Details: org.springframework.security.web.authentication.WebAuthenticationDetails@0: \
RemoteIpAddress: 127.0.0.1; SessionId: 8fkp8t83ohar; \
Granted Authorities: ROLE_SUPERVISOR, ROLE_USER

Authentication object holds the following granted authorities:

ROLE_SUPERVISOR (getAuthority(): ROLE_SUPERVISOR)
ROLE_USER (getAuthority(): ROLE_USER)

Success! Your web filters appear to be properly configured!</pre>
</div>
</div>
<div class="paragraph">
<p>一旦你成功地收到上述消息，返回到示例应用程序的主页，点击"Manage"。然后，你可以使用这个应用程序。注意只有当前用户的联系人会被显示，并且只有拥有<code>ROLE_SUPERVISOR</code>可用授权去删除联系人，在幕后<code>MethodSecurityInterceptor</code>保护业务对象。</p>
</div>
<div class="paragraph">
<p>这应用程序允许你修改与不同的联系人相关联的访问控制列表。一定要试试这个，并了解它是如何工作通过检查应用程序上下文XML文件。</p>
</div>
</div>
<div class="sect2">
<h3 id="ldap-sample"><a class="anchor" href="#ldap-sample"></a>LDAP 示例</h3>
<div class="paragraph">
<p>LDAP例子程序提供了一个基本的配置和使用命名空间和使用传统的bean同等设置在同一个应用程序上下文文件。这意味着，其实是在这个应用程序中配置了两个相同的身份验证提供者。</p>
</div>
</div>
<div class="sect2">
<h3 id="openid-sample"><a class="anchor" href="#openid-sample"></a>OpenID 示例</h3>
<div class="paragraph">
<p>OpenID的示例演示了如何使用命名空间来配置OpenID和如何设置为Google，Yahoo和OpenID设置 <a href="http://openid.net/specs/openid-attribute-exchange-1_0.html">attribute exchange</a>配置（如果你愿意的话，也可以添加其他的供应商）。它使用一个基于JQery的 <a href="http://code.google.com/p/openid-selector/">openid-selector</a>，以提供用户友好的登录页面，它允许用户很容易的选择一个验证提供者，而不是输入OpenID标识符。</p>
</div>
<div class="paragraph">
<p>应用程序的不同之处在于它允许任何用户访问该站点认证情景（只要他们的OpenID身份验证是成功的）。当你第一次登录时，你会得到一个"Welcome [your name]"的消息。如果你注销并重新登录（以相同的身份），那么这应更改为"欢迎回来"，这是通过使用一个实现自定义的<code>UserDetailsService</code>它分配一个标准角色给任何用户，并在内部存储身份的map。显然，一个真正的应用程序将使用一个数据库替换它。看一看源代码了解更多信息，此类还考虑到，不同供应商返回不同属性，并建立相应用户名。</p>
</div>
</div>
<div class="sect2">
<h3 id="cas-sample"><a class="anchor" href="#cas-sample"></a>CAS 示例</h3>
<div class="paragraph">
<p>CAS示例要求你同时运行CAS服务器和CAS客户端。 它不包含在发行包，所以你应该按照 <a href="#get-source">the introduction</a>描述签出目标代码。你会发现<code>sample/cas</code>目录下的相关文件。还有在那里一个<code>Readme.txt</code>文件，这也解释了如何直接从源代码运行服务器和客户端，完全支持SSL。</p>
</div>
</div>
<div class="sect2">
<h3 id="jaas-sample"><a class="anchor" href="#jaas-sample"></a>JAAS 示例</h3>
<div class="paragraph">
<p>该JAAS是很简单的如何用Spring Security 使用JAAS LoginModule 的例子。所提供的<code>LoginModule</code>将成功地验证用户，如果用户名和密码相等，否则抛出一个<code>LoginException</code>异常。在本示例中使用的<code>AuthorityGranter</code>总是授予角色ROLEUSER。示例应用程序还演示了如何通过设置<code>LoginModule</code>的<a href="#nsa-http-jaas-api-provision">jaas-api-provision</a>等于<code>true</code>返回JAAS Subjec来运行。</p>
</div>
</div>
<div class="sect2">
<h3 id="preauth-sample"><a class="anchor" href="#preauth-sample"></a>Pre-Authentication 示例</h3>
<div class="paragraph">
<p>此示例应用程序演示了如何绑定bean从<a href="#preauth">pre-authentication</a> 框架从Java EE容器使用登录信息。用户名和角色是由容器设置的。</p>
</div>
<div class="paragraph">
<p>代码是<code>samples/preauth</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="community"><a class="anchor" href="#community"></a>Spring Security 社区</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="jira"><a class="anchor" href="#jira"></a>问题跟踪</h3>
<div class="paragraph">
<p>Spring Security 使用JIRA来管理bug报告和改进请求，如果你发现错误，请使用JIRA记录报告。不要在支持论坛，邮件列表，或通过电子邮件项目的记录。这些方法是临时的，我们更喜欢使用正式的流程。</p>
</div>
<div class="paragraph">
<p>如果可能的话，在你的问题的报告摸清提供一个JUnit测试，演示任何不正确的行为。或者，更好的是，提供了一个可以解决这个问题的补丁。同样，非常欢迎的提出改进需求，虽然我们只接受、有对应的单元测试的改进请求。这是必要的，以确保保持项目的测试覆盖率。</p>
</div>
<div class="paragraph">
<p>问题跟踪系统你可以通过这里访问： <a href="https://github.com/spring-projects/spring-security/issues" class="bare">https://github.com/spring-projects/spring-security/issues</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="becoming-involved"><a class="anchor" href="#becoming-involved"></a>成为参与者</h3>
<div class="paragraph">
<p>我们欢迎你参与Spring Security项目。有贡献的方法很多，包括阅读论坛，并响应来自其他人的问题，编写新的代码，改进现有的代码，协助文档，开发样品或教程，或则干脆提出建议。</p>
</div>
</div>
<div class="sect2">
<h3 id="further-info"><a class="anchor" href="#further-info"></a>更多信息</h3>
<div class="paragraph">
<p>欢迎为Spring Security 提出问题和意见。你可以使用Spring社区 论坛网站http://spring.io/questions[<a href="http://spring.io/questions" class="bare">http://spring.io/questions</a>] 和其他Spring Security框架的用户进行讨论。请记住，正如前面说的使用JIRA提交bug报告。</p>
</div>
</div>
</div>
</div>
<h1 id="overall-architecture" class="sect0"><a class="anchor" href="#overall-architecture"></a>架构与实现</h1>
<div class="paragraph">
<p>一旦你熟悉了设置和运行一些基于命名空间配置的应用程序，你可能希望开发更多的框架去理解命名空间门面后面实际上是如何运转。类似大部分软件， Spring Security有一定的中央接口，以及通常在整个框架中使用的概念抽象类。在参考指南的这一部分，我们将看看其中的一些，看看它们如何协同工作去支持Spring Security中的身份验证和访问控制。</p>
</div>
<div class="sect1">
<h2 id="technical-overview"><a class="anchor" href="#technical-overview"></a>技术概述</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="runtime-environment"><a class="anchor" href="#runtime-environment"></a>运行环境</h3>
<div class="paragraph">
<p>Spring Security 3.0需要Java 5.0的运行环境或者更高的版本. 由于 Spring Security 是以独立的方式运作, 就不需要什么特殊的配置文件到你的Java运行环境。特别是, 不需要配置专门的Java认证和授权服务(JAAS)策略文件或将Spring Security的位置放到普通路径中。</p>
</div>
<div class="paragraph">
<p>同样，如果你使用的是EJB容器或者Servlet容器也没有必要把任何特殊的配置文件放到任何地方，也不包括Spring Security的服务器类加载器。所有必须的文件都将包含在你的应用程序中。</p>
</div>
<div class="paragraph">
<p>这种设计给部署时间提供了最大的灵活性，你可以简单的复制你的目标文件(可以是JAR, WAR或者EAR)从一个系统到另一个系统，它会立即开始工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="core-components"><a class="anchor" href="#core-components"></a>核心组件</h3>
<div class="paragraph">
<p>在Spring Security 3.0的版本中，<code>spring-security-core</code>中的内容被精简到了最低限度。它不再包含web应用安全,LDAP或命名空间配置的任何代码。我们来看看一些Java类型，你会在核心模块中找到。它们代表了框架的基石，所有如果你需要越过一个简单的命名空间配置，那么最重要的是你要明白它们是什么，即使你不需要直接与它们进行交互。</p>
</div>
<div class="sect3">
<h4 id="truesecuritycontextholder-securitycontext-authentication"><a class="anchor" href="#truesecuritycontextholder-securitycontext-authentication"></a>SecurityContextHolder, SecurityContext和Authentication 对象</h4>
<div class="paragraph">
<p>最根本的对象是<code>SecurityContextHolder</code>。我们把当前应用程序的当前安全环境的细节存储到它里边了， 它也包含了应用当前使用的主体细节。默认情况下<code>SecurityContextHolder</code>使用<code>ThreadLocal</code>存储这些信息， 这意味着，安全环境在同一个线程执行的方法一直是有效的， 即使这个安全环境没有作为一个方法参数传递到那些方法里。这种情况下使用<code>ThreadLocal</code>是非常安全的，只要记得在处理完当前主体的请求以后，把这个线程清除就行了。当然，Spring Security自动帮你管理这一切了， 你就不用担心什么了。</p>
</div>
<div class="paragraph">
<p>有些程序并不适合使用<code>ThreadLocal</code>，因为它们处理线程的特殊方法。比如Swing客户端也许希望Java Virtual Machine里所有的线程 都使用同一个安全环境。<code>SecurityContextHolder</code>可以配置启动策略来指定你希望上下文怎么被存储。对于一个独立的应用程序，你会使用<code>SecurityContextHolder.MODE_GLOBAL</code>策略。其他程序可能也想由安全线程产生的线程也承担同样的安全标识。这是通过使用<code>SecurityContextHolder.MODE_INHERITABLETHREADLOCAL</code>实现。你可以通过两种方式更改默认的<code>SecurityContextHolder.MODE_THREADLOCAL</code>模式。第一个是设置系统属性，第二个是调用<code>SecurityContextHolder</code>的静态方法。大多数应用程序不需要修改默认值，但是如果你想要修改，可以看一下<code>SecurityContextHolder</code>的JavaDocs中的详细信息了解更多。</p>
</div>
<div class="sect4">
<h5 id="true--12"><a class="anchor" href="#true--12"></a>当前用户获取信息</h5>
<div class="paragraph">
<p>我们在<code>SecurityContextHolder</code>内存储目前与应用程序交互的主要细节。Spring Security使用一个<code>Authentication</code>对象来表示这些信息。 你通常不需要创建一个自我认证的对象,但它是很常见的用户查询的<code>Authentication</code>对象。你可以使用以下代码块-从你的应用程序的任何部分-获得当前身份验证的用户的名称，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

if (principal instanceof UserDetails) {
String username = ((UserDetails)principal).getUsername();
} else {
String username = principal.toString();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过调用<code>getContext()</code>返回的对象是<code>SecurityContext</code>接口的实例。这是保存在线程本地存储中的对象。我们将在下面看到，大多数的认证机制以Spring Security返回<code>UserDetails</code>实例为主。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tech-userdetailsservice"><a class="anchor" href="#tech-userdetailsservice"></a>The UserDetailsService</h4>
<div class="paragraph">
<p>从上面的代码片段中还可以看出一件事，就是你可以从<code>Authentication</code>对象中获得安全主体。这个安全主体就是一个<code>Object</code>。大多数情况下，可以强制转换成<code>UserDetails</code>对象 。 <code>UserDetails</code>是一个Spring Security的核心接口。它代表一个主体，是扩展的，而且是为特定程序服务的。 想一下<code>UserDetails</code>章节，在你自己的用户数据库和如何把Spring Security需要的数据放到<code>SecurityContextHolder</code>里。为了让你自己的用户数据库起作用，我们常常把<code>UserDetails</code>转换成你系统提供的类，这样你就可以直接调用业务相关的方法了(比如 <code>getEmail()</code>, <code>getEmployeeNumber()</code>等等)。</p>
</div>
<div class="paragraph">
<p>现在，你可能想知道，我应该什么时候提供这个<code>UserDetails</code>对象呢?我怎么做呢?我想你说这个东西是声明式的，我不需要写任何代码，怎么办?简单的回答是，这里有一个特殊的接口叫<code>UserDetailsService</code>。这个接口里的唯一的一个方法，接收<code>String</code>类型的用户名参数，返回<code>UserDetails</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是Spring Security用户加载信息的最常用的方法并且每当需对用户的信息时你会看到它使用的整个框架。</p>
</div>
<div class="paragraph">
<p>成功认证后，<code>UserDetails</code>用于构建存储在<code>SecurityContextHolder</code>(详见 <a href="#tech-intro-authentication">以下</a>)的<code>Authentication</code>对象。好消息是，我们提供了一些<code>UserDetailsService</code>的实现，包括一个使用内存映射(<code>InMemoryDaoImpl</code>)而另一个使用JDBC(<code>JdbcDaoImpl</code>)。大多数用户倾向于写自己的，常常放到已有的数据访问对象(DAO)上使用这些实现，表示他们的雇员，客户或其他企业应用中的用户。记住这个优势，无论你用<code>UserDetailsService</code>返回的什么数据都可以通过<code>SecurityContextHolder</code>获得，就像上面的代码片段讲的一样。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关于<code>UserDetailsService</code>常常有一些混乱。它纯粹是用于用户数据的DAO并没有其它功能，除了提供该数据到其他组件的框架内。特别是，它<em>不会</em>对用户进行身份验证,这是由<code>AuthenticationManager</code>完成。在许多情况下，如果你需要自定义身份验证过程，直接<a href="#core-services-authentication-manager">实现 <code>AuthenticationProvider</code></a>更有意义 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="tech-granted-authority"><a class="anchor" href="#tech-granted-authority"></a>GrantedAuthority</h4>
<div class="paragraph">
<p>除了主体，另一个<code>Authentication</code>提供的重要方法是<code>getAuthorities()</code>。这个方法提供了<code>GrantedAuthority</code>对象数组。毫无疑问，<code>GrantedAuthority</code>是赋予到主体的权限。这些权限通常使用角色表示，比如<code>ROLE_ADMINISTRATOR</code>或<code>ROLE_HR_SUPERVISOR</code>。这些角色会在后面，对web验证，方法验证和领域对象验证进行配置。Spring Security的其他部分用来拦截这些权限，期望他们被表现出现。<code>GrantedAuthority</code>对象通常是使用<code>UserDetailsService</code>读取的。</p>
</div>
<div class="paragraph">
<p>通常情况下，<code>GrantedAuthority</code>对象是应用程序范围下的授权。它们不会特意分配给一个特定的领域对象。因此，你不能设置一个<code>GrantedAuthority</code>，让他有权限展示编号54的<code>Employee</code>对象，因为如果有成千上万的这种授权，你会很快用光内存(或者，至少，导致程序花费大量时间去验证一个用户)。当然，Spring Security被明确设计成处理常见的需求，但是你最好别因为这个目的使用项目领域模型安全功能。</p>
</div>
</div>
<div class="sect3">
<h4 id="true--13"><a class="anchor" href="#true--13"></a>小结</h4>
<div class="paragraph">
<p>简单回顾一下，Spring Security主要由以下几部分组成的:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SecurityContextHolder</code>, 提供几种访问 <code>SecurityContext</code>的方式。</p>
</li>
<li>
<p><code>SecurityContext</code>, 保存<code>Authentication</code>信息和请求对应的安全信息。</p>
</li>
<li>
<p><code>Authentication</code>, 展示Spring Security特定的主体。</p>
</li>
<li>
<p><code>GrantedAuthority</code>, 反应，在应用程序范围你，赋予主体的权限。</p>
</li>
<li>
<p><code>UserDetails</code>,通过你的应用DAO，提供必要的信息，构建Authentication对象。</p>
</li>
<li>
<p><code>UserDetailsService</code>, 创建一个<code>UserDetails</code>，传递一个 <code>String</code>类型的用户名(或者证书ID或其他).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在，你应该对这种重复使用的组件有一些了解了。 让我们贴近看一下验证的过程。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tech-intro-authentication"><a class="anchor" href="#tech-intro-authentication"></a>验证</h3>
<div class="paragraph">
<p>Spring Security可以在很多不同的认证环境下使用。虽然我们推荐人们使用Spring Security，不与已存在的容器管理认证系统结合，但它也是支持的-使用你自己的属性验证系统进行整合。</p>
</div>
<div class="sect3">
<h4 id="true-spring-security"><a class="anchor" href="#true-spring-security"></a>什么是Spring Security验证?</h4>
<div class="paragraph">
<p>让我们考虑一个大家都很熟悉的标准的验证场景。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>提示用户输入用户名和密码进行登录。</p>
</li>
<li>
<p>该系统 (成功) 验证该用户名的密码正确。</p>
</li>
<li>
<p>获取该用户的环境信息 (他们的角色列表等).</p>
</li>
<li>
<p>为用户建立安全的环境。</p>
</li>
<li>
<p>用户进行，可能执行一些操作，这是潜在的保护的访问控制机制，检查所需权限，对当前的安全的环境信息的操作。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>前三个项目构成的验证过程，所以我们将看看这些是如何发生在Spring Security中的。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用户名和密码进行组合成一个实例<code>UsernamePasswordAuthenticationToken</code> (一个<code>Authentication</code>接口的实例, 我们之前看到的).</p>
</li>
<li>
<p>令牌传递到<code>AuthenticationManager</code>实例进行验证。</p>
</li>
<li>
<p>该<code>AuthenticationManager</code>完全填充<code>Authentication</code>实例返回成功验证。</p>
</li>
<li>
<p>安全环境是通过调用 <code>SecurityContextHolder.getContext().setAuthentication(&#8230;&#8203;)</code>, 传递到返回的验证对象建立的。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>从这一点上来看，用户被认为是被验证的。让我们看看一些代码作为一个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.security.authentication.*;
import org.springframework.security.core.*;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;

public class AuthenticationExample {
private static AuthenticationManager am = new SampleAuthenticationManager();

public static void main(String[] args) throws Exception {
	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

	while(true) {
	System.out.println("Please enter your username:");
	String name = in.readLine();
	System.out.println("Please enter your password:");
	String password = in.readLine();
	try {
		Authentication request = new UsernamePasswordAuthenticationToken(name, password);
		Authentication result = am.authenticate(request);
		SecurityContextHolder.getContext().setAuthentication(result);
		break;
	} catch(AuthenticationException e) {
		System.out.println("Authentication failed: " + e.getMessage());
	}
	}
	System.out.println("Successfully authenticated. Security context contains: " +
			SecurityContextHolder.getContext().getAuthentication());
}
}

class SampleAuthenticationManager implements AuthenticationManager {
static final List&lt;GrantedAuthority&gt; AUTHORITIES = new ArrayList&lt;GrantedAuthority&gt;();

static {
	AUTHORITIES.add(new SimpleGrantedAuthority("ROLE_USER"));
}

public Authentication authenticate(Authentication auth) throws AuthenticationException {
	if (auth.getName().equals(auth.getCredentials())) {
	return new UsernamePasswordAuthenticationToken(auth.getName(),
		auth.getCredentials(), AUTHORITIES);
	}
	throw new BadCredentialsException("Bad Credentials");
}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里我们已经写了一个小程序，要求用户输入一个用户名和密码并执行上述序列。这个<code>AuthenticationManager</code>我们这里将验证用户的用户名和密码将其设置成一样的，它给每一个用户分配一个单一的角色。从上面输出的将是类似的东西:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt" data-lang="txt">Please enter your username:
bob
Please enter your password:
password
Authentication failed: Bad Credentials
Please enter your username:
bob
Please enter your password:
bob
Successfully authenticated. Security context contains: \
org.springframework.security.authentication.UsernamePasswordAuthenticationToken@441d0230: \
Principal: bob; Password: [PROTECTED]; \
Authenticated: true; Details: null; \
Granted Authorities: ROLE_USER</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，你通常不需要写任何这样的代码。这个过程通常会发生在内部，以一个web认证过滤器为例，我们刚刚在这里的代码显示，在Spring Security中究竟是什么构成了验证的问题，有一个相对简单的答案。用户验证时，<code>SecurityContextHolder</code>包含一个完全填充的<code>Authentication</code>对象的用户进行身份验证。</p>
</div>
</div>
<div class="sect3">
<h4 id="true-securitycontextholder"><a class="anchor" href="#true-securitycontextholder"></a>直接设置SecurityContextHolder的内容</h4>
<div class="paragraph">
<p>事实上，Spring Security不介意你如何把<code>Authentication</code>对象包含在<code>SecurityContextHolder</code>内。唯一的关键要求是<code>SecurityContextHolder</code>包含<code>Authentication</code>在<code>AbstractSecurityInterceptor</code>之前(我们会看到更多的版本)需要用户授权操作。</p>
</div>
<div class="paragraph">
<p>你可以(很多用户都这样做)写一个自己的过滤器或MVC控制器来提供验证系统的交互，这些都不是基于Spring Security的。比如，你也许使用容器管理认证，从ThreadLocal或JNDI里获得当前用户信息。或者，你的公司可能有一个遗留系统，它是一个企业标准，你不能控制它。这种情况下，很容易让Spring Security工作，也能提供验证能力。你所需要的就是写一个过滤器(或等价物)从指定位置读取第三方用户信息，把它放到<code>SecurityContextHolder</code>里。在这种情况下，你还需要考虑的事情通常是由内置的认证基础设施自动照顾。例如，<a href="#tech-intro-sec-context-persistence">缓存请求的情况下</a>你可能需要事先创建一个HTTP会话，在编写客户端响应之前 <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>如果你想知道<code>AuthenticationManager</code>是如何以现实世界的例子来实现，我们可以来看看  <a href="#core-services-authentication-manager">核心服务一章</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tech-intro-web-authentication"><a class="anchor" href="#tech-intro-web-authentication"></a>在Web应用程序中的身份验证</h3>
<div class="paragraph">
<p>现在让我们来看看你在Web应用程序中使用Spring Security的情况(不启用<code>web.xml</code>安全性)。用户如何进行身份验证和建立安全环境?</p>
</div>
<div class="paragraph">
<p>考虑一个典型的Web应用程序的身份验证过程:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>你访问首页, 点击一个链接。</p>
</li>
<li>
<p>向服务器发送一个请求，服务器判断你是否在访问一个受保护的资源。</p>
</li>
<li>
<p>如果你还没有进行过认证，服务器发回一个响应，提示你必须进行认证。响应可能是HTTP响应代码，或者是重新定向到一个特定的web页面。</p>
</li>
<li>
<p>依据验证机制，你的浏览器将重定向到特定的web页面，这样你可以添加表单，或者浏览器使用其他方式校验你的身份（比如，一个基本校验对话框，cookie，或者X509证书，或者其他）。</p>
</li>
<li>
<p>浏览器会发回一个响应给服务器。 这将是HTTP POST包含你填写的表单内容，或者是HTTP头部，包含你的验证信息。</p>
</li>
<li>
<p>下一步，服务器会判断当前的证书是否是有效的， 如果他们是有效的，下一步会执行。 如果他们是非法的，通常你的浏览器会再尝试一次（所以你返回的步骤二）。</p>
</li>
<li>
<p>你发送的原始请求，会导致重新尝试验证过程。有希望的是，你会通过验证，得到足够的授权，访问被保护的资源。如果你有足够的权限，请求会成功。否则，你会收到一个HTTP错误代码403，意思是访问被拒绝。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Spring Security使用鲜明的类负责上面提到的每个步骤。主要的部分是（为了使用他们） <code>ExceptionTranslationFilter</code>, 一个 <code>AuthenticationEntryPoint</code> 一个验证机制, 我们在上一节看到它负责调用<code>AuthenticationManager</code>。</p>
</div>
<div class="sect3">
<h4 id="trueexceptiontranslationfilter"><a class="anchor" href="#trueexceptiontranslationfilter"></a>ExceptionTranslationFilter</h4>
<div class="paragraph">
<p><code>ExceptionTranslationFilter</code>是一个Spring Security过滤器，用来检测是否抛出了Spring Security异常。这些异常会被<code>AbstractSecurityInterceptor</code>抛出，它主要用来提供验证服务。我们会在下一节讨论<code>AbstractSecurityInterceptor</code>，但是现在，我们只需要知道，它是用来生成Java，并且要知道和HTTP没什么关系，或者如何验证一个主体。而<code>ExceptionTranslationFilter</code>提供这些服务，使用特点那个的响应，返回错误代码403(如果主体被验证了，但是权限不足-在上边的步骤七),或者启动一个<code>AuthenticationEntryPoint</code>(如果主体没有被认证，然后我们需要进入步骤三)。</p>
</div>
</div>
<div class="sect3">
<h4 id="tech-intro-auth-entry-point"><a class="anchor" href="#tech-intro-auth-entry-point"></a>AuthenticationEntryPoint</h4>
<div class="paragraph">
<p><code>AuthenticationEntryPoint</code>对应上面列表中的步骤三。如你所想的，每个web应用程序都有默认的验证策略(好的，这可以在Spring Security里配置一切，但是让我们现在保持简单)。每个主要验证系统会有它自己的<code>AuthenticationEntryPoint</code>实现， 会执行动作，如同步骤三里的描述一样。</p>
</div>
</div>
<div class="sect3">
<h4 id="true--14"><a class="anchor" href="#true--14"></a>验证机制</h4>
<div class="paragraph">
<p>在你的浏览器决定提交你的认证证书之后(使用HTTP表单发送或者是HTTP头),服务器部分需要有一些东西来"收集"这些验证信息。现在我们到了上述的第六步。 在Spring Security里，我们需要一个特定的名字，来描述从用户代码（通常是浏览器）收集验证信息的功能，这个名字就是"验证机制"。实例是窗体的基本登录和基本的身份验证。一旦认证细节已从用户代理收集,建立一个<code>Authentication</code> "request"对象，然后提交给<code>AuthenticationManager</code>。</p>
</div>
<div class="paragraph">
<p>验证机制重新获得了组装好的<code>Authentication</code>对象时，它会认为请求有效，把<code>Authentication</code>放到<code>SecurityContextHolder</code>里的，然后导致原始请求重审(第七步)。另一方面,如果<code>AuthenticationManager</code>驳回了请求,验证机制会让用户代码重试(第二步)。</p>
</div>
</div>
<div class="sect3">
<h4 id="tech-intro-sec-context-persistence"><a class="anchor" href="#tech-intro-sec-context-persistence"></a>Storing the SecurityContext between requests</h4>
<div class="paragraph">
<p>根据不同的应用程序类型，在用户操作的过程中需要有合适的策略来保存security信息。在一个典型的web应用中，一个用户登录系统之后就会被一个特有的session Id所唯一标识,服务器会将session作用期间的principal数据保存在缓存中。在Spring Security中,保存<code>SecurityContext</code>的任务落在了<code>SecurityContextPersistenceFilter</code>身上，它默认将上下文当做<code>HttpSession</code>属性保存在HTTP请求中,并且将每一个请求的上下文保存在<code>SecurityContextHolder</code>中，最重要的功能,是在请求结束之后,清理<code>SecurityContextHolder</code>。你不需要处于安全的目的直接和<code>HttpSession</code>打交道。在这里仅仅只是不需要那样做-总是使用<code>SecurityContextHolder</code>来代替<code>HttpSession</code>。</p>
</div>
<div class="paragraph">
<p>许多其他的应用（举个例子：一个无状态的RESTful风格web服务）不使用Http Session并且每次请求过来都会进行验证。然而比较重要的是:`SecurityContextPersistenceFilter`被包含在过滤器链中,并确保每次请求完毕之后清理<code>SecurityContextHolder</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>其中有一个应用程序接收一个会话的并发请求,同样的<code>SecurityContext</code>实例将线程之间共享。即使正在使用<code>ThreadLocal</code>,它是相同的实例,从每个线程的<code>HttpSession</code>检索。如果你希望暂时改变一个线程正在运行的上下文这很有意义。如果你只是使用<code>SecurityContextHolder.getContext()</code>,和调用<code>setAuthentication(anAuthentication)</code>返回的上下文对象,那么<code>Authentication</code>对象将在<em>全部</em>并发线程共享相同的<code>SecurityContext</code>情况的变化。 你可以自定义<code>SecurityContextPersistenceFilter</code>的行为,为每一个请求创建一个完全新的<code>SecurityContext</code>,防止在一个线程的变化影响另一个。或者,你可以创建一个新的实例,只是在这个点上,你暂时改变了背景。方法<code>SecurityContextHolder.createEmptyContext()</code>总是返回一个新的上下文实例。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tech-intro-access-control"><a class="anchor" href="#tech-intro-access-control"></a>Spring Security的访问控制(授权)</h3>
<div class="paragraph">
<p>负责Spring Security访问控制决策的主要接口是<code>AccessDecisionManager</code>。它有一个<code>decide</code>方法，它需要一个<code>Authentication</code>对象请求访问,一个"secure object"(见下文)和安全元数据属性的列表适用的对象(如一个列表哪些角色需要被访问授权)。</p>
</div>
<div class="sect3">
<h4 id="true-aop"><a class="anchor" href="#true-aop"></a>安全和AOP建议</h4>
<div class="paragraph">
<p>如果你熟悉AOP的话，就会知道有几种不同的拦截方式：之前，之后，抛异常和环绕。 其中环绕是非常有用的，因为advisor可以决定是否执行这个方法，是否修改返回的结果，是否抛出异常。 Spring Security为方法调用提供了一个环绕advice，就像web请求一样。 我们使用Spring的标准AOP支持制作了一个处理方法调用的环绕advice，我们使用标准Filter建立了对web请求的环绕advice。</p>
</div>
<div class="paragraph">
<p>对那些不熟悉AOP的人，需要理解的关键问题是Spring Security可以帮助你保护方法的调用，就像保护web请求一样。大多数人对保护服务层里的安全方法非常按兴趣。这是因为在目前这一代J2EE程序里，服务器放了更多业务相关的逻辑。如果你只是需要保护服务层的方法调用，Spring标准AOP平台就够了。如果你想直接保护领域对象，你会发现AspectJ非常值得考虑。</p>
</div>
<div class="paragraph">
<p>可以选择使用AspectJ还是SpringAOP处理方法验证，或者你可以选择使用filters处理web请求验证。 你可以不选，选择其中一个，选择两个，或者三个都选。主流的应用是处理一些web请求验证，再结合一些在服务层里的Spring AOP方法调用验证。</p>
</div>
</div>
<div class="sect3">
<h4 id="secure-objects"><a class="anchor" href="#secure-objects"></a>安全对象和AbstractSecurityInterceptor</h4>
<div class="paragraph">
<p>那么什么<em>是</em>一个"安全对象"呢?Spring Security使用术语是指可以有安全性的任何对象(如授权决策)应用于它。最常见的例子就是方法调用和web请求。</p>
</div>
<div class="paragraph">
<p>Spring Security支持的每个安全对象类型都有它自己的类型,他们都是<code>AbstractSecurityInterceptor</code>的子类。很重要的是,如果主体是已经通过了验证,在<code>AbstractSecurityInterceptor</code>被调用的时候,<code>SecurityContextHolder</code>将会包含一个有效的<code>Authentication</code>。</p>
</div>
<div class="paragraph">
<p><code>AbstractSecurityInterceptor</code>提供了一套一致的工作流程，来处理对安全对象的请求，通常是:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>查找当前请求里分配的"配置属性"。</p>
</li>
<li>
<p>把安全对象，当前的<code>Authentication</code>和配置属性,提交给<code>AccessDecisionManager</code>来进行以此认证决定。</p>
</li>
<li>
<p>有可能在调用的过程中,对<code>Authentication</code>进行修改。</p>
</li>
<li>
<p>允许安全对象进行处理（假设访问被允许了）。</p>
</li>
<li>
<p>在调用返回的时候执行配置的<code>AfterInvocationManager</code>。如果调用引发异常,<code>AfterInvocationManager</code>将不会被调用。</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="tech-intro-config-attributes"><a class="anchor" href="#tech-intro-config-attributes"></a>配置属性是什么?</h5>
<div class="paragraph">
<p>一个"配置属性"可以看做是一个字符串,它对于<code>AbstractSecurityInterceptor</code>使用的类是有特殊含义的。它们由框架内接口<code>ConfigAttribute</code>表示。它们可能是简单的角色名称或拥有更复杂的含义,这就与<code>AccessDecisionManager</code>实现的先进程度有关了。<code>AbstractSecurityInterceptor</code>和配置在一起的 <code>SecurityMetadataSource</code> 用来为一个安全对象搜索属性。通常这个属性对用户是不可见的。配置属性将以注解的方式设置在受保护方法上，或者作为受保护URLs的访问属性。例如,当我们看到像<code>&lt;intercept-url pattern='/secure/**' access='ROLE_A,ROLE_B'/&gt;</code>命名空间中的介绍,这是说配置属性<code>ROLE_A</code>和<code>ROLE_B</code>适用于匹配Web请求的特定模式。在实践中,使用默认的<code>AccessDecisionManager</code>配置, 这意味着,任何人谁拥有<code>GrantedAuthority</code>只要符合这两个属性将被允许访问。严格来说,它们只是依赖于<code>AccessDecisionManager</code>实施的属性和解释。使用前缀<code>ROLE_</code>是一个标记,以表明这些属性是角色,应该由Spring Security的<code>RoleVoter</code>前缀被消耗掉。这只是使用<code>AccessDecisionManager</code>的选择基础。我们将在<a href="#authz-arch">授权章</a>看到<code>AccessDecisionManager</code>是如何实现的。</p>
</div>
</div>
<div class="sect4">
<h5 id="truerunasmanager"><a class="anchor" href="#truerunasmanager"></a>RunAsManager</h5>
<div class="paragraph">
<p>假设<code>AccessDecisionManager</code>决定允许执行这个请求,<code>AbstractSecurityInterceptor</code>会正常执行这个请求。话虽如此，罕见情况下，用户可能需要把<code>SecurityContext</code>的<code>Authentication</code>换成另一个<code>Authentication</code>, 这是由<code>AccessDecisionManager</code> 调用<code>RunAsManager</code>。这也许在,有原因,不常见的情况下有用,比如服务层方法需要调用远程系统表现不同的身份。 因为Spring Security自动传播安全身份，从一个服务器到另一个（假设你使用了配置好的RMI或者HttpInvoker远程调用协议客户端），就可以用到它了。</p>
</div>
</div>
<div class="sect4">
<h5 id="trueafterinvocationmanager"><a class="anchor" href="#trueafterinvocationmanager"></a>AfterInvocationManager</h5>
<div class="paragraph">
<p>按照下面安全对象执行和返回的方式-可能意味着完全的方法调用或过滤器链的执行-在<code>AbstractSecurityInterceptor</code>得到一个最后的机会来处理调用。这种状态下<code>AbstractSecurityInterceptor</code>对有可能修改返回对象感兴趣。你可能想让它发生，因为验证决定不能“关于如何在”一个安全对象调用。高可插拔性,<code>AbstractSecurityInterceptor</code>通过控制<code>AfterInvocationManager</code>在实际需要的时候修改对象。这里类实际上可能替换对象，或者抛出异常，或者什么也不做。如果调用成功后，检查调用才会执行。如果出现异常，额外的检查将被跳过。</p>
</div>
<div class="paragraph">
<p><code>AbstractSecurityInterceptor</code> 和它的相关对象 <a href="#abstract-security-interceptor">Security interceptors and the "secure object" model</a></p>
</div>
<div id="abstract-security-interceptor" class="imageblock">
<div class="content">
<img src="images/security-interception.png" alt="Abstract Security Interceptor">
</div>
<div class="title">Figure 1. Security interceptors and the "secure object" model</div>
</div>
</div>
<div class="sect4">
<h5 id="true--15"><a class="anchor" href="#true--15"></a>扩展安全对象模型</h5>
<div class="paragraph">
<p>只有当开发人员考虑一个全新的拦截方法和授权请求时才需要直接使用安全对象。例如，为了确保对消息系统的调用，它有可能建立建立一个新的安全对象。任何东西都需要安全，并且还提供了一种方法去调用（如建议语义的AOP）能够被做成一个安全对象。不得不说的是，大多数Spring应用程序将只使用三种目前完全支持的安全对象类型(AOP Alliance <code>MethodInvocation</code>, AspectJ <code>JoinPoint</code>和web请求<code>FilterInvocation</code>)。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="localization"><a class="anchor" href="#localization"></a>Localization</h3>
<div class="paragraph">
<p>Spring Security支持终端用户看到异常消息的本地化。如果你的应用程序是专为讲英语的用户设计的，你不需要做任何事情，因为默认所有的安全信息都是英文的，如果你需要支持其他地方，你需要知道的一切都被包含在这部分。</p>
</div>
<div class="paragraph">
<p>所有异常消息都可以本地化，包括有关验证失败和访问被拒绝（授权失败）的消息。这主要集中在开发者和系统发布（包括不正确的属性，接口违反合同，使用不正确的构造器，开始验证，日志调试等级）异常和日志消息没有本地化，而是使用硬编码的Spring Security的英文代码。</p>
</div>
<div class="paragraph">
<p>在<code>spring-security-core-xx.jar</code>的运输中你会发现一个<code>org.springframework.security</code> 包含了 <code>messages.properties</code>文件,以及一些常用版本的本地化语言。这应该是你的<code>ApplicationContext</code>,因为Spring Security实现了Spring的<code>MessageSourceAware</code>界面，希望这些消息是依赖于应用程序上下文启动的时候注入。通常你需要做的是创建你的应用程序上下文参考消息里面的bean。一个例子如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="messageSource"
	class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;
&lt;property name="basename" value="classpath:org/springframework/security/messages"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该<code>messages.properties</code>是按照标准的资源束命名方式，为Spring Security的消息所支持的默认语言。这个默认的文件是英文的。</p>
</div>
<div class="paragraph">
<p>如果您希望自定义<code>messages.properties</code>文件，或支持其他语言，您应该复制该文件，相应地重命名它，并在上面的bean定义中注释它。在这个文件中没有大量的消息密钥，因此本地化不应该被认为是一个重大举措。如果你对这个文件执行定为操作，请考虑与社区分享你的工作通过记录JIRA任务和附加被你恰当命名的<code>messages.properties</code>本地化版本。</p>
</div>
<div class="paragraph">
<p>Spring Security依赖于Spring"s的本地化支持，以实际查找适当的消息。为了这项工作，你必须确保从传入请求的区域存储在Spring&#8217;s`org.springframework.context.i18n.LocaleContextHolder`。Spring MVC的` DispatcherServlet <code>会自动为你的程序做，但因为Spring Security的过滤器在那之前被调用，`localecontextholder</code>需在过滤器被呼叫之前建立在包含正确的<code>Locale</code>里。你也可以在你自己的过滤器里面做这个（必须做完这项在Spring Security的<code>web.xml</code>过滤之前）或者你可以使用Spring的<code>RequestContextFilter</code>。请参阅Spring Framework文档，以进一步详细说明使用Spring定位。</p>
</div>
<div class="paragraph">
<p>“联系人”示例应用程序设置为使用本地化消息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="core-services"><a class="anchor" href="#core-services"></a>核心服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在，我们对Spring Security的架构和核心类进行高级别的概述，让我们在一个或两个核心接口及其实现的仔细看看，尤其是<code>AuthenticationManager</code>，<code>UserDetailsService</code>和<code>AccessDecisionManager</code>这些东西的信息都在这个文档的里面，所以这一点很重要，你要知道他们是如何配置如何操作的。</p>
</div>
<div class="sect2">
<h3 id="core-services-authentication-manager"><a class="anchor" href="#core-services-authentication-manager"></a>The AuthenticationManager, ProviderManager and AuthenticationProvider</h3>
<div class="paragraph">
<p>该 <code>AuthenticationManager</code>只是一个接口，这样的实现可以是我们选择的任何东西，但它是如何在实践中运作的?如果我们需要检查多个授权数据库或者将不同的授权服务结合起来，类似数据库和LDAP服务器?</p>
</div>
<div class="paragraph">
<p>Spring Security的默认实现被称为<code>ProviderManager</code>而非处理身份验证请求本身，它委托给一个列表去配置<code>AuthenticationProvider</code>，其中每个查询反过来，看它是否能进行认证。每个提供程序都将抛出一个异常或返回一个完全填充的身份验证对象。还记得我们的好朋友，<code>UserDetails</code>和<code>UserDetailsService</code>吗?如果没有，回到前面的章节刷新你的记忆。到验证的认证请求的最常见的方法是加载相应<code>UserDetails</code>并针对已经由用户输入所述一个检查加载密码。这是由<code>DaoAuthenticationProvider</code>所使用的方法（见下文）。加载的<code>UserDetails</code>对象-尤其是<code>GrantedAuthority</code>的IT包含-建设是返回一个成功验证，并存储在<code>SecurityContext</code>完全填充<code>Authentication</code>对象时，将被使用。</p>
</div>
<div class="paragraph">
<p>如果你使用的命名空间，创建并在内部进行维护<code>ProviderManager</code>的一个实例，您可以通过使用命名空间身份验证提供元素添加提供商。(see <a href="#ns-auth-manager">命名空间章节</a>)。在这种情况下，你不应该声明在应用程序上下文中的<code>ProviderManager</code> bean。但是，如果你没有使用命名空间，那么你会这样声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="authenticationManager"
		class="org.springframework.security.authentication.ProviderManager"&gt;
	&lt;constructor-arg&gt;
		&lt;list&gt;
			&lt;ref local="daoAuthenticationProvider"/&gt;
			&lt;ref local="anonymousAuthenticationProvider"/&gt;
			&lt;ref local="ldapAuthenticationProvider"/&gt;
		&lt;/list&gt;
	&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中，我们有三个提供者。它们试图在顺序显示(它是通过使用一个<code>List</code>的暗示)，每个提供者都能尝试验证，或者通过简单的返回<code>null</code>跳过认证。如果所有的实现都返回<code>null</code>，则<code>ProviderManager</code>将抛出一个<code>ProviderNotFoundException</code>。如果你有兴趣了解更多的有关提供者，请参考<code>ProviderManager</code>的JavaDocs。</p>
</div>
<div class="paragraph">
<p>身份验证机，如Web表单登录处理过滤器被注入到<code>ProviderManager</code>的引用，将调用它来处理自己的身份验证请求。你需要的供应商有时可以与认证机制互换，而在其他时间，他们将依赖于特定的认证机制。例如，<code>DaoAuthenticationProvider</code>和<code>LdapAuthenticationProvider</code>给它提交一个简单的用户名/密码验证请求，并因此将与基于表单登录或HTTP基本验证工作的机制兼容。另一方面，一些认证机制创建只能由单一类型<code>AuthenticationProvider</code>解释的认证请求对象。这一方面的一个例子是JA-SIG CAS，它使用一个服务票据的概念，因此可以仅通过一个<code>CasAuthenticationProvider</code>进行认证。你不必太在意这一点，因为如果你忘记注册一个合适的供应商，你会简单地收到一个<code>ProviderNotFoundException</code>不进行认证的尝试。</p>
</div>
<div class="sect3">
<h4 id="core-services-erasing-credentials"><a class="anchor" href="#core-services-erasing-credentials"></a>清楚成功认证的凭据</h4>
<div class="paragraph">
<p>默认情况下(从Spring Security 3.1开始)的<code>ProviderManager</code>将试图清除它返回一个成功的认证请求的Authentication`对象的任何敏感的身份验证信息。这可以防止密码等个人资料超过保留时间。</p>
</div>
<div class="paragraph">
<p>当使用用户对象的高速缓存时，例如，改善在无状态情况下应用程序的性能，这可能导致问题。如果<code>Authentication</code>包含在高速缓存（诸如<code>UserDetails</code>实例）的对象的引用中，将其凭证移除，则它将不再能够进行对缓存的值进行验证。你需要考虑到这一点，如果你使用的是高速缓存。一个显而易见的解决方案是让一个对象的副本，无论是在高速缓存中执行或在<code>AuthenticationProvider</code>它创建返回<code>Authentication</code>对象。另外，你可以在<code>ProviderManager</code>中禁用<code>eraseCredentialsAfterAuthentication</code>。查看Javadoc了解更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="core-services-dao-provider"><a class="anchor" href="#core-services-dao-provider"></a>DaoAuthenticationProvider</h4>
<div class="paragraph">
<p>Spring Security中实现最简单的<code>AuthenticationProvider</code>是<code>DaoAuthenticationProvider</code>，也是最早支持的框架。它利用了<code>UserDetailsService</code>（作为DAO）去查找用户名和密码。它的用户进行身份验证通过<code>userdetailsservice</code>加载`usernamepasswordauthenticationtoken `提交密码进行一对一的比较。配置提供程序是非常简单的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="daoAuthenticationProvider"
	class="org.springframework.security.authentication.dao.DaoAuthenticationProvider"&gt;
&lt;property name="userDetailsService" ref="inMemoryDaoImpl"/&gt;
&lt;property name="passwordEncoder" ref="passwordEncoder"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个<code>PasswordEncoder</code>是可选的。一个<code>PasswordEncoder</code>提供编码以及<code>UserDetails</code>对象提出的密码是从配置<code>UserDetailsService</code>返回的解码。 这将更加详细 <a href="#core-services-password-encoding">如下</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueuserdetailsservice"><a class="anchor" href="#trueuserdetailsservice"></a>UserDetailsService实现</h3>
<div class="paragraph">
<p>本参考指南早些时候提到的，大多数的认证供应商利用的` userdetails <code>和</code> userdetailsservice <code>接口。回想一下，`UserDetailsService</code>是一个方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回的<code>UserDetails</code>是提供给getters的一个接口，以保证非空的认证信息，例如，用户名，密码，授权和用户帐户是否被启用或禁用。大多数认证供应商将使用<code>UserDetailsService</code>，即使用户名和密码不作为认证决定的一部分。他们可以使用返回的<code>UserDetails</code>对象为其<code>GrantedAuthority</code>信息对象，因为其他的一些系统（如LDAP或X.509或CAS等）承担了实际验证凭证的的责任。</p>
</div>
<div class="paragraph">
<p>鉴于<code>UserDetailsService</code>就是这么简单实现的，它应该便于用户检索使用自己选择的持久化策略的认证信息。话虽如此，Spring Security确实包括了许多有用的基本实现，我们将在下面看到。</p>
</div>
<div class="sect3">
<h4 id="core-services-in-memory-service"><a class="anchor" href="#core-services-in-memory-service"></a>在内存认证</h4>
<div class="paragraph">
<p>简单的使用去创建一个自定义的<code>UserDetailsService</code>实现选择从一个持久性引擎中提取信息，但许多应用程序不需要这么复杂。尤其是如果你正在建设一个原型应用或刚刚开始结合Spring Security当你真的不想花时间配置数据库或写作<code>userdetailsservice</code>实现。对于这种情况，一个简单的选项是使用安全性 <a href="#ns-minimal">命名空间</a>的<code>user-service</code>元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;user-service id="userDetailsService"&gt;
&lt;user name="jimi" password="jimispassword" authorities="ROLE_USER, ROLE_ADMIN" /&gt;
&lt;user name="bob" password="bobspassword" authorities="ROLE_USER" /&gt;
&lt;/user-service&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也支持一个外部属性文件的使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;user-service id="userDetailsService" properties="users.properties"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>属性文件应包含在表单条目</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt" data-lang="txt">username=password,grantedAuthority[,grantedAuthority][,enabled|disabled]</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt" data-lang="txt">jimi=jimispassword,ROLE_USER,ROLE_ADMIN,enabled
bob=bobspassword,ROLE_USER,enabled</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-services-jdbc-user-service"><a class="anchor" href="#core-services-jdbc-user-service"></a>JdbcDaoImpl</h4>
<div class="paragraph">
<p>Spring Security还包括<code>UserDetailsService</code>，它可以从一个JDBC数据源获得认证信息。内部Spring JDBC的使用，避免了一个全功能对象关系映射（ORM）的复杂性来存储用户信息。如果你的应用程序不使用ORM工具，你可以写一个自定义<code>UserDetailsService</code>重用在你可能已经创建好的映射文件上。回到 <code>JdbcDaoImpl</code>，实例的配置如下：:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
&lt;property name="driverClassName" value="org.hsqldb.jdbcDriver"/&gt;
&lt;property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
&lt;property name="username" value="sa"/&gt;
&lt;property name="password" value=""/&gt;
&lt;/bean&gt;

&lt;bean id="userDetailsService"
	class="org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"&gt;
&lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过修改上面的<code>DriverManagerDataSource</code>使用不同的关系型数据库管理系统。你也可以从JNDI获得，与任何其他的Spring配置使用一个全球性的数据源。</p>
</div>
<div class="sect4">
<h5 id="trueauthority-groups"><a class="anchor" href="#trueauthority-groups"></a>Authority Groups</h5>
<div class="paragraph">
<p>默认情况下，<code>JdbcDaoImpl</code>加载权限直接映射到用户的角色(见 <a href="#appendix-schema">数据库架构附录</a>)。另一种方法是将权限分成组并分配组给用户。有些人喜欢这种方式作为管理用户权限的一种手段。见 <code>JdbcDaoImpl</code> Javadoc获得如何能够使用权限组的更多信息。该组架构也包括在附录中。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core-services-password-encoding"><a class="anchor" href="#core-services-password-encoding"></a>Password Encoding</h3>
<div class="paragraph">
<p>Spring Security的 <code>PasswordEncoder</code>接口用于支持密码以某种方式在持久存储中进行编码。你不应该在纯文本中存储密码。总是使用单向密码算法如BCrypt使用内置的混淆值，对于每个存储的密码都是不同的。不要使用普通的哈希函数，如MD5或SHA，甚至是一个混淆的版本。BCrypt是故意设计成慢，用于阻碍离线密码破解，而标准的散列算法是快速和能轻易地被用来测试在并行密码定制的硬件上。你可能会认为这并不适用于你，因为你的密码数据库是安全的，和离线攻击不是一个风险线上的。如果是这样的话，做一些研究并阅读所有的高知名度、一直被嘲笑存储密码不安全并已妥协的网站。最好是在安全的一边。对于安全性使用<code>org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"</code>是一个不错的选择。在其他常见的编程语言中也有兼容的实现，所以对于互相操作性它也是一个很好的选择。</p>
</div>
<div class="paragraph">
<p>如果你使用的是已经有哈希密码的遗留系统，那么你需要使用一个解码器来匹配你当前的算法，至少要等到你可以将用户迁移到一个更安全的方案（通常这将涉及到要求用户设置一个新的密码，因为哈希值是不可逆的）。Spring Security具有包含传统的密码编码功能的实现，即<code>org.springframework.security.authentication.encoding</code>包。该<code>DaoAuthenticationProvider</code>可与新的或旧的<code>PasswordEncoder</code>类型注入。</p>
</div>
<div class="sect3">
<h4 id="true-hash"><a class="anchor" href="#true-hash"></a>什么是hash?</h4>
<div class="paragraph">
<p>密码散列对于Spring Security不是唯一的，但是一个共同的来源是对于不熟悉概念的用户。哈希（或摘要）算法是一个单向函数，它由一些输入数据，如密码产生一块固定长度的输出数据（散列）的。作为一个例子，字符串"密码"（十六进制）的MD5哈希。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt" data-lang="txt">5f4dcc3b5aa765d61d8327deb882cf99</code></pre>
</div>
</div>
<div class="paragraph">
<p>从这一方面来说hash的是"单向"，要获得给定的散列值这是很困难的(实际上是不可能的)，或者说实际上任何可能的输出都会产生散列值的原始输入。这个属性使得哈希值对于进行身份验证是非常有用的。它们可以被存储在用户数据库作为替代明文口令，即使值受到损害它们也不会立刻露出可用于登录的密码。请注意，这也意味着一旦它被编码，你就没有办法恢复密码。</p>
</div>
</div>
<div class="sect3">
<h4 id="true-hash-salt"><a class="anchor" href="#true-hash-salt"></a>在Hash中添加Salt</h4>
<div class="paragraph">
<p>随着密码的哈希值的使用有一个潜在的问题就是如果一个普通的词用于输入，则相对容易得到哈希的单向属性。人们倾向于选择类似的密码和巨大的字典，这些以前被黑客攻击的网站都可以在线。例如，如果你使用谷歌搜索哈希值<code>5f4dcc3b5aa765d61d8327deb882cf99</code>，你会很快发现原来的"密码"。以类似的方式，攻击者可以构建散列的字典从标准单词列表中查找原来的密码。有一种方法帮助防止这种情况就是有一个合适的强密码策略，以防止常用的单词被使用。另一个是计算散列何时使用"salt"。这是它与计算散列之前密码组合的每个用户的已知数据的附加字符串。理想情况下，数据应该是随机的，但在实践中，任何salt值通常是最好没有。使用的salt意味着攻击者必须建立散列每个salt值的一个单独的字典，使得攻击更加复杂（但不是不可能）。</p>
</div>
<div class="paragraph">
<p>Bcrypt自动生成每个密码随机salt值时，它被编码，并存储在一个标准格式的BCrypt的字符串。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>传统的方法来处理salt是注入一个<code>SaltSource</code>到<code>DaoAuthenticationProvider</code>，这将获得一个特定的用户salt值并将其传递到<code>PasswordEncoder</code>。使用BCrypt意味着你不用担心salt处理的细节（如值存储在什么地方），因为它是在内部完成的。所以，我们强烈建议你使用BCrypt，除非你已经有一个系统分开其中所存储的salt。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="truehashing-and-authentication"><a class="anchor" href="#truehashing-and-authentication"></a>Hashing and Authentication</h4>
<div class="paragraph">
<p>当一个认证供应商（如Spring Security的<code>DaoAuthenticationProvider</code>）需要对某个用户的已知值提交的认证请求来检查密码和存储的密码以某种方式进行编码，然后提交的值必须准确使用编码相同的算法。这个取决于你的检查，这些都是兼容的，因为Spring Security没有对持久值的控制。如果添加的密码散列以你的身份验证配置Spring Security的，和你的数据库中包含明文密码，那么就没有办法验证成功。即使你知道你的数据库是使用MD5编码的密码，例如，你的应用程序被配置为使用Spring Security的<code>Md5PasswordEncoder</code>，那么有很多事情会是错误的。数据库可以具有在Base 64编码的密码，例如当编码器使用十六进制字符串（缺省值）。替代地数据库可以是使用大写，而从编码器的输出为小写。为了确保，你需要写一个测试，以检查输出从你配置的密码编码器与一个已知的密码和salt的组合，并检查它相匹配的数据库值之前，进一步尝试通过您的应用程序进行验证。使用诸如BCrypt标准将避免这些问题。</p>
</div>
<div class="paragraph">
<p>如果你想生成您的用户数据库编码密码，直接在Java中进行存储，那么你可以使用<code>PasswordEncoder</code>上的<code>encode</code>方法。</p>
</div>
</div>
</div>
</div>
</div>
<h1 id="test" class="sect0"><a class="anchor" href="#test"></a>Testing</h1>
<div class="paragraph">
<p>This section describes the testing support provided by Spring Security.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To use the Spring Security test support, you must include <code>spring-security-test-{spring-security-version}.jar</code> as a dependency of your project.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect1">
<h2 id="test-method"><a class="anchor" href="#test-method"></a>Testing Method Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section demonstrates how to  use Spring Security&#8217;s Test support to test method based security.
We first introduce a <code>MessageService</code> that requires the user to be authenticated in order to access it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class HelloMessageService implements MessageService {

	@PreAuthorize("authenticated")
	public String getMessage() {
		Authentication authentication = SecurityContextHolder.getContext()
															.getAuthentication();
		return "Hello " + authentication;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of <code>getMessage</code> is a String saying "Hello" to the current Spring Security <code>Authentication</code>.
An example of the output is displayed below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">Hello org.springframework.security.authentication.UsernamePasswordAuthenticationToken@ca25360: Principal: org.springframework.security.core.userdetails.User@36ebcb: Username: user; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_USER; Credentials: [PROTECTED]; Authenticated: true; Details: null; Granted Authorities: ROLE_USER</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="test-method-setup"><a class="anchor" href="#test-method-setup"></a>Security Test Setup</h3>
<div class="paragraph">
<p>Before we can use Spring Security Test support, we must perform some setup. An example can be seen below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class) <i class="conum" data-value="1"></i><b>(1)</b>
@ContextConfiguration <i class="conum" data-value="2"></i><b>(2)</b>
public class WithMockUserTests {</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a basic example of how to setup Spring Security Test. The highlights are:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@RunWith</code> instructs the spring-test module that it should create an ApplicationContext This is no different than using the existing Spring Test support. For additional information, refer to the <a href="http://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/htmlsingle/#integration-testing-annotations-standard">Spring Reference</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@ContextConfiguration</code> instructs the spring-test the configuration to use to create the <code>ApplicationContext</code>. Since no configuration is specified, the default configuration locations will be tried. This is no different than using the existing Spring Test support. For additional information, refer to the <a href="http://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/htmlsingle/#testcontext-ctx-management">Spring Reference</a></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security hooks into Spring Test support using the  <code>WithSecurityContextTestExecutionListener</code> which will ensure our tests are ran with the correct user.
It does this by populating the <code>SecurityContextHolder</code> prior to running our tests.
After the test is done, it will clear out the <code>SecurityContextHolder</code>.
If you only need Spring Security related support, you can replace <code>@ContextConfiguration</code> with <code>@SecurityExecutionListeners</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Remember we added the <code>@PreAuthorize</code> annotation to our <code>HelloMessageService</code> and so it requires an authenticated user to invoke it.
If we ran the following test, we would expect the following test will pass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test(expected = AuthenticationCredentialsNotFoundException.class)
public void getMessageUnauthenticated() {
	messageService.getMessage();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test-method-withmockuser"><a class="anchor" href="#test-method-withmockuser"></a>@WithMockUser</h3>
<div class="paragraph">
<p>The question is "How could we most easily run the test as a specific user?"
The answer is to use <code>@WithMockUser</code>.
The following test will be ran as a user with the username "user", the password "password", and the roles "ROLE_USER".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser
public void getMessageWithMockUser() {
String message = messageService.getMessage();
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specifically the following is true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The user with the username "user" does not have to exist since we are mocking the user</p>
</li>
<li>
<p>The <code>Authentication</code> that is populated in the <code>SecurityContext</code> is of type <code>UsernamePasswordAuthenticationToken</code></p>
</li>
<li>
<p>The principal on the <code>Authentication</code> is Spring Security&#8217;s <code>User</code> object</p>
</li>
<li>
<p>The <code>User</code> will have the username of "user", the password "password", and a single <code>GrantedAuthority</code> named "ROLE_USER" is used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Our example is nice because we are able to leverage a lot of defaults.
What if we wanted to run the test with a different username?
The following test would run with the username "customUser". Again, the user does not need to actually exist.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser("customUsername")
public void getMessageWithMockUserCustomUsername() {
	String message = messageService.getMessage();
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also easily customize the roles.
For example, this test will be invoked with the username "admin" and the roles "ROLE_USER" and "ROLE_ADMIN".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser(username="admin",roles={"USER","ADMIN"})
public void getMessageWithMockUserCustomUser() {
	String message = messageService.getMessage();
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we do not want the value to automatically be prefixed with ROLE_ we can leverage the authorities attribute.
For example, this test will be invoked with the username "admin" and the authorities "USER" and "ADMIN".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser(username = "admin", authorities = { "ADMIN", "USER" })
public void getMessageWithMockUserCustomAuthorities() {
	String message = messageService.getMessage();
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course it can be a bit tedious placing the annotation on every test method.
Instead, we can place the annotation at the class level and every test will use the specified user.
For example, the following would run every test with a user with the username "admin", the password "password", and the roles "ROLE_USER" and "ROLE_ADMIN".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@WithMockUser(username="admin",roles={"USER","ADMIN"})
public class WithMockUserTests {</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test-method-withanonymoususer"><a class="anchor" href="#test-method-withanonymoususer"></a>@WithAnonymousUser</h3>
<div class="paragraph">
<p>Using <code>@WithAnonymousUser</code> allows running as an anonymous user.
This is especially convenient when you wish to run most of your tests with a specific user, but want to run a few tests as an anonymous user.
For example, the following will run withMockUser1 and withMockUser2 using <a href="#test-method-withmockuser">@WithMockUser</a> and anonymous as an anonymous user.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class)
@WithMockUser
public class WithUserClassLevelAuthenticationTests {

	@Test
	public void withMockUser1() {
	}

	@Test
	public void withMockUser2() {
	}

	@Test
	@WithAnonymousUser
	public void anonymous() throws Exception {
		// override default to run as anonymous user
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test-method-withuserdetails"><a class="anchor" href="#test-method-withuserdetails"></a>@WithUserDetails</h3>
<div class="paragraph">
<p>While <code>@WithMockUser</code> is a very convenient way to get started, it may not work in all instances.
For example, it is common for applications to expect that the <code>Authentication</code> principal be of a specific type.
This is done so that the application can refer to the principal as the custom type and reduce coupling on Spring Security.</p>
</div>
<div class="paragraph">
<p>The custom principal is often times returned by a custom <code>UserDetailsService</code> that returns an object that implements both <code>UserDetails</code> and the custom type.
For situations like this, it is useful to create the test user using the custom <code>UserDetailsService</code>.
That is exactly what <code>@WithUserDetails</code> does.</p>
</div>
<div class="paragraph">
<p>Assuming we have a <code>UserDetailsService</code> exposed as a bean, the following test will be invoked with an <code>Authentication</code> of type <code>UsernamePasswordAuthenticationToken</code> and a principal that is returned from the <code>UserDetailsService</code> with the username of "user".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@WithUserDetails
public void getMessageWithUserDetails() {
	String message = messageService.getMessage();
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also customize the username used to lookup the user from our <code>UserDetailsService</code>.
For example, this test would be executed with a principal that is returned from the <code>UserDetailsService</code> with the username of "customUsername".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@WithUserDetails("customUsername")
public void getMessageWithUserDetailsCustomUsername() {
	String message = messageService.getMessage();
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also provide an explicit bean name to look up the <code>UserDetailsService</code>.
For example, this test would look up the username of "customUsername" using the <code>UserDetailsService</code> with the bean name "myUserDetailsService".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@WithUserDetails(value="customUsername", userDetailsServiceBeanName="myUserDetailsService")
public void getMessageWithUserDetailsServiceBeanName() {
	String message = messageService.getMessage();
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>@WithMockUser</code> we can also place our annotation at the class level so that every test uses the same user.
However unlike <code>@WithMockUser</code>, <code>@WithUserDetails</code> requires the user to exist.</p>
</div>
</div>
<div class="sect2">
<h3 id="test-method-withsecuritycontext"><a class="anchor" href="#test-method-withsecuritycontext"></a>@WithSecurityContext</h3>
<div class="paragraph">
<p>We have seen that <code>@WithMockUser</code> is an excellent choice if we are not using a custom <code>Authentication</code> principal.
Next we discovered that <code>@WithUserDetails</code> would allow us to use a custom <code>UserDetailsService</code> to create our <code>Authentication</code> principal but required the user to exist.
We will now see an option that allows the most flexibility.</p>
</div>
<div class="paragraph">
<p>We can create our own annotation that uses the <code>@WithSecurityContext</code> to create any <code>SecurityContext</code> we want.
For example, we might create an annotation named <code>@WithMockCustomUser</code> as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@WithSecurityContext(factory = WithMockCustomUserSecurityContextFactory.class)
public @interface WithMockCustomUser {

	String username() default "rob";

	String name() default "Rob Winch";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that <code>@WithMockCustomUser</code> is annotated with the <code>@WithSecurityContext</code> annotation.
This is what signals to Spring Security Test support that we intend to create a <code>SecurityContext</code> for the test.
The <code>@WithSecurityContext</code> annotation requires we specify a <code>SecurityContextFactory</code> that will create a new <code>SecurityContext</code> given our <code>@WithMockCustomUser</code> annotation.
You can find our <code>WithMockCustomUserSecurityContextFactory</code> implementation below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class WithMockCustomUserSecurityContextFactory
	implements WithSecurityContextFactory&lt;WithMockCustomUser&gt; {
	@Override
	public SecurityContext createSecurityContext(WithMockCustomUser customUser) {
		SecurityContext context = SecurityContextHolder.createEmptyContext();

		CustomUserDetails principal =
			new CustomUserDetails(customUser.name(), customUser.username());
		Authentication auth =
			new UsernamePasswordAuthenticationToken(principal, "password", principal.getAuthorities());
		context.setAuthentication(auth);
		return context;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can now annotate a test class or a test method with our new annotation and Spring Security&#8217;s <code>WithSecurityContextTestExecutionListener</code> will ensure that our <code>SecurityContext</code> is populated appropriately.</p>
</div>
<div class="paragraph">
<p>When creating your own <code>WithSecurityContextFactory</code> implementations, it is nice to know that they can be annotated with standard Spring annotations.
For example, the <code>WithUserDetailsSecurityContextFactory</code> uses the <code>@Autowired</code> annotation to acquire the <code>UserDetailsService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">final class WithUserDetailsSecurityContextFactory
	implements WithSecurityContextFactory&lt;WithUserDetails&gt; {

	private UserDetailsService userDetailsService;

	@Autowired
	public WithUserDetailsSecurityContextFactory(UserDetailsService userDetailsService) {
		this.userDetailsService = userDetailsService;
	}

	public SecurityContext createSecurityContext(WithUserDetails withUser) {
		String username = withUser.value();
		Assert.hasLength(username, "value() must be non empty String");
		UserDetails principal = userDetailsService.loadUserByUsername(username);
		Authentication authentication = new UsernamePasswordAuthenticationToken(principal, principal.getPassword(), principal.getAuthorities());
		SecurityContext context = SecurityContextHolder.createEmptyContext();
		context.setAuthentication(authentication);
		return context;
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test-method-meta-annotations"><a class="anchor" href="#test-method-meta-annotations"></a>Test Meta Annotations</h3>
<div class="paragraph">
<p>If you reuse the same user within your tests often, it is not ideal to have to repeatedly specify the attributes.
For example, if there are many tests related to an administrative user with the username "admin" and the roles <code>ROLE_USER</code> and <code>ROLE_ADMIN</code> you would have to write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithMockUser(username="admin",roles={"USER","ADMIN"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rather than repeating this everywhere, we can use a meta annotation.
For example, we could create a meta annotation named <code>WithMockAdmin</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@WithMockUser(value="rob",roles="ADMIN")
public @interface WithMockAdmin { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can use <code>@WithMockAdmin</code> in the same way as the more verbose <code>@WithMockUser</code>.</p>
</div>
<div class="paragraph">
<p>Meta annotations work with any of the testing annotations described above.
For example, this means we could create a meta annotation for <code>@WithUserDetails("admin")</code> as well.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="test-mockmvc"><a class="anchor" href="#test-mockmvc"></a>Spring MVC Test Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security provides comprehensive integration with <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/testing.html#spring-mvc-test-framework">Spring MVC Test</a></p>
</div>
<div class="sect2">
<h3 id="test-mockmvc-setup"><a class="anchor" href="#test-mockmvc-setup"></a>Setting Up MockMvc and Spring Security</h3>
<div class="paragraph">
<p>In order to use Spring Security with Spring MVC Test it is necessary to add the Spring Security <code>FilterChainProxy</code> as a <code>Filter</code>.
It is also necessary to add Spring Security&#8217;s <code>TestSecurityContextHolderPostProcessor</code> to support <a href="#truerunning-as-a-user-in-spring-mvc-test-with-annotations">Running as a User in Spring MVC Test with Annotations</a>.
This can be done using Spring Security&#8217;s <code>SecurityMockMvcConfigurers.springSecurity()</code>.
For example:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security&#8217;s testing support requires spring-test-4.1.3.RELEASE or greater.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@WebAppConfiguration
public class CsrfShowcaseTests {

	@Autowired
	private WebApplicationContext context;

	private MockMvc mvc;

	@Before
	public void setup() {
		mvc = MockMvcBuilders
				.webAppContextSetup(context)
				.apply(springSecurity()) <i class="conum" data-value="1"></i><b>(1)</b>
				.build();
	}

...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>SecurityMockMvcConfigurers.springSecurity()</code> will perform all of the initial setup we need to integrate Spring Security with Spring MVC Test</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="test-mockmvc-smmrpp"><a class="anchor" href="#test-mockmvc-smmrpp"></a>SecurityMockMvcRequestPostProcessors</h3>
<div class="paragraph">
<p>Spring MVC Test provides a convenient interface called a <code>RequestPostProcessor</code> that can be used to modify a request.
Spring Security provides a number of <code>RequestPostProcessor</code> implementations that make testing easier.
In order to use Spring Security&#8217;s <code>RequestPostProcessor</code> implementations ensure the following static import is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="test-mockmvc-csrf"><a class="anchor" href="#test-mockmvc-csrf"></a>Testing with CSRF Protection</h4>
<div class="paragraph">
<p>When testing any non safe HTTP methods and using Spring Security&#8217;s CSRF protection, you must be sure to include a valid CSRF Token in the request.
To specify a valid CSRF token as a request parameter using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(post("/").with(csrf()))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you like you can include CSRF token in the header instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(post("/").with(csrf().asHeader()))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also test providing an invalid CSRF token using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(post("/").with(csrf().useInvalidToken()))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-mockmvc-securitycontextholder"><a class="anchor" href="#test-mockmvc-securitycontextholder"></a>Running a Test as a User in Spring MVC Test</h4>
<div class="paragraph">
<p>It is often desirable to run tests as a specific user.
There are two simple ways of populating the user:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#test-mockmvc-securitycontextholder-rpp">Running as a User in Spring MVC Test with RequestPostProcessor</a></p>
</li>
<li>
<p><a href="#truerunning-as-a-user-in-spring-mvc-test-with-annotations">Running as a User in Spring MVC Test with Annotations</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="test-mockmvc-securitycontextholder-rpp"><a class="anchor" href="#test-mockmvc-securitycontextholder-rpp"></a>Running as a User in Spring MVC Test with RequestPostProcessor</h4>
<div class="paragraph">
<p>There are a number of options available to associate a user to the current <code>HttpServletRequest</code>.
For example, the following will run as a user (which does not need to exist) with the username "user", the password "password", and the role "ROLE_USER":</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The support works by associating the user to the <code>HttpServletRequest</code>.
To associate the request to the <code>SecurityContextHolder</code> you need to ensure that the <code>SecurityContextPersistenceFilter</code> is associated with the <code>MockMvc</code> instance.
A few ways to do this are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Invoking <a href="#test-mockmvc-setup">apply(springSecurity())</a></p>
</li>
<li>
<p>Adding Spring Security&#8217;s <code>FilterChainProxy</code> to <code>MockMvc</code></p>
</li>
<li>
<p>Manually adding <code>SecurityContextPersistenceFilter</code> to the <code>MockMvc</code> instance may make sense when using <code>MockMvcBuilders.standaloneSetup</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(get("/").with(user("user")))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can easily make customizations.
For example, the following will run as a user (which does not need to exist) with the username "admin", the password "pass", and the roles "ROLE_USER" and "ROLE_ADMIN".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(get("/admin").with(user("admin").password("pass").roles("USER","ADMIN")))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have a custom <code>UserDetails</code> that you would like to use, you can easily specify that as well.
For example, the following will use the specified <code>UserDetails</code> (which does not need to exist) to run with a <code>UsernamePasswordAuthenticationToken</code> that has a principal of the specified <code>UserDetails</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(get("/").with(user(userDetails)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can run as anonymous user using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(get("/").with(anonymous()))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is especially useful if you are running with a default user and wish to execute a few requests as an anonymous user.</p>
</div>
<div class="paragraph">
<p>If you want a custom <code>Authentication</code> (which does not need to exist) you can do so using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(get("/").with(authentication(authentication)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can even customize the <code>SecurityContext</code> using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(get("/").with(securityContext(securityContext)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also ensure to run as a specific user for every request by using <code>MockMvcBuilders</code>'s default request.
For example, the following will run as a user (which does not need to exist) with the username "admin", the password "password", and the role "ROLE_ADMIN":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc = MockMvcBuilders
		.webAppContextSetup(context)
		.defaultRequest(get("/").with(user("user").roles("ADMIN")))
		.apply(springSecurity())
		.build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you find you are using the same user in many of your tests, it is recommended to move the user to a method.
For example, you can specify the following in your own class named <code>CustomSecurityMockMvcRequestPostProcessors</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static RequestPostProcessor rob() {
	return user("rob").roles("ADMIN");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can perform a static import on <code>SecurityMockMvcRequestPostProcessors</code> and use that within your tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static sample.CustomSecurityMockMvcRequestPostProcessors.*;

...

mvc
	.perform(get("/").with(rob()))</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="truerunning-as-a-user-in-spring-mvc-test-with-annotations"><a class="anchor" href="#truerunning-as-a-user-in-spring-mvc-test-with-annotations"></a>Running as a User in Spring MVC Test with Annotations</h5>
<div class="paragraph">
<p>As an alternative to using a <code>RequestPostProcessor</code> to create your user, you can use annotations described in <a href="#test-method">Testing Method Security</a>.
For example, the following will run the test with the user with username "user", password "password", and role "ROLE_USER":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser
public void requestProtectedUrlWithUser() throws Exception {
mvc
		.perform(get("/"))
		...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, the following will run the test with the user with username "user", password "password", and role "ROLE_ADMIN":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser(roles="ADMIN")
public void requestProtectedUrlWithUser() throws Exception {
mvc
		.perform(get("/"))
		...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truetesting-http-basic-authentication"><a class="anchor" href="#truetesting-http-basic-authentication"></a>Testing HTTP Basic Authentication</h4>
<div class="paragraph">
<p>While it has always been possible to authenticate with HTTP Basic, it was a bit tedious to remember the header name, format, and encode the values.
Now this can be done using Spring Security&#8217;s <code>httpBasic</code> <code>RequestPostProcessor</code>.
For example, the snippet below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(get("/").with(httpBasic("user","password")))</code></pre>
</div>
</div>
<div class="paragraph">
<p>will attempt to use HTTP Basic to authenticate a user with the username "user" and the password "password" by ensuring the following header is populated on the HTTP Request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">Authorization: Basic dXNlcjpwYXNzd29yZA==</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truesecuritymockmvcrequestbuilders"><a class="anchor" href="#truesecuritymockmvcrequestbuilders"></a>SecurityMockMvcRequestBuilders</h3>
<div class="paragraph">
<p>Spring MVC Test also provides a <code>RequestBuilder</code> interface that can be used to create the <code>MockHttpServletRequest</code> used in your test.
Spring Security provides a few <code>RequestBuilder</code> implementations that can be used to make testing easier.
In order to use Spring Security&#8217;s <code>RequestBuilder</code> implementations ensure the following static import is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.*;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="truetesting-form-based-authentication"><a class="anchor" href="#truetesting-form-based-authentication"></a>Testing Form Based Authentication</h4>
<div class="paragraph">
<p>You can easily create a request to test a form based authentication using Spring Security&#8217;s testing support.
For example, the following will submit a POST to "/login" with the username "user", the password "password", and a valid CSRF token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(formLogin())</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is easy to customize the request.
For example, the following will submit a POST to "/auth" with the username "admin", the password "pass", and a valid CSRF token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(formLogin("/auth").user("admin").password("pass"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also customize the parameters names that the username and password are included on.
For example, this is the above request modified to include the username on the HTTP parameter "u" and the password on the HTTP parameter "p".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(formLogin("/auth").user("u","admin").password("p","pass"))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-logout"><a class="anchor" href="#test-logout"></a>Testing Logout</h4>
<div class="paragraph">
<p>While fairly trivial using standard Spring MVC Test, you can use Spring Security&#8217;s testing support to make testing log out easier.
For example, the following will submit a POST to "/logout" with a valid CSRF token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(logout())</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also customize the URL to post to.
For example, the snippet below will submit a POST to "/signout" with a valid CSRF token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(logout("/signout"))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truesecuritymockmvcresultmatchers"><a class="anchor" href="#truesecuritymockmvcresultmatchers"></a>SecurityMockMvcResultMatchers</h3>
<div class="paragraph">
<p>At times it is desirable to make various security related assertions about a request.
To accommodate this need, Spring Security Test support implements Spring MVC Test&#8217;s <code>ResultMatcher</code> interface.
In order to use Spring Security&#8217;s <code>ResultMatcher</code> implementations ensure the following static import is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.*;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="trueunauthenticated-assertion"><a class="anchor" href="#trueunauthenticated-assertion"></a>Unauthenticated Assertion</h4>
<div class="paragraph">
<p>At times it may be valuable to assert that there is no authenticated user associated with the result of a <code>MockMvc</code> invocation.
For example, you might want to test submitting an invalid username and password and verify that no user is authenticated.
You can easily do this with Spring Security&#8217;s testing support using something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(formLogin().password("invalid"))
	.andExpect(unauthenticated());</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueauthenticated-assertion"><a class="anchor" href="#trueauthenticated-assertion"></a>Authenticated Assertion</h4>
<div class="paragraph">
<p>It is often times that we must assert that an authenticated user exists.
For example, we may want to verify that we authenticated successfully.
We could verify that a form based login was successful with the following snippet of code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(formLogin())
	.andExpect(authenticated());</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we wanted to assert the roles of the user, we could refine our previous code as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(formLogin().user("admin"))
	.andExpect(authenticated().withRoles("USER","ADMIN"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, we could verify the username:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(formLogin().user("admin"))
	.andExpect(authenticated().withUsername("admin"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also combine the assertions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mvc
	.perform(formLogin().user("admin").roles("USER","ADMIN"))
	.andExpect(authenticated().withUsername("admin"));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="web-app-security" class="sect0"><a class="anchor" href="#web-app-security"></a>Web应用程序的安全性</h1>
<div class="paragraph">
<p>大多数Spring Security的用户将使用在这使得HTTP和Servlet API的用户应用程序的框架。在这一部分中,我们将看看Spring Security提供身份验证和访问控制特性的应用程序的web层。我们会看看该命名空间的门面后面,看看哪些类和接口实际上是组装提供web层安全。在某些情况下需要使用传统的bean配置提供完全控制配置,所以我们也将看到怎样的情况下直接配置这些类的命名空间。</p>
</div>
<div class="sect1">
<h2 id="security-filter-chain"><a class="anchor" href="#security-filter-chain"></a>The Security Filter Chain</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security的web基础设施是完全基于标准的servlet过滤器。它不使用servlet或任何其他基于servlet框架(比如Spring MVC)在内部,所以它与任何特定的web技术没有紧密的联系。它涉及到<code>HttpServletRequest</code>和<code>HttpServletResponse</code>并不在乎请求是否来自一个浏览器,一个web服务客户端,一个<code>HttpInvoker</code>或一个AJAX应用程序。</p>
</div>
<div class="paragraph">
<p>Spring Security维护过滤器链内部,每个过滤器都有一个特定的责任和过滤器中添加或删除的配置取决于哪些服务是必需的。过滤器的顺序很重要,因为它们之间有依赖关系。如果你一直使用<a href="#ns-config">命名空间配置</a>,那么过滤器会为你自动配置和你不需要明确定义任何Spring bean但可能有时你想要完全控制安全过滤器链,因为您正在使用的功能中不支持在命名空间中,或你使用你自己的自定义版本的类。</p>
</div>
<div class="sect2">
<h3 id="delegating-filter-proxy"><a class="anchor" href="#delegating-filter-proxy"></a>DelegatingFilterProxy</h3>
<div class="paragraph">
<p>当使用Servlet过滤器时，你显然需要声明他们的<code>web.xml</code>，否则将被servlet容器忽略。在Spring Security，过滤器类也都在Spring bean中定义应用上下文，从而能够利用Spring的丰富的依赖注入的设施和生命周期接口的优势。Spring的<code>DelegatingFilterProxy</code>提供<code>web.xml</code>和应用程序上下文之间的链接</p>
</div>
<div class="paragraph">
<p>当使用<code>DelegatingFilterProxy</code>，你会看到这样的事情在<code>web.xml</code>文件中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;myFilter&lt;/filter-name&gt;
&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
&lt;filter-name&gt;myFilter&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，该过滤器实际上是一个<code>DelegatingFilterProxy</code>，而不是类，会实现过滤器的逻辑。什么<code>DelegatingFilterProxy</code>所做的是通过向其从Spring应用程序上下文中的bean委托<code>Filter</code>的方法。这使得bean来从Spring Web应用程序上下文的生命周期支持和配置灵活性中受益。bean必须实现<code>javax.servlet.Filter</code>并且必须具有相同的名称，在<code>filter-name</code>元素。阅读<code>DelegatingFilterProxy</code>的Javadoc的更多信息</p>
</div>
</div>
<div class="sect2">
<h3 id="filter-chain-proxy"><a class="anchor" href="#filter-chain-proxy"></a>FilterChainProxy</h3>
<div class="paragraph">
<p>Spring Security的网络基础设施，只能通过委托给<code>FilterChainProxy</code>的一个实例使用。安全过滤器不应该由自己来使用。理论上你可以声明每个弹簧安全过滤器bean，你需要在你的应用程序的上下文文件并添加相应的<code>DelegatingFilterProxy</code>到<code>web.xml</code>每个过滤器中，确保他们正确排序，但是这是很麻烦的并且如果你有很多的过滤器会很快弄乱了<code>web.xml</code>文件。<code>FilterChainProxy</code>让我们将一个条目添加到<code>web.xml</code>和完全处理应用程序上下文文件来管理我们的网络安全bean。它是使用<code>DelegatingFilterProxy</code>连接的，就像在上面的例子，随着<code>filter-name</code>设为"filterChainProxy"bean的名称。然后过滤器链中声明应用程序上下文相同的bean的名称。这里有一个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="filterChainProxy" class="org.springframework.security.web.FilterChainProxy"&gt;
&lt;constructor-arg&gt;
	&lt;list&gt;
	&lt;sec:filter-chain pattern="/restful/**" filters="
		securityContextPersistenceFilterWithASCFalse,
		basicAuthenticationFilter,
		exceptionTranslationFilter,
		filterSecurityInterceptor" /&gt;
	&lt;sec:filter-chain pattern="/**" filters="
		securityContextPersistenceFilterWithASCTrue,
		formLoginFilter,
		exceptionTranslationFilter,
		filterSecurityInterceptor" /&gt;
	&lt;/list&gt;
&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名空间元素<code>filter-chain</code>是用来方便设置应用程序中所需的安全过滤器链。 <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</sup>它映射一个特定的URL模式的从<code>filters</code>元素指定的bean的名字建立了过滤器列表，并结合<code>SecurityFilterChain</code>类型的bean。该<code>pattern</code>属性需要一个Ant路径和最具体的URI应该首先出现。 <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote.">3</a>]</sup> 在运行时，<code>FilterChainProxy</code>将定位相匹配的当前Web请求，并由<code>filters</code>属性指定的过滤器bean列表将被应用到该请求的第一个URI模式。过滤器会按照它们定义的顺序调用，所以你必须在这是适用于一个特定的URL过滤器链的完全控制。</p>
</div>
<div class="paragraph">
<p>您可能已经注意到，我们已宣布两个<code>SecurityContextPersistenceFilter</code>在过滤器链（<code>ASC</code>的简称<code>allowSessionCreation</code>，<code>SecurityContextPersistenceFilter</code>的属性）。因为web服务从来不会在请求<code>jsessionid</code>，创造<code>HttpSession</code>表示这样的用户代理是一种浪费。如果你这需要这最大的扩展能力高容量的应用程序，我们建议您使用上面的方法。对于较小的应用程序，使用<code>SecurityContextPersistenceFilter</code>（其默认<code>allowSessionCreation</code>为<code>true</code>）就足够了。</p>
</div>
<div class="paragraph">
<p>需要注意的是<code>FilterChainProxy</code>不会调用它配置了过滤器标准过滤器生命周期方法。我们建议你使用Spring的应用程序上下文的生命周期接口作为替代，就像你对任何其他的Spring bean一样。</p>
</div>
<div class="paragraph">
<p>当我们看到如何使用<a href="#ns-web-xml">命名空间配置</a>建立网络安全,我们使用了<code>DelegatingFilterProxy</code>和"springSecurityFilterChain"这个名字。您现在应该能够看到，这是由<code>FilterChainProxy</code>的名称创建的命名空间。</p>
</div>
<div class="sect3">
<h4 id="true--16"><a class="anchor" href="#true--16"></a>绕过过滤器链</h4>
<div class="paragraph">
<p>你可以使用属性<code>filters = "none"</code>替代供应一个过滤器bean列表。这将完全忽略安全筛选器链中的请求模式。请注意，任何匹配此路径将没有任何身份验证或授权服务应用，将可自由访问。如果你想在一个请求中使用的<code>SecurityContext</code>内容的内容，那么它必须通过保安过滤器链。否则，<code>SecurityContextHolder</code>不会被填充且内容也将空。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truefilter-ordering"><a class="anchor" href="#truefilter-ordering"></a>Filter Ordering</h3>
<div class="paragraph">
<p>过滤器链中定义的顺序是非常重要的。不论你使用的是哪一种过滤器，顺序应该如下:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ChannelProcessingFilter</code>,因为它可能需要重定向到其他协议。</p>
</li>
<li>
<p><code>SecurityContextPersistenceFilter</code>,所以<code>SecurityContext</code>可在<code>SecurityContextHolder</code>在web请求的开始设立，并且当web请求结束时<code>SecurityContext</code>任何改变可以被复制到<code>HttpSession</code>（准备下一个使用Web请求）</p>
</li>
<li>
<p><code>ConcurrentSessionFilter</code>,因为它使用了<code>SecurityContextHolder</code>功能和需要更新<code>SessionRegistry</code>以反映反映主要正在处理的请求。</p>
</li>
<li>
<p>认证处理机制 - <code>UsernamePasswordAuthenticationFilter</code>，<code>CasAuthenticationFilter</code>，<code>BasicAuthenticationFilter</code>等 - 使得<code>SecurityContextHolder</code>可以被修饰以包含有效的<code>Authentication</code>请求令牌</p>
</li>
<li>
<p><code>SecurityContextHolderAwareRequestFilter</code>，如果你使用它来安装一个Spring Security意识<code>HttpServletRequestWrapper</code>到你的servlet容器</p>
</li>
<li>
<p><code>JaasApiIntegrationFilter</code>，如果<code>JaasAuthenticationToken</code>是在<code>SecurityContextHolder</code>这将处理<code>F`RememberMeAuthenticationFilter</code>, so that if no earlier authentication processing mechanism updated the <code>SecurityContextHolder</code>, and the request presents a cookie that enables remember-me services to take place, a suitable remembered <code>Authentication</code> object will be put thereilterChain`作为<code>Subject</code>在<code>JaasAuthenticationToken</code></p>
</li>
<li>
<p><code>RememberMeAuthenticationFilter</code>,所以如果早期的认证处理机制没有更新<code>SecurityContextHolder</code>并且请求给出一个Cookie使remember-me服务发生，一个合适的记忆<code>Authentication</code>对象将被放在那里</p>
</li>
<li>
<p><code>AnonymousAuthenticationFilter</code>,这样如果之前的验证执行机制没有更新<code>SecurityContextHolder</code>，一个匿名<code>Authentication</code>对象将被放在那里</p>
</li>
<li>
<p><code>ExceptionTranslationFilter</code>,捕获任何Spring安全异常,以便响应可以返回一个HTTP错误或适当的<code>AuthenticationEntryPoint</code>可以启动</p>
</li>
<li>
<p><code>FilterSecurityInterceptor</code>,保护网络的URI，当访问被拒绝引发异常</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="request-matching"><a class="anchor" href="#request-matching"></a>Request Matching and HttpFirewall</h3>
<div class="paragraph">
<p>Spring Security有几个方面，你已经定义模式对传入的请求，以决定该请求应如何处理测试。这发生在<code>FilterChainProxy</code>决定的请求应通过传递该过滤器链，也当<code>FilterSecurityInterceptor</code>决定哪些安全约束适用于请求。要了解什么机制和针对你定义的模式进行测试时使用什么URL值是非常重要的。</p>
</div>
<div class="paragraph">
<p>Servlet规范定义了<code>HttpServletRequest</code>其中有几个属性是通过getter方法访问，以及我们可能要匹配。这些都是<code>contextPath</code>，<code>servletPath</code>，<code>pathInfo</code>和<code>queryString</code>。 Spring Security唯一感兴趣的仅仅是在确保应用程序中的路径，所以<code>contextPath</code>被忽略。不幸的是，servlet规范并没有定义到底什么是<code>servletPath</code>和<code>pathInfo</code>的值将包含特定请求URI。例如，一个URL的每个路径段可包含参数, 定义在 <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a> <sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnote_4" title="View footnote.">4</a>]</sup>. 该规范并没有明确说明是否这些都应该被包含在`servletPath</code>和<code>pathInfo</code>的价值观和行为的不同servlet容器之间变化。有一种危险，当一个应用程序被部署在一个容器中，而不是从这些值中的路径参数，攻击者可以将它们添加到请求的URL,以意外导致模式匹配成功或失败。 <sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnote_5" title="View footnote.">5</a>]</sup>. 在传入的URL的其他变化也可能。它可能包含路径遍历序列（如<code>/../）或多个斜杠（</code>//），这也可能导致匹配失败。一些容器标准化这些之前执行servlet映射,但其他人没有。为了防止类似这些问题，<code>FilterChainProxy</code>采用了<code>HttpFirewall</code>战略，检查和包装的要求。未规范化请求默认自动拒绝和路径参数和复制斜线匹配的目的被删除。 <sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnote_6" title="View footnote.">6</a>]</sup>. 因此，至关重要的一个<code>FilterChainProxy</code>用于管理安全过滤器链。需要注意的是<code>servletPath</code>和<code>pathInfo</code>值由容器解码，所以你的应用程序不应该有任何有效的路径包含分号，这些部分将被删除匹配的目的。</p>
</div>
<div class="paragraph">
<p>正如上面提到的，默认的策略是使用Ant风格的路径进行匹配，这可能是大多数用户的最佳选择。该策略在使用Spring的<code>AntPathMatcher</code>执行对级联<code>servletPath</code>和<code>pathInfo</code>的格局不区分大小写的匹配类<code>AntPathRequestMatcher</code>实现，忽视了<code>queryString</code>。</p>
</div>
<div class="paragraph">
<p>如果由于某种原因，你需要一个更强大的匹配策略，您可以使用正则表达式。然后<code>RegexRequestMatcher</code>战略的实现。看到这个类的Javadoc获取更多信息。</p>
</div>
<div class="paragraph">
<p>在实践中我们建议你使用方法安全服务层,控制您的应用程序访问,并不完全依赖于在Web应用程序级别定义的安全约束的使用。URL改变,很难考虑所有可能的应用程序的URL可能支持和如何处理请求。你应该尝试限制自己使用一些简单的容易理解的路径。总是试图用"deny-by-default"的方法,全方位通配符( /<strong> or </strong>) 定义和拒绝访问。</p>
</div>
<div class="paragraph">
<p>安全在服务层定义更健壮且难以绕过,所以你应该利用Spring Security的方法安全选项。</p>
</div>
</div>
<div class="sect2">
<h3 id="true--17"><a class="anchor" href="#true--17"></a>与其它过滤器-基于框架使用</h3>
<div class="paragraph">
<p>如果您使用的过滤器也基于其他一些框架，那么你需要确保Spring Security过滤器是第一位的。这使得<code>SecurityContextHolder</code>到时由其他过滤器被填充以供使用。例子是使用SiteMesh的来装饰您的网页或类似Wicket的Web框架，它使用一个过滤器来处理其请求。</p>
</div>
</div>
<div class="sect2">
<h3 id="filter-chains-with-ns"><a class="anchor" href="#filter-chains-with-ns"></a>高级的命名空间配置</h3>
<div class="paragraph">
<p>正如我们在命名空间章节前面所看到的，它可以使用多个<code>http</code>元素来定义不同的URL模式来进行不同的安全配置。每个元素创建内部<code>FilterChainProxy</code>内的过滤器链和应该映射的URL模式。这些元素将声明它们的添加顺序，所以最具体的模式必须再次先声明。这里的另一个例子，与上面有一个类似的情况，在应用程序支持一个无国籍的RESTful API和一个正常的网络应用，用户可以登录使用的一种形式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- Stateless RESTful service using Basic authentication --&gt;
&lt;http pattern="/restful/**" create-session="stateless"&gt;
&lt;intercept-url pattern='/**' access="hasRole('REMOTE')" /&gt;
&lt;http-basic /&gt;
&lt;/http&gt;

&lt;!-- Empty filter chain for the login page --&gt;
&lt;http pattern="/login.htm*" security="none"/&gt;

&lt;!-- Additional filter chain for normal users, matching all other requests --&gt;
&lt;http&gt;
&lt;intercept-url pattern='/**' access="hasRole('USER')" /&gt;
&lt;form-login login-page='/login.htm' default-target-url="/home.htm"/&gt;
&lt;logout /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="core-web-filters"><a class="anchor" href="#core-web-filters"></a>核心安全过滤器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>总是会有一些关键的过滤器在web应用程序中使用Spring Security,所以我们来看看这些和他们的支持类和接口。我们不会覆盖所有功能，所以如果你想获得完整的信息一定要看看它们的Javadoc。</p>
</div>
<div class="sect2">
<h3 id="filter-security-interceptor"><a class="anchor" href="#filter-security-interceptor"></a>FilterSecurityInterceptor</h3>
<div class="paragraph">
<p>我们已经看到了 <code>FilterSecurityInterceptor</code>简要讨论<a href="#tech-intro-access-control">访问控制</a> ，我们已经与其中<code>&lt;intercept-url&gt;</code>元素相结合，在内部配置的命名空间中使用它。现在，我们将看到如何明确将其<code>FilterChainProxy</code>其配置为使用，其配套过滤器<code>ExceptionTranslationFilter</code>一起。典型的配置示例如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="filterSecurityInterceptor"
	class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
&lt;property name="securityMetadataSource"&gt;
	&lt;security:filter-security-metadata-source&gt;
	&lt;security:intercept-url pattern="/secure/super/**" access="ROLE_WE_DONT_HAVE"/&gt;
	&lt;security:intercept-url pattern="/secure/**" access="ROLE_SUPERVISOR,ROLE_TELLER"/&gt;
	&lt;/security:filter-security-metadata-source&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>FilterSecurityInterceptor</code>负责处理HTTP资源的安全性。它需要一个<code>AuthenticationManager</code>和<code>AccessDecisionManager</code>参考。它也有提供适用于不同的HTTP URL请求的配置属性。回头参考技术介绍中<a href="#tech-intro-config-attributes">这些原始的讨论</a>。</p>
</div>
<div class="paragraph">
<p>在<code>FilterSecurityInterceptor</code>配置属性可以两种方式进行配置。上面显示的第一个，使用<code>&lt;filter-security-metadata-source&gt;</code>命名空间元素。这类似于<code>&lt;http&gt;</code>元素的命名空间，但 <code>&lt;intercept-url&gt;</code>的子元素只使用<code>pattern</code>和 <code>access</code>的属性。使用逗号分隔不同的配置属性,适用于每个HTTP URL。第二个选择是编写自己的‘SecurityMetadataSource’,但这超出了本文的范围。不管采用哪种方式，在<code>SecurityMetadataSource</code>负责返回一个<code>List&lt;ConfigAttribute&gt;</code>包含所有用一个安全的HTTP URL相关联的配置属性。</p>
</div>
<div class="paragraph">
<p>应当指出的是，<code>FilterSecurityInterceptor.setSecurityMetadataSource（）</code>方法实际上是<code>FilterInvocationSecurityMetadataSource</code>的一个实例。这是一个标记接口，它的子类是<code>SecurityMetadataSource</code>。它只是表示<code>SecurityMetadataSource</code>明白<code>FilterInvocation</code>。在简单的利益，我们将继续参考<code>FilterInvocationSecurityMetadataSource</code>作为<code>SecurityMetadataSource</code>，因为区别是无关紧要大多数用户。为了简单起见，我们将继续参考<code>FilterInvocationSecurityMetadataSource</code>作为<code>SecurityMetadataSource</code>，因为对于大多数用户区别是无关紧要。</p>
</div>
<div class="paragraph">
<p>通过命名空间的语法创建的<code>SecurityMetadataSource</code>获得通过匹配在配置的<code>pattern</code>属性请求的URL特定<code>FilterInvocation</code>配置属性。这表现在，它确实为命名空间配置相同的方式。默认的是处理所有表达式作为Apache Ant的路径和正则表达式还支持更复杂的情况。<code>request-matcher</code>属性用于指定模式的类型被使用。它是不可能的相同的定义内混合表达式语法。作为一个例子，使用正则表达式，而不是Ant paths的先前的配置将按如下表示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="filterInvocationInterceptor"
	class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
&lt;property name="runAsManager" ref="runAsManager"/&gt;
&lt;property name="securityMetadataSource"&gt;
	&lt;security:filter-security-metadata-source request-matcher="regex"&gt;
	&lt;security:intercept-url pattern="\A/secure/super/.*\Z" access="ROLE_WE_DONT_HAVE"/&gt;
	&lt;security:intercept-url pattern="\A/secure/.*\" access="ROLE_SUPERVISOR,ROLE_TELLER"/&gt;
	&lt;/security:filter-security-metadata-source&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>模式总是按照它们被定义的顺序进行。因此，重要的是，更具体的模式被定义在列表中比不太具体的模式更高。这是反映在我们的例子上面，在更具体的<code>/secure/super/</code>模式似乎比<code>/secure/</code>模式更高。如果它们被逆转，<code>/secure/</code>模式会一直匹配，并且<code>/secure/super/</code>模式将永远不会被评估。</p>
</div>
</div>
<div class="sect2">
<h3 id="exception-translation-filter"><a class="anchor" href="#exception-translation-filter"></a>ExceptionTranslationFilter</h3>
<div class="paragraph">
<p>该<code>ExceptionTranslationFilter</code>在<code>FilterSecurityInterceptor</code>安全过滤器堆栈的上面。它没有做任何实际的安全执法本身，而是处理由安全拦截器抛出的异常，并提供合适的HTTP响应。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exceptionTranslationFilter"
class="org.springframework.security.web.access.ExceptionTranslationFilter"&gt;
&lt;property name="authenticationEntryPoint" ref="authenticationEntryPoint"/&gt;
&lt;property name="accessDeniedHandler" ref="accessDeniedHandler"/&gt;
&lt;/bean&gt;

&lt;bean id="authenticationEntryPoint"
class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint"&gt;
&lt;property name="loginFormUrl" value="/login.jsp"/&gt;
&lt;/bean&gt;

&lt;bean id="accessDeniedHandler"
	class="org.springframework.security.web.access.AccessDeniedHandlerImpl"&gt;
&lt;property name="errorPage" value="/accessDenied.htm"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="auth-entry-point"><a class="anchor" href="#auth-entry-point"></a>AuthenticationEntryPoint</h4>
<div class="paragraph">
<p>如果用户请求一个安全HTTP资源这个<code>AuthenticationEntryPoint</code>将被调用，但他们不被认证。适当的<code>AuthenticationException</code>或<code>AccessDeniedException</code>将被安全拦截器进一步拆毁了调用堆栈，触发入口点的<code>commence</code>方法。这确实呈现给用户的适当的反应，使认证可以开始工作。我们这里使用的是<code>LoginUrlAuthenticationEntryPoint</code>，这将请求重定向到一个不同的URL（一般是一个登录页面）。使用将取决于你想要的认证机制的实际实现在应用程序中使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="access-denied-handler"><a class="anchor" href="#access-denied-handler"></a>AccessDeniedHandler</h4>
<div class="paragraph">
<p>如果用户已经通过身份验证，他们试图访问受保护的资源会发生什么?在正常使用情况下，这不应该发生，因为应用程序的工作流程应该仅限于用户访问的操作。例如，HTML链接到一个管理页面可能隐藏唉一个没有管理员角色的用户中。你不能依赖隐藏链接的安全,总是有一个可能性,用户只会直接输入URL,以绕过限制。或者，他们可能会修改一个RESTful URL来改变一些参数值。您的应用程序必须对这些方案进行保护，或者它绝对会是不安全的。您通常会使用简单的网络层安全性约束适用于基本的网址，并使用更具体的方法，基于安全上的服务层接口真正明确什么是允许的。</p>
</div>
<div class="paragraph">
<p>如果一个<code>AccessDeniedException</code>被抛出并且用户已经被认证，那么这意味着一个操作已经尝试了它们不具有足够的权限。在这种情况下，<code>ExceptionTranslationFilter</code>将调用第二策略，<code>AccessDeniedHandler</code>。默认情况下,<code>AccessDeniedHandlerImpl</code>被使用，这只是发送一个403（禁止）响应于客户端。此外，还可以配置明确的实例（如在上面的例子），并设置一个错误页面的URL，它会请求转发  <sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnote_7" title="View footnote.">7</a>]</sup>. 这可以是一个简单的“拒绝访问”页上，如一个JSP，或者它可以是更复杂的处理程序，如一个MVC的控制器。当然，你可以自己实现接口，并使用自己的实现。</p>
</div>
<div class="paragraph">
<p>它也可以提供当你自定义你的应用程序时使用命名空间来配置<code>AccessDeniedHandler</code>。详见 <a href="#nsa-access-denied-handler">命名空间附录</a> 了解更多详情。</p>
</div>
</div>
<div class="sect3">
<h4 id="request-caching"><a class="anchor" href="#request-caching"></a>SavedRequest s and the RequestCache Interface</h4>
<div class="paragraph">
<p><code>ExceptionTranslationFilter</code>另一个责任是调用<code>AuthenticationEntryPoint</code>之前保存当前的请求。这允许使用已经验证后要恢复的请求(看到之前的概述 <a href="#tech-intro-web-authentication">web 认证</a>).一个典型示例是在用户登录表单,然后重定向到默认的原始URL <code>SavedRequestAwareAuthenticationSuccessHandler</code>(见 <a href="#form-login-flow-handling">下方</a>).</p>
</div>
<div class="paragraph">
<p>该<code>RequestCache</code>封装用于存储和检索<code>HttpServletRequest</code>实例所需的功能。默认<code>HttpSessionRequestCache</code>被使用，其中该请求存储在<code>HttpSession</code>。该<code>RequestCacheFilter</code>具有实际恢复从当用户被重定向到原始URL缓存中保存的请求工作。</p>
</div>
<div class="paragraph">
<p>在正常情况下，你不需要修改任何此功能，但保存的请求处理是一个“尽力而为”的做法，有可能是其默认的配置是无法处理的情况。使用这些接口，使得它完全可插入从Spring Security 3.0起。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security-context-persistence-filter"><a class="anchor" href="#security-context-persistence-filter"></a>SecurityContextPersistenceFilter</h3>
<div class="paragraph">
<p>我们涵盖所有重要的过滤器在<a href="#tech-intro-sec-context-persistence">技术概述</a>这一章，所以你可能想在这一点上重新阅读该部分。让我们先来看看，你会如何配置它与一个<code>FilterChainProxy</code>使用。一个基本的配置只需要bean本身。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="securityContextPersistenceFilter"
class="org.springframework.security.web.context.SecurityContextPersistenceFilter"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们之前看到的,这个过滤器有两个主要的任务。它负责存储` securitycontext <code>内容之间的HTTP请求和当请求完成结算</code> securitycontextholder`。清除<code>ThreadLocal</code>其中存储的上下文是必不可少的，因为它可能会以其他方式可能是一个线程被替换成servlet容器的线程池，仍连接一个特定的用户的安全上下文。这个线程可能在稍后的阶段中使用，与错误的凭证执行操作。</p>
</div>
<div class="sect3">
<h4 id="security-context-repository"><a class="anchor" href="#security-context-repository"></a>SecurityContextRepository</h4>
<div class="paragraph">
<p>从Spring Security 3.0起,加载和存储安全上下文的工作现在是委托给一个单独的策略接口:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface SecurityContextRepository {

SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder);

void saveContext(SecurityContext context, HttpServletRequest request,
		HttpServletResponse response);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该<code>HttpRequestResponseHolder</code>只是一个容器传入的请求和响应对象，允许实现替换这些包装类。返回的内容将被传递给过滤器链。</p>
</div>
<div class="paragraph">
<p>默认实现<code>HttpSessionSecurityContextRepository</code>,存储安全上下文作为HttpSession的属性  <sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnote_8" title="View footnote.">8</a>]</sup>. 对于此实现最重要的配置参数是<code>allowSessionCreation</code>属性，它默认为<code>true</code>,从而使类来创建一个会话如果它需要一个存储身份验证的用户的安全上下文(它不会创建一个除非认证发生和安全上下文的内容改变了)。如果你不希望创建一个会话,则可以将此属性设置为<code>false</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="securityContextPersistenceFilter"
	class="org.springframework.security.web.context.SecurityContextPersistenceFilter"&gt;
&lt;property name='securityContextRepository'&gt;
	&lt;bean class='org.springframework.security.web.context.HttpSessionSecurityContextRepository'&gt;
	&lt;property name='allowSessionCreation' value='false' /&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者你可以提供 <code>NullSecurityContextRepository</code>的一个实例, 一个 <a href="http://en.wikipedia.org/wiki/Null_Object_pattern">null object</a> 的实现, 这将防止安全上下文被存储，即使已经在会话期间创建一个该实例请求。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="form-login-filter"><a class="anchor" href="#form-login-filter"></a>UsernamePasswordAuthenticationFilter</h3>
<div class="paragraph">
<p>我们现在看到的三个主要的过滤器总是存在在一个Spring Security web配置。这些也都是这是由命名空间<code>&lt;http&gt;</code>元素自动创建，并且不能被替代被取代的三种。现在唯一缺少的是一个实际的认证机制，而这将允许用户进行身份验证。该过滤器是最常用的身份验证过滤器，也是最常用的一种认证过滤器  <sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnote_9" title="View footnote.">9</a>]</sup>. 另外，它还提供了<code>&lt;form-login&gt;</code>元素的命名空间的实现。有三个阶段需要进行配置。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>配置一个<code>LoginUrlAuthenticationEntryPoint</code>登录页面的URL,就像我们上面,并设置<code>ExceptionTranslationFilter</code>。</p>
</li>
<li>
<p>实现登录页面(使用JSP或MVC控制器)。</p>
</li>
<li>
<p>配置一个<code>UsernamePasswordAuthenticationFilter</code>应用程序上下文的实例</p>
</li>
<li>
<p>将过滤器bean添加到您的过滤器链代理（确保你要注意顺序）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>登录表单包含<code>username</code>和<code>password</code>输入字段，并发布到由过滤器（默认情况下这是<code>/login</code>）监测的URL。基本的过滤器配置看起来是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="authenticationFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="form-login-flow-handling"><a class="anchor" href="#form-login-flow-handling"></a>认证成功和失败的应用程序流程</h4>
<div class="paragraph">
<p>该过滤器调用配置<code>AuthenticationManager</code>处理每个认证请求。继成功认证或认证失败的目的地是由<code>AuthenticationSuccessHandler</code>和<code>AuthenticationFailureHandler</code>策略接口分别控制。过滤器属性允许你设置这些，所以你可以完全自定义行为  <sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnote_10" title="View footnote.">10</a>]</sup>. 一些标准的实现，如<code>SimpleUrlAuthenticationSuccessHandler</code>，<code>SavedRequestAwareAuthenticationSuccessHandler</code>，<code>SimpleUrlAuthenticationFailureHandler</code>和<code>ExceptionMappingAuthenticationFailureHandler</code>提供。看一看这些类的Javadoc和<code>AbstractAuthenticationProcessingFilter</code>来获取它们是如何工作的概述和所支持的特性。</p>
</div>
<div class="paragraph">
<p>如果认证成功，将所得<code>Authentication</code>对象将被放置到<code>SecurityContextHolder</code>。配置的<code>AuthenticationSuccessHandler</code>将被重定向或用户转发给适当的目的地。默认情况下使用<code>SavedRequestAwareAuthenticationSuccessHandler</code>,这意味着用户将被重定向到他们要求的原始目的地之前，他们被要求登录。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ExceptionTranslationFilter</code>缓存原始请求用户。当用户进行身份验证时,这种缓存的请求处理程序利用请求获取原始URL和重定向到它。然后原始请求被重建和使用作为替代。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果身份验证失败,则将调用<code>AuthenticationFailureHandler</code>配置。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servletapi"><a class="anchor" href="#servletapi"></a>Servlet API的集成</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节描述如何与Servlet API集成Spring Security。 <a href="https://github.com/spring-projects/spring-security/tree/master/samples/xml/servletapi">servletapi-xml</a>示例应用程序演示了使用这些方法。</p>
</div>
<div class="sect2">
<h3 id="servletapi-25"><a class="anchor" href="#servletapi-25"></a>Servlet 2.5+ 集成</h3>
<div class="sect3">
<h4 id="servletapi-remote-user"><a class="anchor" href="#servletapi-remote-user"></a>HttpServletRequest.getRemoteUser()</h4>
<div class="paragraph">
<p><a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()">HttpServletRequest.getRemoteUser()</a> 将返回<code>SecurityContextHolder.getContext().getAuthentication().getName()</code>的结果。 这通常是当前的用户名。这可能是有用的,如果你想在应用程序中显示当前用户名。此外,检查如果这是空可以用来表示如果一个用户已经通过身份验证或者是匿名的。知道用户是否通过身份验证可以用于确定特定UI元素应该显示（即注销链接应该只显示如果用户身份验证）。</p>
</div>
</div>
<div class="sect3">
<h4 id="servletapi-user-principal"><a class="anchor" href="#servletapi-user-principal"></a>HttpServletRequest.getUserPrincipal()</h4>
<div class="paragraph">
<p><a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()">HttpServletRequest.getUserPrincipal()</a>将返回<code>SecurityContextHolder.getContext().getAuthentication()</code>的结果。这意味着它是一个 <code>Authentication</code> 通常是 <code>UsernamePasswordAuthenticationToken</code>的一个实例使用基于用户名和密码的身份验证。这可能是有用的,如果你需要更多关于用户的信息。例如,您可能已经创建了一个自定义<code>UserDetailsService</code>,返回一个自定义的<code>UserDetails</code>包含您的用户的姓名。你可以用以下获得这些信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Authentication auth = httpServletRequest.getUserPrincipal();
// assume integrated custom UserDetails called MyCustomUserDetails
// by default, typically instance of UserDetails
MyCustomUserDetails userDetails = (MyCustomUserDetails) auth.getPrincipal();
String firstName = userDetails.getFirstName();
String lastName = userDetails.getLastName();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>应该指出的是，它通常是坏的做法，在你的应用程序执行这么多的逻辑。相反,应该集中它减少任何Spring Security和Servlet API的耦合。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="servletapi-user-in-role"><a class="anchor" href="#servletapi-user-in-role"></a>HttpServletRequest.isUserInRole(String)</h4>
<div class="paragraph">
<p>The <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)">HttpServletRequest.isUserInRole(String)</a> 将确定 <code>SecurityContextHolder.getContext().getAuthentication().getAuthorities()</code> 包含一个 <code>GrantedAuthority</code> 角色传入的 <code>isUserInRole(String)</code>。 一般用户不应通过"ROLE_" 前缀到这个方法,因为它是自动添加的。例如,如果你想要确定当前用户有权力"ROLE_ADMIN",你可以使用以下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">boolean isAdmin = httpServletRequest.isUserInRole("ADMIN");</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可能是有用的确定应该显示特定的UI组件。例如,您可能只显示管理链接如果当前用户是管理员。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servletapi-3"><a class="anchor" href="#servletapi-3"></a>Servlet 3+ 集成</h3>
<div class="paragraph">
<p>以下部分将介绍Servlet 3集成Spring Security的方法。</p>
</div>
<div class="sect3">
<h4 id="servletapi-authenticate"><a class="anchor" href="#servletapi-authenticate"></a>HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)</h4>
<div class="paragraph">
<p>The <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#authenticate%28javax.servlet.http.HttpServletResponse%29">HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)</a>方法可用于确保用户身份验证。如果他们没有身份验证,配置AuthenticationEntryPoint将用于请求用户进行身份验证(即重定向到登录页面)。</p>
</div>
</div>
<div class="sect3">
<h4 id="servletapi-login"><a class="anchor" href="#servletapi-login"></a>HttpServletRequest.login(String,String)</h4>
<div class="paragraph">
<p>The <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login%28java.lang.String,%20java.lang.String%29">HttpServletRequest.login(String,String)</a> 方法可用于验证用户与当前<code>AuthenticationManager</code>。例如,下面将尝试验证用户名 "user"和密码"password":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">try {
httpServletRequest.login("user","password");
} catch(ServletException e) {
// fail to authenticate
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>没有必要捕获ServletException如果你想让Spring Security来处理失败的身份验证。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="servletapi-logout"><a class="anchor" href="#servletapi-logout"></a>HttpServletRequest.logout()</h4>
<div class="paragraph">
<p>The <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout%28%29">HttpServletRequest.logout()</a> 方法可以用于记录当前用户。</p>
</div>
<div class="paragraph">
<p>通常这意味着SecurityContextHolder将被清除,HttpSession将失效,任何“记住我”身份验证将清理干净,等。然而,LogoutHandler配置实现将取决于你的Spring Security配置。需要注意是,在HttpServletRequest.logout()被调用,你要还负责编写一个响应。通常这将涉及一个重定向到欢迎页面。</p>
</div>
</div>
<div class="sect3">
<h4 id="servletapi-start-runnable"><a class="anchor" href="#servletapi-start-runnable"></a>AsyncContext.start(Runnable)</h4>
<div class="paragraph">
<p>The <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html#start%28java.lang.Runnable%29">AsynchContext.start(Runnable)</a> 的方法,确保您的凭据将传播到新的线程。使用 Spring Security的并发支持Spring Security覆盖AsyncContext.start(可运行),以确保当前SecurityContext处理可运行时使用。例如,以下将输出当前用户的身份验证:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">final AsyncContext async = httpServletRequest.startAsync();
async.start(new Runnable() {
	public void run() {
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		try {
			final HttpServletResponse asyncResponse = (HttpServletResponse) async.getResponse();
			asyncResponse.setStatus(HttpServletResponse.SC_OK);
			asyncResponse.getWriter().write(String.valueOf(authentication));
			async.complete();
		} catch(Exception e) {
			throw new RuntimeException(e);
		}
	}
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servletapi-async"><a class="anchor" href="#servletapi-async"></a>Async Servlet Support</h4>
<div class="paragraph">
<p>如果你使用的是基于Java的配置,你已经准备好了。如果你使用XML配置中,有一些是必要的更新。第一步是确保你更新你的web.xml使用至少3.0模式如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
version="3.0"&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来你需要确保你的springSecurityFilterChain设置处理异步请求。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;filter-class&gt;
	org.springframework.web.filter.DelegatingFilterProxy
&lt;/filter-class&gt;
&lt;async-supported&gt;true&lt;/async-supported&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
&lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是这样!现在的Spring Security将确保您的SecurityContext是在异步请求传播了。</p>
</div>
<div class="paragraph">
<p>那么它是怎样工作的？如果你是不是真的感兴趣，请随时跳过这一节的其余部分，否则就继续阅读。这是内置在Servlet规范,但有一点调整,Spring Security确保事情妥善处理异步请求。Spring Security 3.2之前,securitycontextholder的securitycontext自动保存只要httpservletresponse承诺。这可能会导致在异步环境下的问题。例如,考虑以下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">httpServletRequest.startAsync();
new Thread("AsyncThread") {
	@Override
	public void run() {
		try {
			// Do work
			TimeUnit.SECONDS.sleep(1);

			// Write to and commit the httpServletResponse
			httpServletResponse.getOutputStream().flush();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>问题是,这个线程是未知的Spring Security,所以SecurityContext中不会传播到它。这意味着当我们提交HttpServletResponse没有SecuriytContext。当Spring Security的自动保存SecurityContext支持HttpServletResponse就会失去我们的登录用户。</p>
</div>
<div class="paragraph">
<p>自从3.2版本开始，Spring Security是足够聪明，不再自动保存SecurityContext，一旦遵守协议 HttpServletResponse的HttpServletRequest.startAsync（）将尽快被调用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servletapi-31"><a class="anchor" href="#servletapi-31"></a>Servlet 3.1+ 集成</h3>
<div class="paragraph">
<p>以下部分描述了Servlet3.1与Spring Security集成的方法。</p>
</div>
<div class="sect3">
<h4 id="servletapi-change-session-id"><a class="anchor" href="#servletapi-change-session-id"></a>HttpServletRequest#changeSessionId()</h4>
<div class="paragraph">
<p>The <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html#changeSessionId()">HttpServletRequest.changeSessionId()</a> 是默认的方法防止 <a href="#ns-session-fixation">固定会话</a> 损害Servlet 3.1或更高的版本。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="basic"><a class="anchor" href="#basic"></a>Basic和Digest认证</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Basic和digest认证是在web应用中流行的替代身份验证机制。基本身份验证通常是使用无状态的客户对每个请求通过他们的凭证。这是相当常见的结合，其中一个应用程序通过两个基于浏览器的用户界面，并作为Web服务使用基于表单的身份验证中使用它。但是，基本身份验证发送密码以纯文本，所以应该只在真正加密传输层可以使用，例如HTTPS。</p>
</div>
<div class="sect2">
<h3 id="basic-processing-filter"><a class="anchor" href="#basic-processing-filter"></a>BasicAuthenticationFilter</h3>
<div class="paragraph">
<p><code>BasicAuthenticationFilter</code>负责处理HTTP头部中的基本认证证书。这可以用于验证由Spring远程协议(如Hessian和Burlap)的呼叫以及正常的浏览器的用户代理（如Firefox和Internet Explorer）。 HTTP基本认证的标准是由RFC 1945，第11条规定，以及<code>BasicAuthenticationFilter</code>符合这个RFC。基本身份验证是一个有吸引力的认证方法，因为它是非常广泛的，部署在用户代理和实施是非常简单的（它只是一个用户名的Base64编码:密码，在HTTP头中指定）。</p>
</div>
<div class="sect3">
<h4 id="basic-config"><a class="anchor" href="#basic-config"></a>Configuration</h4>
<div class="paragraph">
<p>为了实现HTTP基本身份验证,您需要添加一个<code>BasicAuthenticationFilter</code>到你的过滤器链。应用程序上下文应包含<code>BasicAuthenticationFilter</code>及其所需的合作者:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="basicAuthenticationFilter"
class="org.springframework.security.web.authentication.www.BasicAuthenticationFilter"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="authenticationEntryPoint" ref="authenticationEntryPoint"/&gt;
&lt;/bean&gt;

&lt;bean id="authenticationEntryPoint"
class="org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint"&gt;
&lt;property name="realmName" value="Name Of Your Realm"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>配置的<code>AuthenticationManager</code>处理每个认证请求。如果认证失败，配置<code>AuthenticationEntryPoint</code>将被用来重试认证过程。通常你会在组合使用过滤器<code>BasicAuthenticationEntryPoint</code>，它会返回一个合适的头部重试HTTP基本身份验证的401响应。如果认证成功，将所得<code>Authentication</code>对象将和平常一样被放入<code>SecurityContextHolder</code>。</p>
</div>
<div class="paragraph">
<p>如果认证事件成功，或者认证不需要执行，因为HTTP头部没有包含支持的认证请求，过滤器链将继续正常工作。过滤器链中断的唯一情况是，如果认证失败了，<code>Auth`DigestAuthenticationFilter</code>能够消化处理HTTP头部中的认证证书。摘要式身份验证试图解决许多基本身份验证的弱点，特别是保证凭据从不通过线路明文形式发送。许多用户支持摘要式身份验证，包括Firefox和Internet Explorer。标准管理HTTP摘要认证由RFC 2617定义,更新摘要式身份验证的一个早期版本由RFC 2069标准规定。大多数用户代理实现RFC 2617。Spring Security的<code>DigestAuthenticationFilter</code>兼容&#8220;auth&#8221;质量认证的保护(<code>qop</code>)规定的RFC 2617,这也与RFC 2069提供向后兼容性。摘要式身份验证是一个更有吸引力的选择,如果您需要使用未加密的HTTP(即没有TLS / HTTPS)并希望最大化安全的身份验证过程。事实上WebDAV协议摘要式身份验证是一个强制性的要求,指出由RFC 2518 17.1节。
enticationEntryPoint`被调用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="digest-processing-filter"><a class="anchor" href="#digest-processing-filter"></a>DigestAuthenticationFilter</h3>
<div class="paragraph">
<p><code>DigestAuthenticationFilter</code>能够消化处理HTTP头部中的认证证书。摘要式身份验证试图解决许多基本身份验证的弱点，特别是保证凭据从不通过线路明文形式发送。许多用户支持摘要式身份验证，包括Firefox和Internet Explorer。标准管理HTTP摘要认证由RFC 2617定义,更新摘要式身份验证的一个早期版本由RFC 2069标准规定。大多数用户代理实现RFC 2617。Spring Security的<code>DigestAuthenticationFilter</code>兼容&#8220;auth&#8221;质量认证的保护(<code>qop</code>)规定的RFC 2617,这也与RFC 2069提供向后兼容性。摘要式身份验证是一个更有吸引力的选择,如果您需要使用未加密的HTTP(即没有TLS / HTTPS)并希望最大化安全的身份验证过程。事实上WebDAV协议摘要式身份验证是一个强制性的要求,指出由RFC 2518 17.1节可见。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你不应该在现代应用中使用摘要，因为它被认为是不安全的。
最明显的问题是，你必须把您的密码以明文，加密，或一个MD5格式。
所有这些存储格式被认为是不安全的。
相反,你应该使用一种自适应的哈希密码（即BCrypt，PBKDF2，SCrypt等）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>摘要式身份验证的核心是一个"nonce"。这是一个服务器生成的值。Spring Security nonce采用以下格式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt" data-lang="txt">base64(expirationTime + ":" + md5Hex(expirationTime + ":" + key))
expirationTime:   The date and time when the nonce expires, expressed in milliseconds
key:              A private key to prevent modification of the nonce token</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DigestAuthenticatonEntryPoint</code>有一个属性指定用于生成nonce令牌的<code>key</code>,以及<code>nonceValiditySeconds</code>属性确定过期时间(默认300,等于5分钟)。只要nonce是有效的，摘要就会通过串联字符串包括用户名，密码，随机数，被请求的URI，一个客户端产生的随机数（仅该用户代理每个请求生成一个随机值），域名等，然后执行MD5哈希值。如果他们不同意一个包含值(如密码),服务器和用户代理执行此计算消化,就会导致不同的哈希码。在Spring Security实现中，如果服务器生成的nonce已经过期（但是摘要还是有效），在<code>DigestAuthenticationEntryPoint</code>将发送一个<code>"stale=true"</code>头。这告诉用户代理没有必要打扰用户（如用户名和密码等是正确的），而只是采用了全新的随机数再试一次。</p>
</div>
<div class="paragraph">
<p>对于<code>DigestAuthenticationEntryPoint</code>的参数<code>nonceValiditySeconds</code>而言一个适当的值取决于您的应用程序。非常安全的应用程序应该注意一个拦截认证头可以用来模拟本体，直到<code>expirationTime</code>中包含的特定场合。这是关键的原则，选择适当的设置，但它是不寻常的，非常安全的应用程序不能运行在第一个实例的TLS/HTTPS。</p>
</div>
<div class="paragraph">
<p>因为摘要式身份验证的更复杂的实现，经常有用户代理的问题。例如，IE不能在同一个会话的请求提出了一个&#8220;opaque&#8221;令牌。因此Spring Security封装了所有状态信息进入到&#8220;nonce&#8221;令牌中。在我们的测试中,Spring Security的实现与FireFox和ie能可靠地工作,正确处理nonce超时等。</p>
</div>
<div class="sect3">
<h4 id="digest-config"><a class="anchor" href="#digest-config"></a>Configuration</h4>
<div class="paragraph">
<p>既然我们已经回顾了理论,让我们看看如何使用它。为了实现HTTP摘要认证，必须在过滤器链定义<code>DigestAuthenticationFilter</code>。这个应用上下文将需要定义<code>DigestAuthenticationFilter</code>及其所需的合作者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="digestFilter" class=
	"org.springframework.security.web.authentication.www.DigestAuthenticationFilter"&gt;
&lt;property name="userDetailsService" ref="jdbcDaoImpl"/&gt;
&lt;property name="authenticationEntryPoint" ref="digestEntryPoint"/&gt;
&lt;property name="userCache" ref="userCache"/&gt;
&lt;/bean&gt;

&lt;bean id="digestEntryPoint" class=
	"org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint"&gt;
&lt;property name="realmName" value="Contacts Realm via Digest Authentication"/&gt;
&lt;property name="key" value="acegi"/&gt;
&lt;property name="nonceValiditySeconds" value="10"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>配置<code>UserDetailsService</code>是必要的因为<code>DigestAuthenticationFilter</code>必须有一个用户的明文密码直接访问。如果您正在使用您的DAO中的编码密码，摘要身份验证将无法工作   <sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnote_11" title="View footnote.">11</a>]</sup>. 这个DAO的协作者，与<code>UserCache</code>一起，通常直接与<code>DaoAuthenticationProvider</code>共享。该<code>authenticationEntryPoint</code>属性必须是<code>DigestAuthenticationEntryPoint</code>，使<code>DigestAuthenticationFilter</code>能够获得正确的<code>realmName</code>和<code>key</code>再进行摘要计算。</p>
</div>
<div class="paragraph">
<p>像<code>BasicAuthenticationFilter</code>，如果认证成功，<code>Authentication</code>请求令牌将被放置到了<code>SecurityContextHolder</code>。如果认证事件成功，或者认证不需要执行，因为HTTP头部没有包含摘要认证请求，过滤器链将继续正常。过滤器链中断的唯一情况是，如果认证失败了<code>AuthenticationEntryPoint</code>被调用，如前一段讨论。</p>
</div>
<div class="paragraph">
<p>摘要式身份验证的RFC提供了一系列附加功能，以进一步提高安全性。例如，随机数可以在每次请求被改变。尽管如此，Spring Security的实施旨在最大限度地减少执行（和用户代理出现不兼容）的复杂性，并避免保存服务器端的状态。你被邀请审查RFC 2617如果你想更详细地探索这些功能。据我们所知，Spring Security的实现中遵守了RFC的最低标准。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="remember-me"><a class="anchor" href="#remember-me"></a>Remember-Me Authentication</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="remember-me-overview"><a class="anchor" href="#remember-me-overview"></a>Overview</h3>
<div class="paragraph">
<p>Remember-me或persistent-login身份验证是指网站能够记住一个主体的身份之间的会话。这通常是通过发送cookie给浏览器，以及在未来的会话中发现的cookie，并进行自动登录发生完成的。Spring Security提供了这些操作发生的必要的挂钩，并有两个具体的remember-me实现。其中一个使用散列来保护基于cookie标记的安全性，另一个使用了数据库或其他持久化存储机制来保存生成的标记。</p>
</div>
<div class="paragraph">
<p>注意，所有实现都需要一个<code>UserDetailsService</code>。如果您正在使用身份验证提供者不使用<code>UserDetailsService</code>(例如,LDAP提供者),那么它不会工作,除非你也有一个<code>UserDetailsService</code>应用程序上下文中的bean。</p>
</div>
</div>
<div class="sect2">
<h3 id="remember-me-hash-token"><a class="anchor" href="#remember-me-hash-token"></a>Simple Hash-Based Token Approach</h3>
<div class="paragraph">
<p>这种方法使用散列来完成remember-me策略。本质上一个cookie发送到浏览器交互验证成功后,使用的cookie组成结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt" data-lang="txt">base64(username + ":" + expirationTime + ":" +
md5Hex(username + ":" + expirationTime + ":" password + ":" + key))

username:          As identifiable to the UserDetailsService
password:          That matches the one in the retrieved UserDetails
expirationTime:    The date and time when the remember-me token expires, expressed in milliseconds
key:               A private key to prevent modification of the remember-me token</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，remember-me的令牌在指定的期间是有效的，提供的用户名，密码和密钥不会改变。值得注意的是，这有一个潜在的安全问题，任何用户代理在remember-me令牌到期之前捕获到它，令牌将是可用的。这与摘要式身份验证问题是同样的问题。如果本人知道令牌已被抓获，他们可以轻松地更改他们的密码，并立即注销所有的remember-me标记。如果需要更显著的安全性，你应该使用在下一节中描述的方法。另外记得remember-me服务根本不应该被使用。</p>
</div>
<div class="paragraph">
<p>如果你熟悉在<a href="#ns-config">namespace configuration</a>命名空间配置这一章中讨论的主题，你可以启用remember-me认证只需添加<code>&lt;remember-me&gt;</code>元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
&lt;remember-me key="myAppKey"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>UserDetailsService</code>一般会自动选择。如果你有一个以上的应用环境，你需要指定哪一个应该使用<code>user-service-ref</code>属性，其中的值在你的<code>UserDetailsService</code> bean的名称中设置。</p>
</div>
</div>
<div class="sect2">
<h3 id="remember-me-persistent-token"><a class="anchor" href="#remember-me-persistent-token"></a>Persistent Token Approach</h3>
<div class="paragraph">
<p>这种方法是基于文章 <a href="http://jaspan.com/improved_persistent_login_cookie_best_practice">http://jaspan.com/improved_persistent_login_cookie_best_practice</a> 有一些小的修改  <sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnote_12" title="View footnote.">12</a>]</sup>. 若要使用命名空间配置的这种方法，你应该提供一个数据源引用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
&lt;remember-me data-source-ref="someDataSource"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>数据库应该包含一个<code>persistent_logins</code>表,使用以下SQL创建(或同等的):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl" data-lang="ddl">create table persistent_logins (username varchar(64) not null,
								series varchar(64) primary key,
								token varchar(64) not null,
								last_used timestamp not null)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remember-me-impls"><a class="anchor" href="#remember-me-impls"></a>Remember-Me的接口和实现</h3>
<div class="paragraph">
<p>Remember-me是用于 <code>UsernamePasswordAuthenticationFilter</code>,并通过<code>AbstractAuthenticationProcessingFilter</code>超类的钩子实现。
它也被运用在<code>BasicAuthenticationFilter</code>.
钩子会在合适的时候调用一个具体<code>RememberMeServices</code>。
该接口看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Authentication autoLogin(HttpServletRequest request, HttpServletResponse response);

void loginFail(HttpServletRequest request, HttpServletResponse response);

void loginSuccess(HttpServletRequest request, HttpServletResponse response,
	Authentication successfulAuthentication);</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参考JavaDocs获得什么方法都做了更充分的讨论，不过注意在这个阶段，<code>AbstractAuthenticationProcessingFilter</code>仅调用<code>loginFail（）</code>和<code>loginSuccess（）</code>方法。当<code>SecurityContextHolder</code> 不包含 <code>Authentication</code>时<code>autoLogin()</code>方法被<code>RememberMeAuthenticationFilter</code>调用。因此，此接口提供了基本的remember-me的实现与认证相关的事件的充分通知，和代表的执行情况时，一个候选Web请求可能包含一个cookie并希望被记住。这种设计允许任何数目的remember-me实现策略。我们已经看到上面Spring Security提供两种实现方法。我们来看看这些。</p>
</div>
<div class="sect3">
<h4 id="truetokenbasedremembermeservices"><a class="anchor" href="#truetokenbasedremembermeservices"></a>TokenBasedRememberMeServices</h4>
<div class="paragraph">
<p>这个实现支持 <a href="#remember-me-hash-token">Simple Hash-Based Token Approach</a>中描述的简单方法。<code>TokenBasedRememberMeServices</code>生成一个<code>RememberMeAuthenticationToken</code>,由<code>RememberMeAuthenticationProvider</code>处理。一个<code>key</code>认证提供者和<code>TokenBasedRememberMeServices</code>之间共享。此外，<code>TokenBasedRememberMeServices</code>需要一个UserDetailsService可以实现检索比较用户名和密码的目的，并生成<code>RememberMeAuthenticationToken</code>包含正确<code>GrantedAuthority</code>的一个UserDetailsService。如果用户提供无效的cookie，应该应用一些注销命令。<code>TokenBasedRememberMeServices</code>还实现了Spring Security的` logouthandler <code>接口，所有可以用`LogoutFilter</code>自动清除cookie。</p>
</div>
<div class="paragraph">
<p>在应用程序环境方面，remember-me服务需要的bean类如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="rememberMeFilter" class=
"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter"&gt;
&lt;property name="rememberMeServices" ref="rememberMeServices"/&gt;
&lt;property name="authenticationManager" ref="theAuthenticationManager" /&gt;
&lt;/bean&gt;

&lt;bean id="rememberMeServices" class=
"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices"&gt;
&lt;property name="userDetailsService" ref="myUserDetailsService"/&gt;
&lt;property name="key" value="springRocks"/&gt;
&lt;/bean&gt;

&lt;bean id="rememberMeAuthenticationProvider" class=
"org.springframework.security.authentication.RememberMeAuthenticationProvider"&gt;
&lt;property name="key" value="springRocks"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要忘记添加你的<code>RememberMeServices</code>实现<code>UsernamePasswordAuthenticationFilter.setRememberMeServices()</code>的属性,包括<code>RememberMeAuthenticationProvider</code>在<code>AuthenticationManager.setProviders（）</code>中的列表，并添加<code>RememberMeAuthenticationFilter</code>到你的<code>FilterChainProxy</code>(一般在你的<code>UsernamePasswordAuthenticationFilter</code>之后)。</p>
</div>
</div>
<div class="sect3">
<h4 id="truepersistenttokenbasedremembermeservices"><a class="anchor" href="#truepersistenttokenbasedremembermeservices"></a>PersistentTokenBasedRememberMeServices</h4>
<div class="paragraph">
<p>这个类可以以同样的方式作为<code>TokenBasedRememberMeServices</code>被使用，但它另外需要与<code>PersistentTokenRepository</code>存储令牌进行配置。有两种标准实现。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>InMemoryTokenRepositoryImpl</code> 这是只用来测试。</p>
</li>
<li>
<p><code>JdbcTokenRepositoryImpl</code> 其存储在数据库中的标记。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>数据库模式如上面所描述 <a href="#remember-me-persistent-token">Persistent Token Approach</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="csrf"><a class="anchor" href="#csrf"></a>Cross Site Request Forgery (CSRF)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节讨论Spring Security&#8217;s <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery"> Cross Site Request Forgery (CSRF)</a> 支持。</p>
</div>
<div class="sect2">
<h3 id="truecsrf"><a class="anchor" href="#truecsrf"></a>CSRF攻击</h3>
<div class="paragraph">
<p>在我们讨论Spring Security如何保护应用程序不受CSRF攻击之前，我们将解释什么是CSRF攻击。让我们来看一个具体的例子来更好地理解。</p>
</div>
<div class="paragraph">
<p>假设你的银行网站提供允许从当前登录的用户转移钱转到另一个银行账户的形式。例如，HTTP请求可能看起来像:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly
Content-Type: application/x-www-form-urlencoded

amount=100.00&amp;routingNumber=1234&amp;account=9876</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在假装你身份验证你的银行网站，然后再不注销，请访问一个恶意的网站。恶意的网站包含以下形式的HTML页面:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form action="https://bank.example.com/transfer" method="post"&gt;
&lt;input type="hidden"
	name="amount"
	value="100.00"/&gt;
&lt;input type="hidden"
	name="routingNumber"
	value="evilsRoutingNumber"/&gt;
&lt;input type="hidden"
	name="account"
	value="evilsAccountNumber"/&gt;
&lt;input type="submit"
	value="Win Money!"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你想赢钱,所以你点击submit按钮。在这个过程中，你无意中转移$100到恶意用户。这是因为，虽然恶意的网站不能看到你的cookies，与银行相关的cookies仍然与请求一起发送。</p>
</div>
<div class="paragraph">
<p>最糟糕的是，这整个过程可能已经使用JavaScript自动化。这意味着你甚至没有需要点击的按钮。那么我们该如何保护自己免受此类攻击?</p>
</div>
</div>
<div class="sect2">
<h3 id="true--18"><a class="anchor" href="#true--18"></a>同步器标记模式</h3>
<div class="paragraph">
<p>问题是，从银行网站上的HTTP请求，和从恶意的网站的要求是完全一样的。这就意味着没有办法拒绝来自恶意的网站的请求,允许请求来自银行的网站。为了抵御CSRF攻击我们需要确保请求中有一些恶意的网站是无法提供的。</p>
</div>
<div class="paragraph">
<p>一种解决方案是使用 <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern">同步器标记模式</a>. 这个解决方案是保证每个请求除了需要我们的会话cookie，还用随机生成的令牌作为HTTP参数。提交一个请求时,服务器必须查找参数和比较它的期望值和实际值的请求。如果值不匹配,请求失败。</p>
</div>
<div class="paragraph">
<p>我们可以轻松的预期，只要更新每个HTTP请求的令牌。这样做可以安全地自同源策略保证了恶意的网站无法读取响应。此外，我们不希望包括HTTP GET随机令牌，因为这可能会导致标记被泄露。</p>
</div>
<div class="paragraph">
<p>让我们来看看我们的例子将如何改变。假定随机产生的标记存在于一个HTTP参数name_csrf。例如，要转账的要求是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly
Content-Type: application/x-www-form-urlencoded

amount=100.00&amp;routingNumber=1234&amp;account=9876&amp;_csrf=&lt;secure-random&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你会注意到，我们添加了_csrf参数的随机值。现在，恶意网站将无法猜测_csrf参数(必须提供明确的恶意网站)，当服务器将实际的令牌与预期的令牌进行比较时，传输将失败。</p>
</div>
</div>
<div class="sect2">
<h3 id="true-csrf"><a class="anchor" href="#true-csrf"></a>何时使用CSRF保护</h3>
<div class="paragraph">
<p>什么时候应该使用CSRF保护？我们的建议是使用CSRF保护，可以通过浏览器处理普通用户的任何请求。如果你只是创建一个非浏览器客户端使用的服务,你可能会想要禁用CSRF保护。</p>
</div>
<div class="sect3">
<h4 id="truecsrf-json"><a class="anchor" href="#truecsrf-json"></a>CSRF保护和JSON</h4>
<div class="paragraph">
<p>一个常见的问题是"我是否需要保护JSON请求的javascript ?"简短的答案是，这取决于你。但是，你必须非常小心，因为有CSRF攻击可以影响JSON请求。例如，一个恶意用户可以使用以下格式，创建一个 <a href="http://blog.opensecurityresearch.com/2012/02/json-csrf-with-parameter-padding.html">CSRF和JSON使用以下form</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form action="https://bank.example.com/transfer" method="post" enctype="text/plain"&gt;
&lt;input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'&gt;
&lt;input type="submit"
	value="Win Money!"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将产生以下JSON结构</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">{ "amount": 100,
"routingNumber": "evilsRoutingNumber",
"account": "evilsAccountNumber",
"ignore_me": "=test"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一个应用程序没有验证内容类型，那么它会接触到这种攻击。根据设置,验证内容类型的Spring MVC应用程序仍然可以利用更新URL后缀结尾".json"如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form action="https://bank.example.com/transfer.json" method="post" enctype="text/plain"&gt;
&lt;input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'&gt;
&lt;input type="submit"
	value="Win Money!"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truecsrf-2"><a class="anchor" href="#truecsrf-2"></a>CSRF和无状态的浏览器应用程序</h4>
<div class="paragraph">
<p>如果我的应用程序是无状态的呢?这并不意味着你是受保护的。事实上,如果用户对于一个给定的请求不需要在web浏览器中执行任何操作,他们可能仍然容易受到CSRF攻击。</p>
</div>
<div class="paragraph">
<p>例如,考虑一个应用程序使用一个定制的cookie,其中包含所有的声明进行身份验证,而不是JSESSIONID。当CSRF是由自定义cookie与在该JSESSIONID cookie在前面的例子中相同的方式发送的，请求被发送。</p>
</div>
<div class="paragraph">
<p>使用基本身份验证的用户也容易受到CSRF攻击，因为浏览器会自动包括以同样的方式，在我们前面的例子中该JSESSIONID的cookie会发送任何请求的用户名密码。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="csrf-using"><a class="anchor" href="#csrf-using"></a>Using Spring Security CSRF Protection</h3>
<div class="paragraph">
<p>那么，什么是必要的，使用Spring Security来保护我们的网站不受CSRF攻击的步骤是什么？使用Spring Security的CSRF保护的步骤如下所述:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#csrf-use-proper-verbs">使用适当的HTTP动词</a></p>
</li>
<li>
<p><a href="#csrf-configure">配置CSRF保护</a></p>
</li>
<li>
<p><a href="#csrf-include-csrf-token">包括CSRF令牌</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="csrf-use-proper-verbs"><a class="anchor" href="#csrf-use-proper-verbs"></a>使用适当的HTTP动词</h4>
<div class="paragraph">
<p>防止CSRF攻击的第一步是确保你的网站使用适当的HTTP动词。具体来说，前Spring Security的CSRF支持可以使用，你需要确定你的应用程序使用PATCH，POST, PUT, and/or DELETE对于任何修改状态。</p>
</div>
<div class="paragraph">
<p>这不是一个Spring安全限制的支持，而是进行适当的预防CSRF的一般要求。原因是包括在一个HTTP GET私人信息可能导致的信息泄露。看到 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3">RFC 2616 Section 15.1.3在URI的敏感信息编码</a> 一般的指导对于敏感信息使用POST而不是GET。</p>
</div>
</div>
<div class="sect3">
<h4 id="csrf-configure"><a class="anchor" href="#csrf-configure"></a>配置CSRF保护</h4>
<div class="paragraph">
<p>下一步是要包括你的应用程序中的Spring Security的CSRF保护。有些框架处理无效CSRF无效用户的会话令牌，而这将导致 <a href="#csrf-logout">其自身的问题</a>。相反，在默认情况下Spring Security的CSRF保护将产生一个HTTP 403访问被拒绝。这可以通过配置<a href="#access-denied-handler">AccessDeniedHandler</a>以不同方式处理。</p>
</div>
<div class="paragraph">
<p>Spring Security 4.0,CSRF保护与XML配置默认启用。如果你想禁用CSRF保护,下面可以看到相应的XML配置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;csrf disabled="true"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>CSRF保护默认情况下使用Java配置启用。如果您想禁用CSRF，下面可以看到相应的Java配置。请参考Javadoc中的CSRF()在CSRF保护是如何自定义配置的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	.csrf().disable();
}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="csrf-include-csrf-token"><a class="anchor" href="#csrf-include-csrf-token"></a>包括CSRF令牌</h4>
<div class="sect4">
<h5 id="csrf-include-csrf-token-form"><a class="anchor" href="#csrf-include-csrf-token-form"></a>Form Submissions</h5>
<div class="paragraph">
<p>最后一步是确保您包括CSRF令牌在所有补丁，POST，PUT和DELETE方法。一个方法是使用<code>_csrf</code>请求属性来获取当前<code>CsrfToken</code>。用一个JSP这样做的一个示例如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;c:url var="logoutUrl" value="/logout"/&gt;
&lt;form action="${logoutUrl}"
	method="post"&gt;
&lt;input type="submit"
	value="Log out" /&gt;
&lt;input type="hidden"
	name="${_csrf.parameterName}"
	value="${_csrf.token}"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个更容易的方法是从Spring Security的JSP标签库使用<a href="#the-csrfinput-tag">CSRF输入标签</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你正在使用Spring MVC的<code>&lt;form:form&gt;</code>标签或 <a href="http://www.thymeleaf.org/whatsnew21.html#reqdata">Thymeleaf 2.1+</a> 和使用 <code>@EnableWebSecurity</code>, <code>CsrfToken</code>是自动包括 (使用<code>CsrfRequestDataValueProcessor</code>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="csrf-include-csrf-token-ajax"><a class="anchor" href="#csrf-include-csrf-token-ajax"></a>Ajax和JSON请求</h5>
<div class="paragraph">
<p>如果使用JSON,那么它是不可能在HTTP参数提交CSRF令牌。相反,你可以提交HTTP报头中的令牌。一个典型的模式是将包括您的meta标签内的CSRF令牌。用一个JSP一个例子如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;html&gt;
&lt;head&gt;
	&lt;meta name="_csrf" content="${_csrf.token}"/&gt;
	&lt;!-- default header name is X-CSRF-TOKEN --&gt;
	&lt;meta name="_csrf_header" content="${_csrf.headerName}"/&gt;
	&lt;!-- ... --&gt;
&lt;/head&gt;
&lt;!-- ... --&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>而不是手动创建meta标签,您可以从Spring Security JSP标记库中使用简单的<a href="#the-csrfmetatags-tag">csrfMetaTags标签</a>。</p>
</div>
<div class="paragraph">
<p>然后，您可以包含所有Ajax请求中的令牌。如果你是使用jQuery,这将通过以下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">$(function () {
var token = $("meta[name='_csrf']").attr("content");
var header = $("meta[name='_csrf_header']").attr("content");
$(document).ajaxSend(function(e, xhr, options) {
	xhr.setRequestHeader(header, token);
});
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为一种替代的jQuery，我们建议使用 <a href="http://cujojs.com/">cujoJS&#8217;s</a> rest.js. The <a href="https://github.com/cujojs/rest">rest.js</a>模块提供先进的支持以RESTful方式处理HTTP请求和响应。核心能力是能够说明链接所需的HTTP客户端添加行为拦截器客户端。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">var client = rest.chain(csrf, {
token: $("meta[name='_csrf']").attr("content"),
name: $("meta[name='_csrf_header']").attr("content")
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>所配置的客户端可以与需要一个到CSRF保护资源的请求的应用程序共享任何组件。rest.js和jQuery之间有一个显著的不同是只有配置客户端的请求将包含CSRF令牌,vs jQuery将包括<em>所有</em>请求令牌。请求接收令牌能力的范围有助于防止泄露CSRF令牌给第三方。请参阅  <a href="https://github.com/cujojs/rest/tree/master/docs">rest.js 参考文档</a>获取更多关于rest.js的信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="csrf-cookie"><a class="anchor" href="#csrf-cookie"></a>CookieCsrfTokenRepository</h5>
<div class="paragraph">
<p>可能有些情况下，用户想要坚持<code>CSRF Token</code>在cookie中。
默认情况下<code>CookieCsrfTokenRepository</code>将编写一个名为 <code>XSRF-TOKEN</code>的cookie和从头部命名 <code>X-XSRF-TOKEN</code>中读取或HTTP参数 <code>_csrf</code>。
这些默认值来自 <a href="https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection">AngularJS</a></p>
</div>
<div class="paragraph">
<p>你可以使用下面的XML配置<code>CookieCsrfTokenRepository</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;csrf token-repository-ref="tokenRepository"/&gt;
&lt;/http&gt;
&lt;b:bean id="tokenRepository"
	class="org.springframework.security.web.csrf.CookieCsrfTokenRepository"
	p:cookieHttpOnly="false"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>示例显式地设置<code>cookieHttpOnly=false</code>.
这是必要的，以允许JavaScript（即AngularJS）读取它。
如果你不需要使用JavaScript直接读取cookie的能力，，建议省略<code>cookieHttpOnly=false</code>来提高安全性。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可以配置<code>CookieCsrfTokenRepository</code>在Java配置中使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.csrf()
				.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>示例显式地设置<code>cookieHttpOnly=false</code>.
这是必要的,允许JavaScript(例如AngularJS)读取它。
如果你不需要使用JavaScript直接读取cookie的能力，建议省略 <code>cookieHttpOnly=false</code> (通过使用<code>new CookieCsrfTokenRepository()</code>代替) 提高安全性.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="csrf-caveats"><a class="anchor" href="#csrf-caveats"></a>CSRF警告</h3>
<div class="paragraph">
<p>在实现CSRF时有几个注意事项.</p>
</div>
<div class="sect3">
<h4 id="csrf-timeouts"><a class="anchor" href="#csrf-timeouts"></a>Timeouts</h4>
<div class="paragraph">
<p>一个问题是,预期CSRF令牌存储在HttpSession中,所以一旦HttpSession到期你的配置将收到一个InvalidCsrfTokenException <code>AccessDeniedHandler</code>。如果您使用的是默认的<code>AccessDeniedHandler</code>,浏览器将会得到一个HTTP 403并显示错误消息。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有人可能会问，为什么预期<code>CsrfToken</code>没有存储在默认的cookie。这是因为在该首部（即，指定的Cookie）可以被另一个域设置公知的漏洞。这是一样的道理Ruby on Rails <a href="http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/">no longer skips CSRF checks when the header X-Requested-With is present</a>. 见 <a href="http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html">这个webappsec.org线程</a> 关于如何执行的细节漏洞。另一个缺点是，通过除去状态（即超时）丢失强行终止该令牌，损失它的能力。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一个简单的方法，有一些JavaScript可以减轻一个活跃的用户体验超时，让用户知道他们的会话即将到期。用户可以点击一个按钮继续，并刷新会话。</p>
</div>
<div class="paragraph">
<p>另外，指定一个自定义的<code>AccessDeniedHandler</code>允许你以任何你喜欢的方式处理<code>InvalidCsrfTokenException</code>。 有关如何自定义<code>AccessDeniedHandler</code>的例子参考提供的链接为 <a href="#nsa-access-denied-handler">xml</a> 和 <a href="https://github.com/spring-projects/spring-security/blob/3.2.0.RC1/config/src/test/groovy/org/springframework/security/config/annotation/web/configurers/NamespaceHttpAccessDeniedHandlerTests.groovy#L64">Java configuration</a>.</p>
</div>
<div class="paragraph">
<p>最后，应用程序可以配置为使用 <a href="#csrf-cookie">CookieCsrfTokenRepository</a>这将不会过期。
正如前面提到的,这不是安全的使用一个会话,但在许多情况下已经足够好。</p>
</div>
</div>
<div class="sect3">
<h4 id="csrf-login"><a class="anchor" href="#csrf-login"></a>Logging In</h4>
<div class="paragraph">
<p>为了防止 <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests">forging登录请求</a> 在登录表单中应该也要防止CSRF攻击。因为<code>CsrfToken</code>存储在HttpSession中，这意味着一个HttpSession将尽快创建<code>CsrfToken</code>令牌属性进行访问。 虽然这听起来很糟糕，一个RESTful / stateless的体系结构对于实现实际的安全是必要的。如果没有的状态，我们什么都没有，如果令牌被攻破，我们可以做的。实事求是地讲，在CSRF令牌的尺寸非常小，应该对我们的架构可以忽略不计的影响。如果没有状态，如果令牌被攻破，我们没有什么可以做的。实际上,CSRF令牌的规模和体系结构很小应该对我们的架构有一个微不足道的影响。</p>
</div>
<div class="paragraph">
<p>一种保护登录常用技术是使用一个javascript函数在表单提交之前获得一个有效的CSRF令牌。通过这样做，没有必要去想会话超时因为表单提交前有创建会话（在上一节中讨论） (假设 <a href="#csrf-cookie">CookieCsrfTokenRepository</a> 没有配置而不是), 因此，用户当他想提交用户名/密码可以停留在登录页面上为了达到这个目标,你可以采取Spring Security提供的<code>CsrfTokenArgumentResolver</code>的优势，并像它在<a href="#mvc-csrf-resolver">这里</a>描述暴露的端点。</p>
</div>
</div>
<div class="sect3">
<h4 id="csrf-logout"><a class="anchor" href="#csrf-logout"></a>Logging Out</h4>
<div class="paragraph">
<p>添加CSRF将更新LogoutFilter只使用HTTP POST。这确保了注销需要CSRF令牌和一个恶意的用户不能强制注销用户。</p>
</div>
<div class="paragraph">
<p>一种方法是使用一种形式的日志。如果你真的想要一个链接，你可以（即也许隐藏表单）使用JavaScript，让链接执行POST。对于禁止使用JavaScript的浏览器,您可以选择有链接的用户注销确认页面执行POST。</p>
</div>
<div class="paragraph">
<p>如果你真的想使用HTTP GET注销你可以这样做,但请记住这一般不推荐。例如,下面的Java配置将执行任意的HTTP方法请求URL /logout执行注销:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.logout()
				.logoutRequestMatcher(new AntPathRequestMatcher("/logout"));
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="csrf-multipart"><a class="anchor" href="#csrf-multipart"></a>Multipart (文件上传)</h4>
<div class="paragraph">
<p>有两个选项来使用CSRF保护multipart/form-data.每个选项都有其权衡。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#csrf-multipartfilter">Placing MultipartFilter before Spring Security</a></p>
</li>
<li>
<p><a href="#csrf-include-csrf-token-in-action">Include CSRF token in action</a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>之前你和multipart集成Spring Security的CSRF保护文件上传，确保没有CSRF保护你可以第一时间上传。使用multipart表单与Spring的更多信息可以在 <a href="http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-multipart">17.10 Spring&#8217;s multipart (文件上传) 支持</a> 的Spring参考和 <a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html">MultipartFilter javadoc</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="csrf-multipartfilter"><a class="anchor" href="#csrf-multipartfilter"></a>Placing MultipartFilter before Spring Security</h5>
<div class="paragraph">
<p>第一个选项是确保<code>MultipartFilter</code>在Spring Security过滤器之前指定。Spring Security过滤器之前指定<code>MultipartFilter</code>意味着没有授权调用<code>MultipartFilter</code>这意味着任何人都可以服务器上上传临时文件。不过，只有授权的用户可以将文件提交由您的应用程序处理。总的来说,这是推荐的方法,因为临时文件上传在大多数服务器上应该只有一个微不足道的影响。</p>
</div>
<div class="paragraph">
<p>为了确保<code>MultipartFilter</code>是Spring Security的过滤器，在Java配置前指定，用户可以重写beforespringsecurityfilterchain如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SecurityApplicationInitializer extends AbstractSecurityWebApplicationInitializer {

	@Override
	protected void beforeSpringSecurityFilterChain(ServletContext servletContext) {
		insertFilters(servletContext, new MultipartFilter());
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了确保<code>MultipartFilter</code>是Spring Security的过滤器，在XML配置前指定，用户可以确定<code>MultipartFilter</code>的&lt;filter-mapping&gt;元素在springSecurityFilterChain前在web.xml中配置如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;filter&gt;
	&lt;filter-name&gt;MultipartFilter&lt;/filter-name&gt;
	&lt;filter-class&gt;org.springframework.web.multipart.support.MultipartFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter&gt;
	&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
	&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
	&lt;filter-name&gt;MultipartFilter&lt;/filter-name&gt;
	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;filter-mapping&gt;
	&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="csrf-include-csrf-token-in-action"><a class="anchor" href="#csrf-include-csrf-token-in-action"></a>Include CSRF token in action</h5>
<div class="paragraph">
<p>如果允许未经授权的用户上传temporariy文件是不能接受的，另一种是将Spring Security过滤后的<code>MultipartFilter</code>和CSRF作为查询参数包含在表单的动作属性。在jsp示例如下所示</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form action="./upload?${_csrf.parameterName}=${_csrf.token}" method="post" enctype="multipart/form-data"&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法的缺点是，查询参数可以被泄露。更普遍的是,最佳的方法是将敏感数据在身体或头部,以确保不泄露。更多信息可以在 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3">RFC 2616 Section 15.1.3 编码URI的敏感信息</a>中找到。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truehiddenhttpmethodfilter"><a class="anchor" href="#truehiddenhttpmethodfilter"></a>HiddenHttpMethodFilter</h4>
<div class="paragraph">
<p>该HiddenHttpMethodFilter应放在Spring Security的过滤器之前。一般来说这是事实，但它可能能够对防止CSRF攻击有更多的影响。</p>
</div>
<div class="paragraph">
<p>请注意，HiddenHttpMethodFilter只覆盖一个POST HTTP方法，所以这实际上是不可能造成任何实际问题。但是，它仍然是最好的做法，以确保它被放置在Spring Security过滤器之前。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true--19"><a class="anchor" href="#true--19"></a>重写默认值</h3>
<div class="paragraph">
<p>Spring Security的目标是提供默认值,保护用户免受攻击。这并不意味着你被迫接受所有的默认设置。</p>
</div>
<div class="paragraph">
<p>例如，您可以提供一个自定义CsrfTokenRepository覆盖其中<code>CSRF Token</code>的存储方式。</p>
</div>
<div class="paragraph">
<p>您还可以指定一个自定义RequestMatcher确定哪些请求受CSRF保护(即也许你不在乎注销是利用)。简而言之,如果Spring Security CSRF保护没有做出你想要的,你可以自定义行为。 请参阅 <a href="#nsa-csrf">&lt;csrf&gt;将添加元素</a>文档的细节如何自定义使用XML和<code>CsrfConfigurer</code> javadoc,了解如何使用Java配置将这些自定义设置。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cors"><a class="anchor" href="#cors"></a>CORS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring框架提供了 <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#cors">CORS第一级支持</a>。
CORS必须在Spring Security之前处理因为预检要求将不包含任何cookie（即<code>JSESSIONID</code>）。
如果第一个请求不包含任何cookie和Spring Security，将决定用户的请求没有被验证（因为有请求没有cookies），并拒绝它。</p>
</div>
<div class="paragraph">
<p>最简单的方法就是确保CORS首先是使用<code>CorsFilter</code>处理。
用户可以把<code>CorsFilter</code>和Spring Security 提供一个 <code>CorsConfigurationSource</code>使用如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// by default uses a Bean by the name of corsConfigurationSource
			.cors().and()
			...
	}

	@Bean
	CorsConfigurationSource corsConfigurationSource() {
		CorsConfiguration configuration = new CorsConfiguration();
		configuration.setAllowedOrigins(Arrays.asList("https://example.com"));
		configuration.setAllowedMethods(Arrays.asList("GET","POST"));
		UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
		source.registerCorsConfiguration("/**", configuration);
		return source;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在XML中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;cors configuration-source-ref="corsSource"/&gt;
	...
&lt;/http&gt;
&lt;b:bean id="corsSource" class="org.springframework.web.cors.UrlBasedCorsConfigurationSource"&gt;
	...
&lt;/b:bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你正在使用Spring MVC的CORS支持，你可以省略指定<code>CorsConfigurationSource</code>和Spring Security将利用CORS配置提供给Spring MVC。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// if Spring MVC is on classpath and no CorsConfigurationSource is provided,
			// Spring Security will use CORS configuration provided to Spring MVC
			.cors().and()
			...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在XML中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- Default to Spring MVC's CORS configuraiton --&gt;
	&lt;cors /&gt;
	...
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="headers"><a class="anchor" href="#headers"></a>安全HTTP响应头</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节讨论Spring Security支持将各种安全头添加到响应。</p>
</div>
<div class="sect2">
<h3 id="true--20"><a class="anchor" href="#true--20"></a>默认的安全头</h3>
<div class="paragraph">
<p>Spring Security允许用户轻松地注入的默认安全标头来帮助保护他们的应用程序。Spring Security默认是包括以下头部:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http" data-lang="http">Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Strict-Transport-Security只有添加HTTPS请求
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关这些标题的更多详细信息，请参见相应的章节:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#headers-cache-control">Cache Control</a></p>
</li>
<li>
<p><a href="#headers-content-type-options">Content Type Options</a></p>
</li>
<li>
<p><a href="#headers-hsts">HTTP Strict Transport Security</a></p>
</li>
<li>
<p><a href="#headers-frame-options">X-Frame-Options</a></p>
</li>
<li>
<p><a href="#headers-xss-protection">X-XSS-Protection</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>而这些头文件被认为是最佳方法,应该注意的是,并不是所有的客户端利用头部,所以鼓励进行额外的测试。</p>
</div>
<div class="paragraph">
<p>您可以自定义特定的头文件。
例如,假设希望你的HTTP响应头部为以下的样子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http" data-lang="http">Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block</code></pre>
</div>
</div>
<div class="paragraph">
<p>具体而言，你希望自定义所有的默认标题与下列:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#headers-frame-options">X-Frame-Options</a>允许来自同一个域中的任何请求</p>
</li>
<li>
<p><a href="#headers-hsts">HTTP Strict Transport Security (HSTS)</a> 将不会被添加到响应</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以很容易地用下面的Java配置做到这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers()
				.frameOptions().sameOrigin()
				.httpStrictTransportSecurity().disable();
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，如果你正在使用Spring Security的XML配置，你可以使用下面的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;frame-options policy="SAMEORIGIN" /&gt;
		&lt;hsts disable="true"/&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不想要添加默认值,需要明确控制应该使用什么,您可以禁用默认值。一个例子提供了Java和基于XML的配置:</p>
</div>
<div class="paragraph">
<p>如果您正在使用Spring安全的Java配置以下只会增加 <a href="#headers-cache-control">Cache Control</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		// do not use any default headers unless explicitly listed
		.defaultsDisabled()
		.cacheControl();
}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的XML只会增加<a href="#headers-cache-control">Cache Control</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers defaults-disabled="true"&gt;
		&lt;cache-control/&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果有必要,你可以禁用所有的HTTP安全响应头下面的Java配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers().disable();
}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果有必要,你可以禁用所有的HTTP安全响应头下面的XML配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers disabled="true" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="headers-cache-control"><a class="anchor" href="#headers-cache-control"></a>缓存控制</h4>
<div class="paragraph">
<p>在过去的Spring Security要求你提供自己的缓存控制您的web应用程序。这似乎是合理的,但是浏览器缓存已经进化到包括缓存安全连接。这意味着用户可以查看经过身份验证的页面,注销,然后恶意用户可以使用浏览器历史记录查看缓存页面。为了帮助缓解Spring Security增加了对高速缓存控制的支持，这将插入以下头部作为你的回应。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>简单的添加<a href="#nsa-headers">&lt;头部</a> 没有子元素的元素会自动添加缓存控制和不少其他保护措施。
不过，如果你只想要缓存控制，你可以使用Spring Security的XML命名空间与 <a href="#nsa-cache-control">&lt;cache-control</a>&gt; 元素和<a href="#nsa-headers-defaults-disabled">headers@defaults-disabled</a> 属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers defaults-disable="true"&gt;
		&lt;cache-control /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，您可以在Java配置中启用缓存控制类似以下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.defaultsDisabled()
		.cacheControl();
}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你真的想要缓存特定的反应,您的应用程序可以选择性地调用 <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String,java.lang.String)">HttpServletResponse.setHeader(String,String)</a> 覆盖头部Spring Security的设置。为了保证CSS，JavaScript之类的东西是用的并且图像正确缓存。</p>
</div>
<div class="paragraph">
<p>当使用Spring Web MVC,这通常是在你的配置中。例如,下面的配置设置将确保缓存头你所有的资源:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebMvc
public class WebMvcConfiguration extends WebMvcConfigurerAdapter {

	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry
			.addResourceHandler("/resources/**")
			.addResourceLocations("/resources/")
			.setCachePeriod(31556926);
	}

	// ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="headers-content-type-options"><a class="anchor" href="#headers-content-type-options"></a>内容类型选项</h4>
<div class="paragraph">
<p>历史上的浏览器，包括Internet Explorer，试图想请求的内容类型使用 <a href="http://en.wikipedia.org/wiki/Content_sniffing">content sniffing</a>。这就使得浏览器通过猜测来改善用户体验的内容类型没有指定内容类型的资源。例如,如果一个浏览器遇到一个JavaScript文件,该文件没有指定的内容类型,它会猜内容类型,然后执行它。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有许多额外的一个人应该做的事情(即只显示文档在不同的领域,确保设置内容类型头,清理文件等等)时,从而允许内容上传。然而,这些措施的范围之外的Spring Security提供什么。同样重要的是指出禁用content sniffing的时候，你必须要指定内容类型的东西才能正常工作。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>content sniffing的问题是，这允许恶意用户使用polyglots（即一个文件，是作为多种内容类型有效）来执行XSS攻击。例如，某些网站可能会允许用户提交一个有效的PostScript文档到网站，并查看它。恶意用户可能会创建一个 <a href="http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf">postscript文件，这也是一个有效的JavaScript文件</a> 并用它执行XSS攻击。</p>
</div>
<div class="paragraph">
<p>通过添加以下content sniffing可以禁用我们的响应头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>X-Content-Type-Options: nosniff</code></pre>
</div>
</div>
<div class="paragraph">
<p>就像缓存控制元件,nosniff指令添加默认情况下使用&lt;headers&gt;元素时,没有子元素。
然而,如果你想要更多的控制,添加头文件可以使用 <a href="#nsa-content-type-options">&lt;content-type-options</a>&gt;元素和<a href="#nsa-headers-defaults-disabled">headers@defaults-disabled</a>属性，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers defaults-disabled="true"&gt;
		&lt;content-type-options /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>X-Content-Type-Options头默认情况下使用Spring Security添加Java配置。如果你想要更多的控制头,您可以显式地指定以下内容类型选项:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.defaultsDisabled()
		.contentTypeOptions();
}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="headers-hsts"><a class="anchor" href="#headers-hsts"></a>HTTP Strict Transport Security (HSTS)</h4>
<div class="paragraph">
<p>当你输入你的银行的网站,你输入mybank.example.com 或者你输入 <a href="https://mybank.example.com" class="bare">https://mybank.example.com</a>? 如果您省略https协议,你可能容易受到 <a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a>。即使网站执行重定向到 <a href="https://mybank.example.com" class="bare">https://mybank.example.com</a> 恶意用户能够拦截最初的HTTP请求和操作响应(即重定向到 <a href="https://mibank.example.com" class="bare">https://mibank.example.com</a> 和窃取他们的凭证)。</p>
</div>
<div class="paragraph">
<p>很多用户忽略了https协议，这就是为什么 <a href="http://tools.ietf.org/html/rfc6797">HTTPHTTP严格传输安全（HSTS）</a> 已创建。一旦mybank.example.com 添加为 <a href="http://tools.ietf.org/html/rfc6797#section-5.1">HSTS host</a>,浏览器可以提前知道任何请求 mybank.example.com 应该解读为 <a href="https://mybank.example.com.这大大降低了发生中间人攻击的可能性。" class="bare">https://mybank.example.com.这大大降低了发生中间人攻击的可能性。</a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>按照 <a href="http://tools.ietf.org/html/rfc6797#section-7.2">RFC6797</a>, HSTS头仅注入到HTTPS响应。为了让浏览器承认头，浏览器必须先信任CA签署的用于建立连接的SSL证书（不只是SSL证书）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一个网站被标记为HSTS主机有主机预装到浏览器的一个方法。另一种是将"Strict-Transport-Security"头添加到响应。例如，以下将指示浏览器把域作为一年的HSTS主机（一年有大约31536000秒）:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Strict-Transport-Security: max-age=31536000 ; includeSubDomains</code></pre>
</div>
</div>
<div class="paragraph">
<p>可选includeSubDomains指令指示Spring安全子域(即secure.mybank.example.com)也应该被视为一个 HSTS域。</p>
</div>
<div class="paragraph">
<p>至于其它头部，Spring Security的默认添加HSTS。您可以自定义HSTS头部与<a href="#nsa-hsts">&lt;hsts</a>&gt;元素如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;hsts
			include-subdomains="true"
			max-age-seconds="31536000" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地,您可以只启用HSTS头与Java配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.httpStrictTransportSecurity()
			.includeSubdomains(true)
			.maxAgeSeconds(31536000);
}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="headers-hpkp"><a class="anchor" href="#headers-hpkp"></a>HTTP Public Key Pinning (HPKP)</h4>
<div class="paragraph">
<p>HTTP Public Key Pinning (HPKP) 是一个安全特性，它讲述了一个web客户端关联特定加密公钥与一个特定的web服务器以防止中间人(MITM)攻击和伪造的证书。</p>
</div>
<div class="paragraph">
<p>为了确保在TLS会话中使用服务器的公钥的真实性，这个公钥被包装成一个X。509证书通常由一个证书颁发机构(CA)签名。Web客户端如浏览器信任了很多这些CA，这都可以创建任意域名证书。
如果攻击者能够破坏一个CA，他们可以执行各种TLS连接MITM攻击。 HPKP可以规避HTTPS协议这一威胁,告诉客户端公钥属于一个特定的web服务器。
HPKP是在首次使用(TOFU)技术信托。第一次web服务器经由该公钥属于它的特殊HTTP头告诉客户端，客户端存储此信息的给定时间段。
当客户端访问服务器,它预计包含公钥证书的指纹通过HPKP已知。如果服务器提供一个未知的公共密钥，客户端应呈现警告给用户。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>因为用户代理需要验证对SSL证书链的链销,HPKP头只是注入HTTPS反应。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为你的网站启用这个特性很简单,当在HTTPS访问你的网站时返回Public-Key-Pins HTTP头。
例如，以下将指导用户代理只报告密码验证失败的给定URI(via the <a href="https://tools.ietf.org/html/rfc7469#section-2.1.4"><strong><em>report-uri</em></strong></a> directive)  2 引脚:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Public-Key-Pins-Report-Only: max-age=5184000 ; pin-sha256="d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=" ; pin-sha256="E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=" ; report-uri="http://example.net/pkp-report" ; includeSubDomains</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个 <a href="https://tools.ietf.org/html/rfc7469#section-3"><strong><em>pin 验证失败 report</em></strong></a> 是一个标准的JSON结构,可以捕获通过web应用程序的API或HPKP主办的公开报告服务, 比如, <a href="https://report-uri.io/"><strong><em>REPORT-URI</em></strong></a>.</p>
</div>
<div class="paragraph">
<p>可选的includeSubDomains指令指示浏览器也与给定引脚验证子域。</p>
</div>
<div class="paragraph">
<p>相对于其他的头部，Spring Security没有默认添加HPKP。你可以定制HPKP头与<a href="#nsa-hpkp">&lt;hpkp</a>&gt; 元素如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;hpkp
			include-subdomains="true"
			report-uri="http://example.net/pkp-report"&gt;
			&lt;pins&gt;
					&lt;pin algorithm="sha256"&gt;d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=&lt;/pin&gt;
					&lt;pin algorithm="sha256"&gt;E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=&lt;/pin&gt;
			&lt;/pins&gt;
		&lt;/hpkp&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，您可以启用Java配置HPKP头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
				http
				// ...
				.headers()
						.httpPublicKeyPinning()
								.includeSubdomains(true)
								.reportUri("http://example.net/pkp-report")
								.addSha256Pins("d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=", "E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=";
		}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="headers-frame-options"><a class="anchor" href="#headers-frame-options"></a>X-Frame-Options</h4>
<div class="paragraph">
<p>允许给你的网站添加框架可能是一个安全问题。例如，使用巧妙的CSS样式用户可能会被欺骗点击的东西，他们不打算 (<a href="http://www.youtube.com/watch?v=3mk0RySeNsU">video demo</a>)。 例如，登录到他们的银行用户可能会点击一个按钮授予其他用户访问。这种攻击被称为 <a href="http://en.wikipedia.org/wiki/Clickjacking">Clickjacking</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>另一种现代的方式来处理点击劫持是使用 <a href="#headers-content-security-policy">[headers-content-security-policy]</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有很多方法来缓解点击劫持攻击。例如，为了保护您可以使用传统的点击劫持的攻击的浏览器 <a href="https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script">frame breaking code</a>. 虽然并不完美，但断码的框架是可以为传统的浏览器做的最好的。</p>
</div>
<div class="paragraph">
<p>解决点击劫持更先进的方法是使用 <a href="https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options">X-Frame-Options</a> 头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>X-Frame-Options: DENY</code></pre>
</div>
</div>
<div class="paragraph">
<p>X-Frame-Options响应头指示浏览器阻止任何网站，这个头在响应中被呈现在一个框架中。
默认情况下,Spring Security禁用iframe内呈现。</p>
</div>
<div class="paragraph">
<p>你可以定制X-Frame-Options和 <a href="#nsa-frame-options">frame-options</a> 元素。
例如,以下将指示Spring Security用 "X-Frame-Options: SAMEORIGIN" 允许iframes在同一个域:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;frame-options
		policy="SAMEORIGIN" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，您可以自定义框架选项在Java配置中使用相同的起源:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.frameOptions()
			.sameOrigin();
}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="headers-xss-protection"><a class="anchor" href="#headers-xss-protection"></a>X-XSS-Protection</h4>
<div class="paragraph">
<p>有些浏览器已经内置支持过滤掉 <a href="https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OWASP-DV-001)">reflected XSS attacks</a>。这决不是完整的证明,但协助XSS的保护。</p>
</div>
<div class="paragraph">
<p>过滤通常是默认启用,所以添加头部通常只是确保它被启用和指示浏览器检测到XSS攻击时该做什么。例如,过滤器可能试图改变的内容至少入侵方式仍然呈现一切。有时,这种类型的替代可以成为 <a href="http://hackademix.net/2009/11/21/ies-xss-filter-creates-xss-vulnerabilities/">XSS 漏洞本身</a>。相反，它是最好的阻止内容，而不是试图修复它。要做到这一点，我们可以添加以下头部:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>X-XSS-Protection: 1; mode=block</code></pre>
</div>
</div>
<div class="paragraph">
<p>在默认情况下已经包括了这个头。然而，我们可以自定义它，如果我们想。 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;xss-protection block="false"/&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，您可以在Java配置中自定义XSS保护如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.xssProtection()
			.block(false);
}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="headers-csp"><a class="anchor" href="#headers-csp"></a>Content Security Policy (CSP)</h4>
<div class="paragraph">
<p><a href="https://www.w3.org/TR/CSP2/">Content Security Policy (CSP)</a>是一个web应用程序可以利用的机制来减轻内容注入漏洞,如跨站点脚本（XSS）。 CSP是一种声明性政策,为web应用程序提供了一个工具的作者声明，并最终通知客户端(用户代理)对web应用程序的来源将加载资源。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>内容安全策略不是为了解决所有的内容注入漏洞。相反，CSP可以利用，以帮助减少因内容注入攻击的危害。作为防御的第一道防线，Web应用程序的作者应该验证它们的输入和编码它们的输出。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>web应用程序可以通过使用CSP使用下列其中一个HTTP头的响应:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><em>Content-Security-Policy</em></strong></p>
</li>
<li>
<p><strong><em>Content-Security-Policy-Report-Only</em></strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每个这些头被用作一种机制，以提供一个 <strong><em>security policy</em></strong> 到客户端。
安全策略包含了一组 <strong><em>security policy directives</em></strong> (例如, <em>script-src</em> 和 <em>object-src</em>),
每个负责宣布限制为特定的资源表示形式。</p>
</div>
<div class="paragraph">
<p>例如，Web应用程序可以声明，预计加载特定，可信来源的脚本，通过再响应以下头部:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Content-Security-Policy: script-src https://trustedscripts.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>试图加载脚本以外另一个来源是什么中声明<em>script-src</em>指令将被用户代理。
此外，如果 <a href="https://www.w3.org/TR/CSP2/#directive-report-uri"><strong><em>report-uri</em></strong></a> 指令在安全政策声明，然后违反将由用户代理来声明的URL进行报告.</p>
</div>
<div class="paragraph">
<p>例如,如果一个web应用程序违反了安全政策声明,下面的响应头将指导用户代理发送违反政策的报告中指定的URL <em>report-uri</em> 指令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://www.w3.org/TR/CSP2/#violation-reports"><strong><em>Violation reports</em></strong></a> 是标准JSON结构,可以捕获通过web应用程序的API或公开托管CSP违反报告服务,比如, <a href="https://report-uri.io/"><strong><em>REPORT-URI</em></strong></a>.</p>
</div>
<div class="paragraph">
<p><strong><em>Content-Security-Policy-Report-Only</em></strong>头提供了web应用程序的作者的能力和管理员监控安全策略,而不是执行它们。 这个头通常用在当试验and/or开发一个网站的安全策略。
当一个政策被认为是有效的,它可以执行使用 <em>Content-Security-Policy</em> 头字段。</p>
</div>
<div class="paragraph">
<p>鉴于以下响应头,政策声明脚本可能加载两种可能的来源。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果违反了这一政策,试图从 <em>evil.加载脚本,
用户代理将发送一个违反报告宣布 _report-uri</em> 指令指定的URL,但仍然允许违反资源负载。</p>
</div>
<div class="sect4">
<h5 id="headers-csp-configure"><a class="anchor" href="#headers-csp-configure"></a>Configuring Content Security Policy</h5>
<div class="paragraph">
<p>重要的是要注意 Spring Security <strong><em>不添加</em></strong>内容默认安全策略。
web应用程序的作者必须声明安全策略执行and/or对受保护的资源进行监测。</p>
</div>
<div class="paragraph">
<p>例如,下面的安全策略:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用XML配置启用CSP头与 <a href="#nsa-content-security-policy">&lt;content-security-policy</a>元素如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要启用CSP <em>'report-only'</em>头部, 配置元素如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
			report-only="true" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地,您可以使用Java配置启用CSP头，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.contentSecurityPolicy("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/");
}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要启用CSP <em>'report-only'</em> 头部, 提供以下Java配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.contentSecurityPolicy("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
		.reportOnly();
}
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="headers-csp-links"><a class="anchor" href="#headers-csp-links"></a>Additional Resources</h5>
<div class="paragraph">
<p>内容安全策略应用到一个web应用程序通常是一个不简单的事情。
以下资源可以为你的网站发展有效的安全策略提供进一步的援助。</p>
</div>
<div class="paragraph">
<p><a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/">An Introduction to Content Security Policy</a></p>
</div>
<div class="paragraph">
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP">CSP Guide - Mozilla Developer Network</a></p>
</div>
<div class="paragraph">
<p><a href="https://www.w3.org/TR/CSP2/">W3C Candidate Recommendation</a></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="headers-custom"><a class="anchor" href="#headers-custom"></a>Custom Headers</h3>
<div class="paragraph">
<p>Spring安全机制,使它更加方便的将共同安全头添加到您的应用程序。并且,它还提供了钩子,能够添加自定义头部。</p>
</div>
<div class="sect3">
<h4 id="headers-static"><a class="anchor" href="#headers-static"></a>Static Headers</h4>
<div class="paragraph">
<p>也许有些时候你希望注入自定义的安全标头不支持您的应用程序的。例如,下面的自定义安全头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>X-Custom-Security-Header: header-value</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用XML命名空间,这些头部可以添加到响应使用 <a href="#nsa-header">&lt;header</a>&gt;元素如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;header name="X-Custom-Security-Header" value="header-value"/&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，头部可以在Java配置中添加到响应如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.addHeaderWriter(new StaticHeadersWriter("X-Custom-Security-Header","header-value"));
}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="headers-writer"><a class="anchor" href="#headers-writer"></a>Headers Writer</h4>
<div class="paragraph">
<p>当命名空间或Java配置不支持你想要的头部你可以自定义一个<code>HeadersWriter</code> 实例甚至提供一个自定义实现的 <code>HeadersWriter</code>。</p>
</div>
<div class="paragraph">
<p>让我们看看一个例子使用一个自定义的<code>XFrameOptionsHeaderWriter</code>的实例。也许你想允许框架内容有着相同的起源。这很容易支持通过设置 <a href="#nsa-frame-options-policy">policy</a> 属性 "SAMEORIGIN", 但让我们看看一个更明确的例子使用 <a href="#nsa-header-ref">ref</a> 属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;header ref="frameOptionsWriter"/&gt;
	&lt;/headers&gt;
&lt;/http&gt;
&lt;!-- Requires the c-namespace.
See http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-c-namespace
--&gt;
&lt;beans:bean id="frameOptionsWriter"
	class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"
	c:frameOptionsMode="SAMEORIGIN"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以限制框架的内容为与Java配置相同的起源:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.addHeaderWriter(new XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN));
}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="headers-delegatingrequestmatcherheaderwriter"><a class="anchor" href="#headers-delegatingrequestmatcherheaderwriter"></a>DelegatingRequestMatcherHeaderWriter</h4>
<div class="paragraph">
<p>有时你可能想要只对某些请求写头部。例如,也许你想只保护你的登录页面不被攻击，你可以使用 <code>DelegatingRequestMatcherHeaderWriter</code> 。 当使用XML命名空间配置, 这可以如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;frame-options disabled="true"/&gt;
		&lt;header ref="headerWriter"/&gt;
	&lt;/headers&gt;
&lt;/http&gt;

&lt;beans:bean id="headerWriter"
	class="org.springframework.security.web.header.writers.DelegatingRequestMatcherHeaderWriter"&gt;
	&lt;beans:constructor-arg&gt;
		&lt;bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher"
			c:pattern="/login"/&gt;
	&lt;/beans:constructor-arg&gt;
	&lt;beans:constructor-arg&gt;
		&lt;beans:bean
			class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"/&gt;
	&lt;/beans:constructor-arg&gt;
&lt;/beans:bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以使用java配置防止框架的内容到登录页面:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	RequestMatcher matcher = new AntPathRequestMatcher("/login");
	DelegatingRequestMatcherHeaderWriter headerWriter =
		new DelegatingRequestMatcherHeaderWriter(matcher,new XFrameOptionsHeaderWriter());
	http
	// ...
	.headers()
		.frameOptions().disabled()
		.addHeaderWriter(headerWriter);
}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="session-mgmt"><a class="anchor" href="#session-mgmt"></a>会话管理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>HTTP会话相关的功能性是通过<code>SessionManagementFilter</code>和<code>SessionAuthenticationStrategy</code>接口结合来处理，筛选出一个代表.典型用法包括会话固定保护攻击预防，检测到会话超时并且限制有多少会话经过身份验证的用户可以同时打开。</p>
</div>
<div class="sect2">
<h3 id="true--21"><a class="anchor" href="#true--21"></a>会话管理过滤器</h3>
<div class="paragraph">
<p><code>SessionManagementFilter</code>检测 <code>SecurityContextRepository</code>的内容违背了现在<code>SecurityContextHolder</code>的内容来决定是否在当前请求用户已经通过身份验证，通常由一个非交互式的身份验证机制，如验证或记脚注:[身份验证机制验证后进行重定向（例如form-login）将不会被<code>SessionManagementFilter</code>检测到，过滤器将不调用身份验证请求，会话管理功能必须在这些情况下分别处理].如果存储库包含一个安全文档，过滤器什么都不做，如果这没有这么做，局部线程<code>SecurityContext</code>包含了一个（不是匿名）<code>Authentication</code>对象.</p>
</div>
<div class="paragraph">
<p>如果用户当前没有经过身份验证,过滤器将检查是否一个无效的请求会话ID（例如由于超时），并将调用<code>InvalidSessionStrategy</code>的配置，如果一个被设置了.最通常的行为是重定向到一个固定的URL，这是将实现<code>SimpleRedirectInvalidSessionStrategy</code>进行实施.无效的会话时后者也会使用当通过命名空间配置.<a href="#ns-session-mgmt">as described earlier</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="true--22"><a class="anchor" href="#true--22"></a>会话的身份验证策略</h3>
<div class="paragraph">
<p><code>SessionAuthenticationStrategy</code>通过<code>SessionManagementFilter</code> 和<code>AbstractAuthenticationProcessingFilter</code>被利用，所以如果你利用了一个定制的form-login例如，你将需要把它注入到这两个，在这种情况下，一个典型的配置，结合命名空间和自定义的beans可能看起来像这样 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;
&lt;session-management session-authentication-strategy-ref="sas"/&gt;
&lt;/http&gt;

&lt;beans:bean id="myAuthFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
	&lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
	...
&lt;/beans:bean&gt;

&lt;beans:bean id="sas" class=
"org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意默认的使用，<code>SessionFixationProtectionStrategy</code>可能会导致问题，如果你是存储在session中的bean实施<code>HttpSessionBindingListener</code>，包括Spring session-scoped beans，看这个类中的javadoc寻找更多信息.</p>
</div>
</div>
<div class="sect2">
<h3 id="concurrent-sessions"><a class="anchor" href="#concurrent-sessions"></a>并发控制</h3>
<div class="paragraph">
<p>Spring Security能防止主体同时访问同一应用程序的多个指定的次数，许多软件公司利用这一强制许可.虽然网络管理员喜欢这个功能，因为它有助于防止人们共享登录名.例如你能停止"Batman"用户从两个不同的会话登录到Web应用程序 ，您可以终止他们的以前的登录，或者当他们尝试再次登录时，你可以报告一个错误 ，预防第二次登陆，请注意，如果您使用的第二种方法，一个没有显式退出的用户（例如谁刚刚关闭了浏览器）将无法再次登录，直到他们的原始会话过期.</p>
</div>
<div class="paragraph">
<p>并发控制是由命名空间支持的，所以请检查早期的命名空间章节的最简单的配置。虽然有时你需要自定义的东西。</p>
</div>
<div class="paragraph">
<p>该实现使用了一个<code>SessionAuthenticationStrategy</code>的专门的版本，叫做<code>ConcurrentSessionControlAuthenticationStrategy</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以前并发的身份验证检查通过<code>ProviderManager</code>制作，由<code>ConcurrentSessionController</code>注射，后者将检查用户是否试图超过允许的会话数.尽管如此，这种方法需要一个HTTP会话提前被创建.这是不受欢迎的，在Spring Security 3, 用户首先经过<code>AuthenticationManager</code>进行身份验证，而且一旦他们成功地通过身份验证，就会创建一个会话，并检查是否允许他们有另一个会话打开.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使用并发会话支持，您需要添加以下
<code>web.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;listener&gt;
	&lt;listener-class&gt;
	org.springframework.security.web.session.HttpSessionEventPublisher
	&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>除此之外，你将需要添加<code>ConcurrentSessionFilter</code> 到你的<code>FilterChainProxy</code>.<code>ConcurrentSessionFilter</code>要求两个属性，<code>sessionRegistry</code>一般是指一个<code>SessionRegistryImpl</code>的实例，<code>expiredUrl</code>指向页面时显示会话已过期的页面，一个配置利用命名空间去创建<code>FilterChainProxy</code>和不符合要求的beans如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="CONCURRENT_SESSION_FILTER" ref="concurrencyFilter" /&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;

&lt;session-management session-authentication-strategy-ref="sas"/&gt;
&lt;/http&gt;

&lt;beans:bean id="concurrencyFilter"
class="org.springframework.security.web.session.ConcurrentSessionFilter"&gt;
&lt;beans:property name="sessionRegistry" ref="sessionRegistry" /&gt;
&lt;beans:property name="expiredUrl" value="/session-expired.htm" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="myAuthFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
&lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
&lt;beans:property name="authenticationManager" ref="authenticationManager" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="sas" class="org.springframework.security.web.authentication.session.CompositeSessionAuthenticationStrategy"&gt;
&lt;beans:constructor-arg&gt;
	&lt;beans:list&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy"&gt;
		&lt;beans:constructor-arg ref="sessionRegistry"/&gt;
		&lt;beans:property name="maximumSessions" value="1" /&gt;
		&lt;beans:property name="exceptionIfMaximumExceeded" value="true" /&gt;
	&lt;/beans:bean&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy"&gt;
	&lt;/beans:bean&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.RegisterSessionAuthenticationStrategy"&gt;
		&lt;beans:constructor-arg ref="sessionRegistry"/&gt;
	&lt;/beans:bean&gt;
	&lt;/beans:list&gt;
&lt;/beans:constructor-arg&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="sessionRegistry"
	class="org.springframework.security.core.session.SessionRegistryImpl" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每一次<code>HttpSession</code>开始或者结束,添加一个监听到<code>web.xml</code> 导致一个<code>ApplicationEvent</code>被发布到Spring <code>ApplicationContext</code>.这很关键，因为当一个会话结束时这个允许<code>SessionRegistryImpl</code>被通知，即使他们退出了另一个会话或它超时.</p>
</div>
<div class="sect3">
<h4 id="list-authenticated-principals"><a class="anchor" href="#list-authenticated-principals"></a>查询sessionregistry目前身份验证的用户和他们的会话</h4>
<div class="paragraph">
<p>建立并发控制通过命名空间或使用bean具有有益的副作用，为您提供一个参考的` sessionregistry <code>可以直接应用在在您的应用程序.因此,即使你不想限制用户会话的数量,它可能值得建立基础设施.你可以建立`maximumSession</code>财产到- 1允许无限的会话.如果你使用的命名空间，您可以利用<code>session-registry-alias</code>属性为内部创建<code>SessionRegistry</code>的别名设置.提供一个参考，你可以注射到你自己的bean.</p>
</div>
<div class="paragraph">
<p><code>getAllPrincipals()</code>方法为您提供当前身份验证的用户的列表.您可以列出用户会话通过呼叫<code>getAllSessions(Object principal, boolean includeExpiredSessions)</code>方法，返回<code>SessionInformation</code>对象列表.您也可以终止用户会话通过在<code>SessionInformation</code>实例中呼叫<code>expireNow()</code>，当用户返回到应用程序时，他们将被阻止进行。您可能会发现这些方法在一个管理应用程序中是有用的，例如.看看javadoc的更多信息</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="anonymous"><a class="anchor" href="#anonymous"></a>匿名身份验证</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="anonymous-overview"><a class="anchor" href="#anonymous-overview"></a>概述</h3>
<div class="paragraph">
<p>采取 "deny-by-default"在您显式指定什么是允许和禁止一切，它通常被认为是良好的安全实践.定义什么是未经身份验证的用户访问的是一个类似的情况,特别是用于Web应用程序.许多网站要求用户必须对其他比一些网址的任何东西进行身份验证(例如，主界面和登录页面).在这种情况下，它是最简单的定义访问这些特定的网址的访问配置属性，而不是为每一个安全的资源.不同的,在默认情况下` role_something `要求很好说，但有时候也有例外.例如一个应用的登陆，注销，和主页面.你也可以从过滤器链完全忽略这些页面,从而绕过访问控制检查,但这可能是不受欢迎的其他原因,特别是如果经过身份验证的用户的页面的行为会有所不同.</p>
</div>
<div class="paragraph">
<p>这就是我们所说的匿名身份验证，请注意,没有真正的概念区别用户"anonymously authenticated"和未经过身份验证的用户.Spring Security的匿名身份验证只给您一个更加方便的方式来配置您的访问控制属性.如<code>getCallerPrincipal</code>调用servlet API，仍将返回null,尽管实际上<code>SecurityContextHolder</code>中的一个匿名认证对象.</p>
</div>
<div class="paragraph">
<p>还有其他的匿名身份验证的情况下是有用的,例如，当一个审计拦截器查询<code>SecurityContextHolder</code>来识别哪个主要是负责一个给定的操作.类可以创建更强劲,如果他们知道<code>SecurityContextHolder</code>总是包含一个“身份验证”对象,而且从不<code>null</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="anonymous-config"><a class="anchor" href="#anonymous-config"></a>配置</h3>
<div class="paragraph">
<p>匿名认证提供支持自动使用HTTP配置Spring Security 3时可定制（或禁用）使用<code>&lt;anonymous&gt;</code>元元素.您不需要配置这里所描述的beans，除非你使用传统的bean配置.</p>
</div>
<div class="paragraph">
<p>三个类 一起提供匿名身份验证功能.<code>AnonymousAuthenticationToken</code> 是一个实现 <code>Authentication</code> ,商店的` GrantedAuthority <code>适用于匿名委托,有相应的</code> anonymousauthenticationprovider <code>,这是链接到</code> providermanager <code>,以至于 `AnonymousAuthenticationToken</code>能接受.最后，有一个` anonymousauthenticationfilter <code>，这是把正常的认证机制后，自动添加一个</code> anonymousauthenticationtoken <code>的</code> securitycontextholder `,如果没有现有的身份验证在那里举行.筛选器和身份验证提供程序的定义如下 :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="anonymousAuthFilter"
	class="org.springframework.security.web.authentication.AnonymousAuthenticationFilter"&gt;
&lt;property name="key" value="foobar"/&gt;
&lt;property name="userAttribute" value="anonymousUser,ROLE_ANONYMOUS"/&gt;
&lt;/bean&gt;

&lt;bean id="anonymousAuthenticationProvider"
	class="org.springframework.security.authentication.AnonymousAuthenticationProvider"&gt;
&lt;property name="key" value="foobar"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在筛选器和身份验证提供程序之间共享“key”,使前者所创建的符号被后者的脚注所接受[ <code>key</code>属性的使用不应被视为在这里提供任何真正的安全性.它仅仅是一个簿记锻炼,
如果你是共享一个` providermanager <code>包含</code> anonymousauthenticationprovider <code>,在这样的情形下，它是可能的认证客户端构建`Authentication</code>对象(如RMI调用),然后，一个恶意的客户端可以提交一个` anonymousauthenticationtoken <code>，它创造了自己 (选择的用户名和权限列表 ).如果`key</code>是人或能被发现，然后代表将被匿名者接受，这不是正常使用的问题，但如果你使用RMI你最好使用一个定制的没有匿名的` providermanager <code>提供者而不是分享你使用HTTP认证机制.
]. ` userattribute `表达的形式</code> usernameintheauthenticationtoken，授予权威<code>,这是相同的语法使用等号后的`InMemoryDaoImpl</code>的`userMap”属性.</p>
</div>
<div class="paragraph">
<p>如前所述,匿名身份验证的好处是,所有URI模式可以安全应用。例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="filterSecurityInterceptor"
	class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="httpRequestAccessDecisionManager"/&gt;
&lt;property name="securityMetadata"&gt;
	&lt;security:filter-security-metadata-source&gt;
	&lt;security:intercept-url pattern='/index.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/hello.htm' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/logoff.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/login.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/**' access='ROLE_USER'/&gt;
	&lt;/security:filter-security-metadata-source&gt;" +
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anonymous-auth-trust-resolver"><a class="anchor" href="#anonymous-auth-trust-resolver"></a>验证信任解析器</h3>
<div class="paragraph">
<p>排在匿名身份验证讨论是<code>AuthenticationTrustResolver</code>界面,与相应的<code>AuthenticationTrustResolverImpl</code>实现.这个接口提供了一个<code>isAnonymous(Authentication)</code>的方法,感兴趣的类可以考虑这种特殊类型的身份验证状态.<code>ExceptionTranslationFilter</code>使用这个接口在处理<code>AccessDeniedException</code>,如果抛出<code>AccessDeniedException</code> ,和一个匿名类型的身份验证,而不是扔403(禁止)的反应,过滤器将开始` authenticationentrypoint <code>所以可以验证正确.这是一个必要的区别,否则，负责将永远被视为"authenticated"，并没有得到一个机会通过表格登录,基本、摘要或其他一些正常的身份验证机制。你会经常看到</code> role_anonymous <code>属性在上述拦截器配置更换</code> is_authenticated_anonymously <code>，这实际上是一样的定义访问控制,这是一个例子，使用的</code> authenticatedvoter <code>我们将看到在<a href="#authz-authenticated-voter">authorization chapter</a>.它使用一个</code> authenticationtrustresolver <code>处理这个特定的配置属性和访问权限授予匿名用户.它使用一个</code> authenticationtrustresolver <code>处理这个特定的配置属性和访问权限授予匿名用户.</code> authenticatedvoter <code>方法更强大，因为它允许你区分匿名,请记住我和完全身份验证的用户.如果你不需要这个功能,然后你可以坚持`ROLE_ANONYMOUS</code>,这将是由Spring Security的标准` rolevoter `.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="websocket"><a class="anchor" href="#websocket"></a>WebSocket Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 4 added support for securing <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html">Spring&#8217;s WebSocket support</a>.
This section describes how to use Spring Security&#8217;s WebSocket support.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can find a complete working sample of WebSocket security in samples/javaconfig/chat.
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Direct JSR-356 Support</div>
<div class="paragraph">
<p>Spring Security does not provide direct JSR-356 support because doing so would provide little value.
This is because the format is unknown, so there is <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-intro-sub-protocol">little Spring can do to secure an unknown format</a>.
Additionally, JSR-356 does not provide a way to intercept messages, so security would be rather invasive.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-configuration"><a class="anchor" href="#websocket-configuration"></a>WebSocket Configuration</h3>
<div class="paragraph">
<p>Spring Security 4.0 has introduced authorization support for WebSockets through the Spring Messaging abstraction.
To configure authorization using Java Configuration, simply extend the <code>AbstractSecurityWebSocketMessageBrokerConfigurer</code> and configure the <code>MessageSecurityMetadataSourceRegistry</code>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class WebSocketSecurityConfig
      extends AbstractSecurityWebSocketMessageBrokerConfigurer { <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>

    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .simpDestMatchers("/user/*").authenticated() <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any inbound CONNECT message requires a valid CSRF token to enforce <a href="#websocket-sameorigin">Same Origin Policy</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The SecurityContextHolder is populated with the user within the simpUser header attribute for any inbound request.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Our messages require the proper authorization. Specifically, any inbound message that starts with "/user/" will require ROLE_USER. Additional details on authorization can be found in <a href="#websocket-authorization">WebSocket Authorization</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security also provides <a href="#nsa-websocket-security">XML Namespace</a> support for securing WebSockets.
A comparable XML based configuration looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;websocket-message-broker&gt; <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
    <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;intercept-message pattern="/user/**" access="hasRole('USER')" /&gt;
&lt;/websocket-message-broker&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any inbound CONNECT message requires a valid CSRF token to enforce <a href="#websocket-sameorigin">Same Origin Policy</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The SecurityContextHolder is populated with the user within the simpUser header attribute for any inbound request.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Our messages require the proper authorization. Specifically, any inbound message that starts with "/user/" will require ROLE_USER. Additional details on authorization can be found in <a href="#websocket-authorization">WebSocket Authorization</a></td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="websocket-authentication"><a class="anchor" href="#websocket-authentication"></a>WebSocket Authentication</h3>
<div class="paragraph">
<p>WebSockets reuse the same authentication information that is found in the HTTP request when the WebSocket connection was made.
This means that the <code>Principal</code> on the <code>HttpServletRequest</code> will be handed off to WebSockets.
If you are using Spring Security, the <code>Principal</code> on the <code>HttpServletRequest</code> is overridden automatically.</p>
</div>
<div class="paragraph">
<p>More concretely, to ensure a user has authenticated to your WebSocket application, all that is necessary is to ensure that you setup Spring Security to authenticate your HTTP based web application.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-authorization"><a class="anchor" href="#websocket-authorization"></a>WebSocket Authorization</h3>
<div class="paragraph">
<p>Spring Security 4.0 has introduced authorization support for WebSockets through the Spring Messaging abstraction.
To configure authorization using Java Configuration, simply extend the <code>AbstractSecurityWebSocketMessageBrokerConfigurer</code> and configure the <code>MessageSecurityMetadataSourceRegistry</code>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    @Override
    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .nullDestMatcher().authenticated() <i class="conum" data-value="1"></i><b>(1)</b>
                .simpSubscribeDestMatchers("/user/queue/errors").permitAll() <i class="conum" data-value="2"></i><b>(2)</b>
                .simpDestMatchers("/app/**").hasRole("USER") <i class="conum" data-value="3"></i><b>(3)</b>
                .simpSubscribeDestMatchers("/user/**", "/topic/friends/*").hasRole("USER") <i class="conum" data-value="4"></i><b>(4)</b>
                .simpTypeMatchers(MESSAGE, SUBSCRIBE).denyAll() <i class="conum" data-value="5"></i><b>(5)</b>
                .anyMessage().denyAll(); <i class="conum" data-value="6"></i><b>(6)</b>

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any message without a destination (i.e. anything other that Message type of MESSAGE or SUBSCRIBE) will require the user to be authenticated</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Anyone can subscribe to /user/queue/errors</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Any message that has a destination starting with "/app/" will be require the user to have the role ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Any message that starts with "/user/" or "/topic/friends/" that is of type SUBSCRIBE will require ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Any other message of type MESSAGE or SUBSCRIBE is rejected. Due to 6 we do not need this step, but it illustrates how one can match on specific message types.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Any other Message is rejected. This is a good idea to ensure that you do not miss any messages.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security also provides <a href="#nsa-websocket-security">XML Namespace</a> support for securing WebSockets.
A comparable XML based configuration looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;websocket-message-broker&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;intercept-message type="CONNECT" access="permitAll" /&gt;
    &lt;intercept-message type="UNSUBSCRIBE" access="permitAll" /&gt;
    &lt;intercept-message type="DISCONNECT" access="permitAll" /&gt;

    &lt;intercept-message pattern="/user/queue/errors" type="SUBSCRIBE" access="permitAll" /&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;intercept-message pattern="/app/**" access="hasRole('USER')" /&gt;      <i class="conum" data-value="3"></i><b>(3)</b>

    <i class="conum" data-value="4"></i><b>(4)</b>
    &lt;intercept-message pattern="/user/**" access="hasRole('USER')" /&gt;
    &lt;intercept-message pattern="/topic/friends/*" access="hasRole('USER')" /&gt;

    <i class="conum" data-value="5"></i><b>(5)</b>
    &lt;intercept-message type="MESSAGE" access="denyAll" /&gt;
    &lt;intercept-message type="SUBSCRIBE" access="denyAll" /&gt;

    &lt;intercept-message pattern="/**" access="denyAll" /&gt; <i class="conum" data-value="6"></i><b>(6)</b>
&lt;/websocket-message-broker&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any message of type CONNECT, UNSUBSCRIBE, or DISCONNECT will require the user to be authenticated</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Anyone can subscribe to /user/queue/errors</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Any message that has a destination starting with "/app/" will be require the user to have the role ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Any message that starts with "/user/" or "/topic/friends/" that is of type SUBSCRIBE will require ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Any other message of type MESSAGE or SUBSCRIBE is rejected. Due to 6 we do not need this step, but it illustrates how one can match on specific message types.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Any other message with a destination is rejected. This is a good idea to ensure that you do not miss any messages.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="websocket-authorization-notes"><a class="anchor" href="#websocket-authorization-notes"></a>WebSocket Authorization Notes</h4>
<div class="paragraph">
<p>In order to properly secure your application it is important to understand Spring&#8217;s WebSocket support.</p>
</div>
<div class="sect4">
<h5 id="websocket-authorization-notes-messagetypes"><a class="anchor" href="#websocket-authorization-notes-messagetypes"></a>WebSocket Authorization on Message Types</h5>
<div class="paragraph">
<p>It is important to understand the distinction between SUBSCRIBE and MESSAGE types of messages and how it works within Spring.</p>
</div>
<div class="paragraph">
<p>Consider a chat application.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The system can send notifications MESSAGE to all users through a destination of "/topic/system/notifications"</p>
</li>
<li>
<p>Clients can receive notifications by SUBSCRIBE to the "/topic/system/notifications".</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While we want clients to be able to SUBSCRIBE to "/topic/system/notifications", we do not want to enable them to send a MESSAGE to that destination.
If we allowed sending a MESSAGE to "/topic/system/notifications", then clients could send a message directly to that endpoint and impersonate the system.</p>
</div>
<div class="paragraph">
<p>In general, it is common for applications to deny any MESSAGE sent to a message that starts with the <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp">broker prefix</a> (i.e. "/topic/" or "/queue/").</p>
</div>
</div>
<div class="sect4">
<h5 id="websocket-authorization-notes-destinations"><a class="anchor" href="#websocket-authorization-notes-destinations"></a>WebSocket Authorization on Destinations</h5>
<div class="paragraph">
<p>It is also is important to understand how destinations are transformed.</p>
</div>
<div class="paragraph">
<p>Consider a chat application.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>User&#8217;s can send messages to a specific user by sending a message to the destination of "/app/chat".</p>
</li>
<li>
<p>The application sees the message, ensures that the "from" attribute is specified as the current user (we cannot trust the client).</p>
</li>
<li>
<p>The application then sends the message to the recipient using <code>SimpMessageSendingOperations.convertAndSendToUser("toUser", "/queue/messages", message)</code>.</p>
</li>
<li>
<p>The message gets turned into the destination of "/queue/user/messages-&lt;sessionid&gt;"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With the application above, we want to allow our client to listen to "/user/queue" which is transformed into "/queue/user/messages-&lt;sessionid&gt;".
However, we do not want the client to be able to listen to "/queue/*" because that would allow the client to see messages for every user.</p>
</div>
<div class="paragraph">
<p>In general, it is common for applications to deny any SUBSCRIBE sent to a message that starts with the <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp">broker prefix</a> (i.e. "/topic/" or "/queue/").
Of course we may provide exceptions to account for things like</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-authorization-notes-outbound"><a class="anchor" href="#websocket-authorization-notes-outbound"></a>Outbound Messages</h4>
<div class="paragraph">
<p>Spring contains a section titled <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp-message-flow">Flow of Messages</a> that describes how messages flow through the system.
It is important to note that Spring Security only secures the <code>clientInboundChannel</code>.
Spring Security does not attempt to secure the <code>clientOutboundChannel</code>.</p>
</div>
<div class="paragraph">
<p>The most important reason for this is performance.
For every message that goes in, there are typically many more that go out.
Instead of securing the outbound messages, we encourage securing the subscription to the endpoints.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-sameorigin"><a class="anchor" href="#websocket-sameorigin"></a>Enforcing Same Origin Policy</h3>
<div class="paragraph">
<p>It is important to emphasize that the browser does not enforce the <a href="http://en.wikipedia.org/wiki/Same-origin_policy">Same Origin Policy</a> for WebSocket connections.
This is an extremely important consideration.</p>
</div>
<div class="sect3">
<h4 id="websocket-sameorigin-why"><a class="anchor" href="#websocket-sameorigin-why"></a>Why Same Origin?</h4>
<div class="paragraph">
<p>Consider the following scenario.
A user visits bank.com and authenticates to their account.
The same user opens another tab in their browser and visits evil.com.
The Same Origin Policy ensures that evil.com cannot read or write data to bank.com.</p>
</div>
<div class="paragraph">
<p>With WebSockets the Same Origin Policy does not apply.
In fact, unless bank.com explicitly forbids it, evil.com can read and write data on behalf of the user.
This means that anything the user can do over the websocket (i.e. transfer money), evil.com can do on that users behalf.</p>
</div>
<div class="paragraph">
<p>Since SockJS tries to emulate WebSockets it also bypasses the Same Origin Policy.
This means developers need to explicitly protect their applications from external domains when using SockJS.</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sameorigin-spring"><a class="anchor" href="#websocket-sameorigin-spring"></a>Spring WebSocket Allowed Origin</h4>
<div class="paragraph">
<p>Fortunately, since Spring 4.1.5 Spring&#8217;s WebSocket and SockJS support restricts access to the <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-server-allowed-origins">current domain</a>.
Spring Security adds an additional layer of protection to provide <a href="http://en.wikipedia.org/wiki/Defense_in_depth_%28computing%29">defence in depth</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sameorigin-csrf"><a class="anchor" href="#websocket-sameorigin-csrf"></a>Adding CSRF to Stomp Headers</h4>
<div class="paragraph">
<p>By default Spring Security requires the <a href="#csrf">CSRF token</a> in any CONNECT message type.
This ensures that only a site that has access to the CSRF token can connect.
Since only the <strong>Same Origin</strong> can access the CSRF token, external domains are not allowed to make a connection.</p>
</div>
<div class="paragraph">
<p>Typically we need to include the CSRF token in an HTTP header or an HTTP parameter.
However, SockJS does not allow for these options.
Instead, we must include the token in the Stomp headers</p>
</div>
<div class="paragraph">
<p>Applications can <a href="#csrf-include-csrf-token">obtain a CSRF token</a> by accessing the request attribute named _csrf.
For example, the following will allow accessing the <code>CsrfToken</code> in a JSP:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">var headerName = "${_csrf.headerName}";
var token = "${_csrf.token}";</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using static HTML, you can expose the <code>CsrfToken</code> on a REST endpoint.
For example, the following would expose the <code>CsrfToken</code> on the URL /csrf</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
public class CsrfController {

    @RequestMapping("/csrf")
    public CsrfToken csrf(CsrfToken token) {
        return token;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The javascript can make a REST call to the endpoint and use the response to populate the headerName and the token.</p>
</div>
<div class="paragraph">
<p>We can now include the token in our Stomp client.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">...
var headers = {};
headers[headerName] = token;
stompClient.connect(headers, function(frame) {
  ...

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sameorigin-disable"><a class="anchor" href="#websocket-sameorigin-disable"></a>Disable CSRF within WebSockets</h4>
<div class="paragraph">
<p>If you want to allow other domains to access your site, you can disable Spring Security&#8217;s protection.
For example, in Java Configuration you can use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    ...

    @Override
    protected boolean sameOriginDisabled() {
        return true;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-sockjs"><a class="anchor" href="#websocket-sockjs"></a>Working with SockJS</h3>
<div class="paragraph">
<p><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-fallback">SockJS</a> provides fallback transports to support older browsers.
When using the fallback options we need to relax a few security constraints to allow SockJS to work with Spring Security.</p>
</div>
<div class="sect3">
<h4 id="websocket-sockjs-sameorigin"><a class="anchor" href="#websocket-sockjs-sameorigin"></a>SockJS &amp; frame-options</h4>
<div class="paragraph">
<p>SockJS may use an <a href="https://github.com/sockjs/sockjs-client/tree/v0.3.4">transport that leverages an iframe</a>.
By default Spring Security will <a href="#headers-frame-options">deny</a> the site from being framed to prevent Clickjacking attacks.
To allow SockJS frame based transports to work, we need to configure Spring Security to allow the same origin to frame the content.</p>
</div>
<div class="paragraph">
<p>You can customize X-Frame-Options with the <a href="#nsa-frame-options">frame-options</a> element.
For example, the following will instruct Spring Security to use "X-Frame-Options: SAMEORIGIN" which allows iframes within the same domain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;frame-options
          policy="SAMEORIGIN" /&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, you can customize frame options to use the same origin within Java Configuration using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
   WebSecurityConfigurerAdapter {

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
      // ...
      .headers()
        .frameOptions()
            .sameOrigin();
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sockjs-csrf"><a class="anchor" href="#websocket-sockjs-csrf"></a>SockJS &amp; Relaxing CSRF</h4>
<div class="paragraph">
<p>SockJS uses a POST on the CONNECT messages for any HTTP based transport.
Typically we need to include the CSRF token in an HTTP header or an HTTP parameter.
However, SockJS does not allow for these options.
Instead, we must include the token in the Stomp headers as described in <a href="#websocket-sameorigin-csrf">Adding CSRF to Stomp Headers</a>.</p>
</div>
<div class="paragraph">
<p>It also means we need to relax our CSRF protection with the web layer.
Specifically, we want to disable CSRF protection for our connect URLs.
We do NOT want to disable CSRF protection for every URL.
Otherwise our site will be vulnerable to CSRF attacks.</p>
</div>
<div class="paragraph">
<p>We can easily achieve this by providing a CSRF RequestMatcher.
Our Java Configuration makes this extremely easy.
For example, if our stomp endpoint is "/chat" we can disable CSRF protection for only URLs that start with "/chat/" using the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig
    extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {

        http
            .csrf()
                // ignore our stomp endpoints since they are protected using Stomp headers
                .ignoringAntMatchers("/chat/**")
                .and()
            .headers()
                // allow same origin to frame our site to support iframe SockJS
                .frameOptions().sameOrigin()
                .and()
            .authorizeRequests()

            ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are using XML based configuration, we can use the <a href="#nsa-csrf-request-matcher-ref">csrf@request-matcher-ref</a>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http ...&gt;
    &lt;csrf request-matcher-ref="csrfMatcher"/&gt;

    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;

    ...
&lt;/http&gt;

&lt;b:bean id="csrfMatcher"
    class="AndRequestMatcher"&gt;
    &lt;b:constructor-arg value="#{T(org.springframework.security.web.csrf.CsrfFilter).DEFAULT_CSRF_MATCHER}"/&gt;
    &lt;b:constructor-arg&gt;
        &lt;b:bean class="org.springframework.security.web.util.matcher.NegatedRequestMatcher"&gt;
          &lt;b:bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher"&gt;
            &lt;b:constructor-arg value="/chat/**"/&gt;
          &lt;/b:bean&gt;
        &lt;/b:bean&gt;
    &lt;/b:constructor-arg&gt;
&lt;/b:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="authorization" class="sect0"><a class="anchor" href="#authorization"></a>授权</h1>
<div class="paragraph">
<p>在Spring Security的高级授权功能是其受欢迎的最有说服力的原因之一，无论您如何选择如何进行身份验证-是否使用提供的机制和提供程序的Spring Security，或整合与一个容器或其他non-Spring Security 认证机构-你会发现授权服务可以在您的应用程序中使用一个一致的和简单的方式.</p>
</div>
<div class="paragraph">
<p>在这一部分我们将探讨不同的` abstractsecurityinterceptor `实现,在第一部分介绍.然后，我们将继续探索如何通过使用域访问控制列表微调授权.</p>
</div>
<div class="sect1">
<h2 id="authz-arch"><a class="anchor" href="#authz-arch"></a>授权体系结构</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="authz-authorities"><a class="anchor" href="#authz-authorities"></a>授权</h3>
<div class="paragraph">
<p>正如我们在&lt;&lt;技术授予权，技术综述 &gt;&gt;所看到，所有的<code>Authentication</code>实现存储的列表<code>GrantedAuthority</code>对象.这些代表已被授予主要的的当局. <code>GrantedAuthority</code>对象是由` authenticationManager <code>插入到`Authentication</code> 对象，然后读取 <code>AccessDecisionManager</code>做出判断.</p>
</div>
<div class="paragraph">
<p><code>GrantedAuthority</code>是一个只有一个方法的接口</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String getAuthority();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个方法允许<code>AccessDecisionManager</code> 来判断得到一个精确的<code>String</code>表示的` GrantedAuthority <code>.通过返回一个表示作为一个`String</code>,一个` GrantedAuthority <code>可以很容易的通过`AccessDecisionManager</code> 来<code>read</code>,如果一个` GrantedAuthority <code>不能精确地表示为一个`String</code>,` GrantedAuthority <code>将会被认为是"complex"和`getAuthority()</code> 必须返回为<code>null</code>.</p>
</div>
<div class="paragraph">
<p>"complex" <code>GrantedAuthority</code>的一个将一个应用于不同客户帐户号码的操作和权限阈值的列表的实现例子.代表这个复杂的` GrantedAuthority <code>作为`String</code>将是相当困难的，作为一个结果，` getauthority() <code>方法应该返回`null</code>.这将对任何` accessDecisionManager <code>表明它需要明确的支持</code> GrantedAuthority `实施以了解其内容.</p>
</div>
<div class="paragraph">
<p>Spring Security包括一个具体的` GrantedAuthority <code>实施，</code> grantedauthorityimpl <code>.这允许用户指定的任何String</code>转换成一种` GrantedAuthority <code>.所有的</code> AuthenticationProvider <code>的包括与安全架构使用</code> grantedauthorityimpl`填充<code>Authentication</code>对象.</p>
</div>
</div>
<div class="sect2">
<h3 id="authz-pre-invocation"><a class="anchor" href="#authz-pre-invocation"></a>Pre-Invocation处理</h3>
<div class="paragraph">
<p>正如我们在&lt;&lt;安全对象、技术综述&gt;&gt;章节中也看到过的,Spring Security,提供拦截控制访问安全对象如方法调用或Web请求。是否允许进行调用前调用的决定是由`AccessDecisionManager `作出判断.</p>
</div>
</div>
<div class="sect2">
<h3 id="authz-access-decision-manager"><a class="anchor" href="#authz-access-decision-manager"></a>访问决策管理器</h3>
<div class="paragraph">
<p>` accessDecisionManager <code>被</code> abstractsecurityinterceptor <code>和负责制定最终的访问控制决策.`AccessDecisionManager</code>接口包含三种方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">void decide(Authentication authentication, Object secureObject,
	Collection&lt;ConfigAttribute&gt; attrs) throws AccessDeniedException;

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AccessDecisionManager</code>的<code>decide</code>方法传递了它所需要的所有相关信息，以作出授权决策.尤其,通过安全的“对象”，使这些参数包含在实际的安全对象调用中进行检查.例如,让我们假设安全对象是一个<code>MethodInvocation `资料，这将是很容易实现`MethodInvocation</code>对于任何<code>Customer</code>论点.然后执行某种安全逻辑判断、来确保<code>AccessDecisionManager `主允许对客户操作.如果访问被拒绝并抛出`AccessDeniedException</code> 我们的预期就实现了.</p>
</div>
<div class="paragraph">
<p>如果` accessDecisionManager <code>可以处理通过</code> configattribute <code>,`supports(ConfigAttribute)</code>方法由<code>AbstractSecurityInterceptor</code> 在决定启动时候命名.
 <code>supports(Class)</code> 方法被安全拦截器实现，确保配置` accessDecisionManager `支持类型的安全对象的被拦截.</p>
</div>
<div class="sect3">
<h4 id="authz-voting-based"><a class="anchor" href="#authz-voting-based"></a>Voting-Based访问决策管理器实现</h4>
<div class="paragraph">
<p>同时，用户可以实现自己的` AccessDecisionManager`判断、控制授权的所有方面,Spring Security包括几个基于投票的` accessDecisionManager `实现. <a href="#authz-access-voting">Voting Decision Manager</a>说明相关类.</p>
</div>
<div id="authz-access-voting" class="imageblock">
<div class="content">
<img src="images/access-decision-voting.png" alt="access decision voting.png">
</div>
<div class="title">Figure 2. Voting Decision Manager</div>
</div>
<div class="paragraph">
<p>使用这种方法，一系列的` accessdecisionvoter <code>实现调查授权决策.</code> accessDecisionManager <code>然后决定是否抛出</code> accessdeniedexception `基于其选票的评估。</p>
</div>
<div class="paragraph">
<p><code>AccessDecisionVoter</code>接口包含三种方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">int vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attrs);

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);</code></pre>
</div>
</div>
<div class="paragraph">
<p>具体返回一个<code>int</code>，可能反映在` accessdecisionvoter <code>的静态字段</code> access_abstain <code>，</code> access_denied <code>和</code> access_granted <code>.如果对授权决策没有意见一个投票的实施将返回</code> access_abstain <code>. 如果真的有一个观点，它必须返回</code> access_denied <code>或</code> access_granted `.</p>
</div>
<div class="paragraph">
<p>这里三个具体的<code>AccessDecisionManager</code>提供了符合投票的 Spring Security,` consensusbased <code>实施将授予或拒绝基于非共识的弃权票的访问.提供的属性来控制在一个平等的投票活动的行为，或者如果所有的选票都弃权.</code> affirmativebased <code>实施将会授权访问如果你个或者更多的`ACCESS_GRANTED</code> 投票被收到（即使投票被忽略，也至少有一个投票）.像“ConsensusBased”实现,有一个参数,控制行为如果所有选民弃权.<code>UnanimousBased</code>的提供者预计一致<code>ACCESS_GRANTED</code>的选票以授予访问权限,忽略了自制。它会拒绝访问如果有任何“ACCESS_DENIED”投票.像其他实现,有一个参数,控制行为如果所有选民弃权.</p>
</div>
<div class="paragraph">
<p>可以实现自定义` accessDecisionManager <code>计算选票不同。例如，从一个特定的</code> accessdecisionvoter `可能会得到额外的加权投票，而否认从一个特定的选民投票可能有否决权的影响.</p>
</div>
<div class="sect4">
<h5 id="authz-role-voter"><a class="anchor" href="#authz-role-voter"></a>角色选民</h5>
<div class="paragraph">
<p>最常用的由Spring Security提供的<code>AccessDecisionVoter</code> 是简单的<code>RoleVoter</code>,如果用户已被分配该角色,将配置属性视为简单的角色名称和投票授予访问权限.</p>
</div>
<div class="paragraph">
<p>如果<code>ConfigAttribute</code> 带着前缀<code>ROLE_</code>开始将会进行投票，它将投票授予访问权限，如果有` GrantedAuthority <code>它返回一个`String</code>表示(通过` getauthority() <code>方法)恰好等于一个或多个从前缀</code> role_ <code>的</code> configattributes <code>.如果没有从</code> role_ <code>精确匹配任何</code> configattribute <code>，</code> rolevoter <code>会投票拒绝访问。如果</code> role_ <code>没有开始</code> configattribute `，选民将投弃权票。</p>
</div>
</div>
<div class="sect4">
<h5 id="authz-authenticated-voter"><a class="anchor" href="#authz-authenticated-voter"></a>经过身份验证的选民</h5>
<div class="paragraph">
<p>另一个选民,我们从 <code>AuthenticatedVoter</code>看到，可以用来区分匿名，fully-authenticated,记得我通过身份验证的用户，许多网站允许某些有限的访问在记得我认证,但是需要用户确认他们的身份登录的完全访问.当我们使用属性IS_AUTHENTICATED_ANONYMOUSLY授予匿名访问,这个属性是由“AuthenticatedVoter”进行处理。有关更多信息,请参见这个类的Javadoc.</p>
</div>
</div>
<div class="sect4">
<h5 id="authz-custom-voter"><a class="anchor" href="#authz-custom-voter"></a>定制的选民</h5>
<div class="paragraph">
<p>显然,您还可以实现自定义“AccessDecisionVoter”,你可以把任何你想要访问控制逻辑.这可能是特定于应用程序(业务逻辑相关)或可能实现一些安全管理逻辑，例如你会发现
<a href="http://spring.io/blog/2009/01/03/spring-security-customization-part-2-adjusting-secured-session-in-real-time"> blog article</a> 在Spring web网站描述如何使用实时选民拒绝访问用户的账户被暂停.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="authz-after-invocation-handling"><a class="anchor" href="#authz-after-invocation-handling"></a>调用处理</h3>
<div class="paragraph">
<p>而“AccessDecisionManager”是由“AbstractSecurityInterceptor”在继续之前调用安全对象调用.某些应用程序需要一种方法修改对象的实际安全返回的对象调用.同时您可以很容易地实现自己的AOP实现这一担忧, Spring Security提供了一个方便的钩,几个集成ACL的功能的具体实现.</p>
</div>
<div class="paragraph">
<p><a href="#authz-after-invocation">After Invocation Implementation</a>说明了Spring Security的<code>AfterInvocationManager</code> 以及这个具体实现.</p>
</div>
<div id="authz-after-invocation" class="imageblock">
<div class="content">
<img src="images/after-invocation.png" alt="after invocation.png">
</div>
<div class="title">Figure 3. After Invocation Implementation</div>
</div>
<div class="paragraph">
<p>像Spring Security的其他部分，<code>AfterInvocationManager</code> 有一个具体的实现，<code>AfterInvocationProviderManager</code>调查<code>AfterInvocationProvider</code>的表，每一个<code>AfterInvocationProvider</code>允许修改返回对象或抛出<code>AccessDeniedException</code>.的确多个提供者可以修改对象,如之前的供应商的结果传递给下一个列表中.</p>
</div>
<div class="paragraph">
<p>请注意,如果您正在使用<code>AfterInvocationManager</code>,你仍然需要配置属性,使<code>MethodSecurityInterceptor</code>的<code>AccessDecisionManager</code>允许一个操作.如果您使用的是典型的Spring Security包括“AccessDecisionManager”实现,没有配置属性定义为一个特定的安全方法调用将导致每个“AccessDecisionVoter”投弃权票,相反,如果<code>AccessDecisionManager</code> 性能  &#8220;allow IfAllAbstainDecisions&#8221;是<code>false</code>就会抛出一个 <code>AccessDeniedException</code>，你可以通过设置&#8220;allowIfAllAbstainDecisions&#8221;避免这种潜在的问题改变为<code>true</code>（虽然这是一般不推荐），或者（ii）只是确保至少有一个配置属性,一个“AccessDecisionVoter”将投票授权访问，后者(推荐)的方法通常是通过“ROLE_USER”或“ROLE_AUTHENTICATED”配置属性.</p>
</div>
</div>
<div class="sect2">
<h3 id="authz-hierarchical-roles"><a class="anchor" href="#authz-hierarchical-roles"></a>层次的角色</h3>
<div class="paragraph">
<p>它是一个共同的要求，一个特定的应用程序中的角色应该自动"include"其他角色,例如，在一个应用程序中有一个"admin" 和"user"的角色的概念,你可能希望一个管理员能够尽一切正常的用户可以。要做到这一点，你可以确保所有的管理用户也被分配到"user"的角色.另外，您可以修改每一个访问约束，这需要"user"的角色，还包括"admin"的作用.这可能会变得相当复杂，如果你有很多不同的角色在你的应用程序.</p>
</div>
<div class="paragraph">
<p>使用角色层次结构允许您配置哪些角色（或主管）应包括其他角色（或主管部门）.一个额外的of Spring Security&#8217;s <a href="#authz-role-voter">RoleVoter</a>的版本，<code>RoleHierarchyVoter</code>配置了一个` rolehierarchy `，从它获得所有的"reachable authorities"，用户被分配。一个典型的配置可能看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="roleVoter" class="org.springframework.security.access.vote.RoleHierarchyVoter"&gt;
	&lt;constructor-arg ref="roleHierarchy" /&gt;
&lt;/bean&gt;
&lt;bean id="roleHierarchy"
		class="org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"&gt;
	&lt;property name="hierarchy"&gt;
		&lt;value&gt;
			ROLE_ADMIN &gt; ROLE_STAFF
			ROLE_STAFF &gt; ROLE_USER
			ROLE_USER &gt; ROLE_GUEST
		&lt;/value&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们有四个角色在一个层次结构 <code>ROLE_ADMIN &#8658; ROLE_STAFF &#8658; ROLE_USER &#8658; ROLE_GUEST</code>.通过身份验证的用户<code>ROLE_ADMIN</code>, 要表现得好像他们所有的四种角色在安全约束的评价与判断,要表现得好像他们所有的四种角色在安全约束的评价与判断,<code>AccessDecisionManager</code> 配置上述<code>RoleHierarchyVoter</code>.<code>&gt;</code>符号可以被认为是意义的"includes".</p>
</div>
<div class="paragraph">
<p>角色层次结构提供了一个方便的方法简化了您的应用程序的访问控制配置数据和/或减少您需要分配给用户的权限数.对于更复杂的要求，您可能希望定义您的应用程序所需的特定访问权限和被分配给用户的角色之间的逻辑映射，在加载用户信息时将两者翻译成两者之间的关系.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="secure-object-impls"><a class="anchor" href="#secure-object-impls"></a>安全对象的实现</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="aop-alliance"><a class="anchor" href="#aop-alliance"></a>AOP联盟(方法调用)安全拦截器</h3>
<div class="literalblock">
<div class="content">
<pre>Spring Security 2.0之前,确保`MethodInvocation`资料需要相当多的配置.现在方法安全的推荐方法是使用&lt; &lt;ns-method-security,namespace configuration&gt;&gt;.这种方法的安全基础设施beans是为您自动配置的，所以您不需要知道实现类的情况。我们将提供一个在这里涉及的类的快速概述。</pre>
</div>
</div>
<div class="paragraph">
<p>方法在执行安全使用` methodsecurityinterceptor <code>,这是一个固定的`MethodInvocation</code> .根据配置的方法，一个拦截可能是特定的一个单一的bean或多个beans之间的共享.拦截器使用` methodsecuritymetadatasource <code>实例获取配置属性，适用于一个特定的方法调用.`MapBasedMethodSecurityMetadataSource</code>用于存储配置属性的键控的方法名称（可以使用通配符），将在内部使用时，这些属性定义在应用程序的上下文中使用的<code>&lt;intercept-methods&gt;</code>拦截或<code>&lt;protect-point&gt;</code>元素。</p>
</div>
<div class="paragraph">
<p>当然你可以使用一个Spring AOP的代理机制配置一个` methodsecurityiterceptor `直接应用程序上下文中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="bankManagerSecurity" class=
	"org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
&lt;property name="afterInvocationManager" ref="afterInvocationManager"/&gt;
&lt;property name="securityMetadataSource"&gt;
	&lt;sec:method-security-metadata-source&gt;
	&lt;sec:protect method="com.mycompany.BankManager.delete*" access="ROLE_SUPERVISOR"/&gt;
	&lt;sec:protect method="com.mycompany.BankManager.getBalance" access="ROLE_TELLER,ROLE_SUPERVISOR"/&gt;
	&lt;/sec:method-security-metadata-source&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aspectj"><a class="anchor" href="#aspectj"></a>AspectJ(连接点)安全拦截器</h3>
<div class="paragraph">
<p>AspectJ的安全拦截器是AOP联盟安全拦截器在上一节讨论非常相似。事实上，我们将只讨论在这一部分的差异.</p>
</div>
<div class="paragraph">
<p>AspectJ拦截器被命名为 <code>AspectJSecurityInterceptor</code>.不像AOP联盟安全拦截器，它依赖于Spring应用程序上下文编织的安全拦截器通过代理,<code>AspectJSecurityInterceptor</code>是基于AspectJ编译器.不会罕见的在同一个程序中使用的两种安全拦截器,与<code>AspectJSecurityInterceptor</code>用于域对象实例安全,AOP联盟` methodsecurityinterceptor `用于服务层安全.</p>
</div>
<div class="paragraph">
<p>让我们首先考虑的是如何<code>AspectJSecurityInterceptor</code>配置在Spring应用程序上下文：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="bankManagerSecurity" class=
	"org.springframework.security.access.intercept.aspectj.AspectJMethodSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
&lt;property name="afterInvocationManager" ref="afterInvocationManager"/&gt;
&lt;property name="securityMetadataSource"&gt;
	&lt;sec:method-security-metadata-source&gt;
	&lt;sec:protect method="com.mycompany.BankManager.delete*" access="ROLE_SUPERVISOR"/&gt;
	&lt;sec:protect method="com.mycompany.BankManager.getBalance" access="ROLE_TELLER,ROLE_SUPERVISOR"/&gt;
	&lt;/sec:method-security-metadata-source&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的，除了类名称，<code>AspectJSecurityInterceptor</code>是完全一样的AOP联盟安全拦截器.事实上，两个拦截器可以共享相同的` securitymetadatasource <code>,作为</code> securitymetadatasource <code>作品 `java.lang.reflect.Method</code>而不是AOP库类。当然,你访问的决定获得有关特定AOP库调用（即` MethodInvocation <code>或`JoinPoint</code>），这样可以使访问的决定时，考虑的范围之外的标准（如方法的参数）.</p>
</div>
<div class="paragraph">
<p>下次你需要定义一个AspectJ <code>aspect</code>.例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.security.samples.aspectj;

import org.springframework.security.access.intercept.aspectj.AspectJSecurityInterceptor;
import org.springframework.security.access.intercept.aspectj.AspectJCallback;
import org.springframework.beans.factory.InitializingBean;

public aspect DomainObjectInstanceSecurityAspect implements InitializingBean {

	private AspectJSecurityInterceptor securityInterceptor;

	pointcut domainObjectInstanceExecution(): target(PersistableEntity)
		&amp;&amp; execution(public * *(..)) &amp;&amp; !within(DomainObjectInstanceSecurityAspect);

	Object around(): domainObjectInstanceExecution() {
		if (this.securityInterceptor == null) {
			return proceed();
		}

		AspectJCallback callback = new AspectJCallback() {
			public Object proceedWithObject() {
				return proceed();
			}
		};

		return this.securityInterceptor.invoke(thisJoinPoint, callback);
	}

	public AspectJSecurityInterceptor getSecurityInterceptor() {
		return securityInterceptor;
	}

	public void setSecurityInterceptor(AspectJSecurityInterceptor securityInterceptor) {
		this.securityInterceptor = securityInterceptor;
	}

	public void afterPropertiesSet() throws Exception {
		if (this.securityInterceptor == null)
			throw new IllegalArgumentException("securityInterceptor required");
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中，安全拦截器将被应用到每一个实例` persistableentity <code>，这是一个抽象类没有显示（你可以使用任何其他类或`pointcut</code>表达你喜欢）.对于那些好奇的人，` aspectjcallback <code>是因为</code> proceed()；<code>声明具有特殊的意义只有在</code> around() <code>体。当它想要的目标继续,`AspectJSecurityInterceptor</code> 调用这个匿名` aspectjcallback `类.</p>
</div>
<div class="paragraph">
<p>你需要配置Spring 负载方面和连接<code>AspectJSecurityInterceptor</code>。一个实现这一的bean声明如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="domainObjectInstanceSecurityAspect"
	class="security.samples.aspectj.DomainObjectInstanceSecurityAspect"
	factory-method="aspectOf"&gt;
&lt;property name="securityInterceptor" ref="bankManagerSecurity"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>是这么回事！现在你可以从你的应用程序中的任何地方创建你的豆子，使用任何你认为合适的方式(eg <code>new Person();</code>)他们会拥有安全拦截器的应用</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="el-access"><a class="anchor" href="#el-access"></a>表达式的访问控制</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 3.0介绍了使用的能力，作为一个授权机制，除了简单的使用配置属性和访问决策的选民，以前见过的使用弹簧的表达。基于表达式的访问控制是建立在相同的架构，但允许复杂的布尔逻辑被封装在一个单一的表达.</p>
</div>
<div class="sect2">
<h3 id="true--23"><a class="anchor" href="#true--23"></a>概述</h3>
<div class="paragraph">
<p>Spring Security 使用Spring EL来支持，你应该看看如何，如果你有兴趣在更深入了解主题。表达式是用"root object" 评估的，作为评价上下文的一部分。Spring Security使用特定的类用于Web和方法安全作为根对象，以提供内置表达式和访问当前主体的值等.</p>
</div>
<div class="sect3">
<h4 id="el-common-built-in"><a class="anchor" href="#el-common-built-in"></a>常见的内置的表达式</h4>
<div class="paragraph">
<p>表达根对象的基类是` securityexpressionroot `.这提供了一些常见的表达式，可应用在网络和方法安全性.</p>
</div>
<table id="common-expressions" class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. Common built-in expressions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">表达</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasRole([role])</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前主体具有指定的角色，则返回<code>true</code>.默认情况下，如果提供的角色不从'ROLE_'这里提供,这将增加。这可以通过修改` defaultroleprefix <code>在</code> defaultwebsecurityexpressionhandler `配置.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAnyRole([role1,role2])</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串列表）的话，返回<code>true</code>,默认情况下，如果提供的角色不从 'ROLE_',这将增加。这可以通过修改` defaultroleprefix <code>在</code> defaultwebsecurityexpressionhandler `定制.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAuthority([authority])</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前的主体具有指定的权限，则返回 <code>true</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAnyAuthority([authority1,authority2])</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串列表）的话，返回<code>true</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许直接访问表示当前用户的主对象</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>authentication</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许直接访问从<code>SecurityContext</code>得出当前的<code>Authentication</code>对象</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>permitAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">总是评估为<code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>denyAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">总是评估为<code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isAnonymous()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前的主体是一个匿名用户，则返回<code>true</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isRememberMe()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前的主体是一个匿名用户，则返回<code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isAuthenticated()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果用户不是匿名的，则返回 <code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isFullyAuthenticated()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果用户不是一个匿名的或是一个记住我的用户返回<code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasPermission(Object target, Object permission)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果用户已访问给定权限的提供的目标，则返回<code>true</code>，例如<code>hasPermission(domainObject, 'read')</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasPermission(Object targetId, String targetType, Object permission)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果用户已访问给定权限的提供的目标，则返回<code>true</code>,例如<code>hasPermission(1, 'com.example.domain.Message', 'read')</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="el-access-web"><a class="anchor" href="#el-access-web"></a>Web Security Expressions</h3>
<div class="paragraph">
<p>使用表达式来保护个人网址,首先需要设置“use-expressions”属性的&lt; http &gt;为<code>true</code>.Spring Security预期的“访问”属性的&lt; intercept-url &gt;元素包含Spring EL表达式。一个布尔表达式应该评估,定义是否应该允许访问.
例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/admin*"
		access="hasRole('admin') and hasIpAddress('192.168.1.0/24')"/&gt;
	...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们定义了应用程序的“admin”区域(定义的URL模式)只能提供给用户授予机关“admin”,其IP地址匹配本地子网.在前一节中我们已经看到内置hasRole表达式。表达“hasIpAddress”是另一个内置的表达式是特定于网络安全.这由<code>WebSecurityExpressionRoot</code>下定义，一个实例时用作表达式根对象评估web访问表达式。这个对象也直接暴露的HttpServletRequest对象的名字“请求”,这样你就可以直接调用请求在一个表达式。如果正在使用表情,“WebExpressionVoter”将被添加到“AccessDecisionManager”所使用的名称空间.
如果你不使用名称空间和想使用表情,你必须添加一个配置.</p>
</div>
<div class="sect3">
<h4 id="el-access-web-beans"><a class="anchor" href="#el-access-web-beans"></a>在网络安全bean表达式</h4>
<div class="paragraph">
<p>如果你想扩展表达式可用,您可以很容易地操作任何你暴露的Spring Bean。例如,assumming你有一个Bean的名称“webSecurity”包含以下方法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class WebSecurity {
		public boolean check(Authentication authentication, HttpServletRequest request) {
				...
		}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以参考使用方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/user/**"
		access="@webSecurity.check(authentication,request)"/&gt;
	...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在Java配置</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">http
		.authorizeRequests()
				.antMatchers("/user/**").access("@webSecurity.check(authentication,request)")
				...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="el-access-web-path-variables"><a class="anchor" href="#el-access-web-path-variables"></a>Path Variables in Web Security Expressions</h4>
<div class="paragraph">
<p>有时在一个URL它很好能够参考路径变量.
例如,考虑一个RESTful应用程序从URL路径的格式查找用户id`/user/{userId}`.</p>
</div>
<div class="paragraph">
<p>你可以很容易地将参考路径变量的模式.例如,如果你有一个Bean的名称“webSecurity”包含以下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class WebSecurity {
		public boolean checkUserId(Authentication authentication, int id) {
				...
		}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以参考使用方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/user/{userId}/**"
		access="@webSecurity.checkUserId(authentication,#userId)"/&gt;
	...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在Java配置</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">http
		.authorizeRequests()
				.antMatchers("/user/{userId}/**").access("@webSecurity.checkUserId(authentication,#userId)")
				...</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两个配置相匹配的url将通过path变量(和)转换成checkUserId方法.</p>
</div>
<div class="paragraph">
<p>例如,如果这个URLs是 <code>/user/123/resource</code>,id是<code>123</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truemethod-security-expressions"><a class="anchor" href="#truemethod-security-expressions"></a>Method Security Expressions</h3>
<div class="paragraph">
<p>方法安全性是一个更复杂的比一个简单的规则允许或拒绝，Spring Security 3.0介绍了一些新的注释,以便全面支持表达式的使用.</p>
</div>
<div class="sect3">
<h4 id="el-pre-post-annotations"><a class="anchor" href="#el-pre-post-annotations"></a>@Pre and @Post Annotations</h4>
<div class="paragraph">
<p>有四个属性注释支持表达式允许pre和post-invocation授权检查并提交支持过滤收集参数或返回值.他们是<code>@PreAuthorize</code>, <code>@PreFilter</code>, <code>@PostAuthorize</code> and <code>@PostFilter</code>. 它们的使用是通过“global-method-security”名称空间的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security pre-post-annotations="enabled"/&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="true-preauthorize-postauthorize-preauthorize-contacts"><a class="anchor" href="#true-preauthorize-postauthorize-preauthorize-contacts"></a>使用@PreAuthorize和@PostAuthorize访问控制,最明显的是有用的注释是“@PreAuthorize”决定是否可以被调用方法。例如(从"Contacts"示例应用程序)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasRole('USER')")
public void create(Contact contact);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着用户与角色"ROLE_USER"才会允许访问.显然同样的事情可以很容易地通过使用传统的配置和一个简单的配置属性所需的角色:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasPermission(#contact, 'admin')")
public void deletePermission(Contact contact, Sid recipient, Permission permission);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们使用一个方法参数的表达式来决定当前用户是否有"admin"允许给定的接触。内置的<code>hasPermission()</code>表达式是通过应用程序上下文链接到Spring Security ACL模块,<a href="#el-permission-evaluator">see below</a>,你可以访问任何变量名称作为方法参数的表达式.</p>
</div>
<div class="paragraph">
<p>有很多方式Spring Security可以解决方法参数。Spring Security使用DefaultSecurityParameterNameDiscoverer发现参数名称。默认情况下,下列选项尝试方法作为一个整体.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果Spring Security的@P注释存在一个参数的方法,将使用价值。这是使用JDK JDK 8之前有用的接口,编译不包含任何有关参数名称的信息。例如:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.security.access.method.P;

...

@PreAuthorize("#c.name == authentication.name")
public void doSomething(@P("c") Contact contact);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在幕后使用使用“AnnotationParameterNameDiscoverer”可实现自定义支持value属性指定的任何注释.</p>
</div>
</li>
<li>
<p>如果Spring Data'的@Param注释存在至少一个参数的方法,将使用价值。这是使用JDK JDK 8之前有用的接口,编译不包含任何有关参数名称的信息。例如:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.data.repository.query.Param;

...

@PreAuthorize("#n == authentication.name")
Contact findContactByName(@Param("n") String name);</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>在幕后使用使用“AnnotationParameterNameDiscoverer”可实现自定义支持value属性指定的任何注释.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果JDK 8是用来编译源参数的参数和使用Spring 4+,那么标准JDK反射API用于发现参数名称。这包含两类和接口工作.</p>
</li>
<li>
<p>最后,如果代码编译与调试符号,参数名称将被发现使用调试符号。这不会为接口工作,因为他们没有调试信息参数名称。为接口,必须使用注释或JDK 8的方法.</p>
</li>
</ul>
</div>
<div class="openblock">
<div class="title"><a id="el-pre-post-annotations-spel"></a></div><div class="content">
<div class="paragraph">
<p>任何Spring-EL功能可在表达,所以你也可以访问属性参数。举个例子,如果你想要一个特定方法只允许一个用户访问的用户名匹配的接触,你可以写</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PreAuthorize("#contact.name == authentication.name")
public void doSomething(Contact contact);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们访问另一个内置的表情, <code>authentication</code>,也就是 <code>Authentication</code>存储在安全上下文。您也可以直接访问它的<code>principal</code>属性,使用表达式<code>principal</code>。值往往会是一个“UserDetails”实例,所以你可能会使用一个表达式<code>principal.username</code>或“principal.enabled”.</p>
</div>
<div class="openblock">
<div class="title"><a id="el-pre-post-annotations-post"></a></div><div class="content">
<div class="paragraph">
<p>一般,您可能希望执行访问控制检查方法调用之后。这可以通过使用@PostAuthorize注释.访问一个方法的返回值,使用内置的名字“returnObject”的表示</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="true-prefilter-and-postfilter"><a class="anchor" href="#true-prefilter-and-postfilter"></a>过滤用@PreFilter and @PostFilter</h5>
<div class="paragraph">
<p>正如你可能已经知道,Spring Security支持集合和数组的过滤,这可以通过使用表达式。这是最常见的一个方法的返回值上执行。例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasRole('USER')")
@PostFilter("hasPermission(filterObject, 'read') or hasPermission(filterObject, 'admin')")
public List&lt;Contact&gt; getAll();</code></pre>
</div>
</div>
<div class="paragraph">
<p>当用<code>@PostFilter</code> 注释,Spring Security遍历返回的集合并删除任何元素提供的表达式是错误的。“filterObject”指的是当前的对象的集合。你还可以过滤方法调用之前,使用“@PreFilter”,尽管这是一个不太常见的需求。语法是相同的,但是如果有一个以上的论证它是一个集合类型然后你必须选择一个的名字使用“filterTarget”属性的注释.</p>
</div>
<div class="paragraph">
<p>注意,过滤显然是不能代替调优数据检索查询。如果你是过滤大收藏和删除的条目,那么这可能是低效的.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="el-method-built-in"><a class="anchor" href="#el-method-built-in"></a>内置的表达式</h4>
<div class="paragraph">
<p>有一些内置的表达式具体方法安全,我们已经看到在上面使用。<code>filterTarget</code> 和<code>returnValue</code>值是很简单,但使用<code>hasPermission()</code>的表达式权证更仔细的观察.</p>
</div>
<div class="sect4">
<h5 id="el-permission-evaluator"><a class="anchor" href="#el-permission-evaluator"></a>许可评估者接口</h5>
<div class="paragraph">
<p><code>hasPermission()</code>的表达式是委托给一个实例的<code>PermissionEvaluator</code>.它旨在表达系统和Spring Security的ACL系统之间的桥梁,允许您指定授权约束域对象,基于抽象的权限.没有显式的依赖ACL模块,所以你可以互换,如果需要另一个实现。接口有两个方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">boolean hasPermission(Authentication authentication, Object targetDomainObject,
							Object permission);

boolean hasPermission(Authentication authentication, Serializable targetId,
							String targetType, Object permission);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这直接映射到可用的版本的表情,除了那第一个参数( <code>Authentication</code> 的对象)是不提供的。首先是在域对象的情况下,使用的访问控制,已经加载。然后表达式将返回true,如果当前用户拥有该对象的批准。第二个版本是用于装载情况下,对象不是,但是它的标识符。域对象的抽象的"type"说明符也是必需的,允许加载正确的ACL权限。这历来是对象的Java类,但是这不是必须的，只要符合权限如何加载就可以.</p>
</div>
<div class="paragraph">
<p>使用“hasPermission()的表情,必须在您的应用程序上下文配置一个PermissionEvaluator”.这看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;security:global-method-security pre-post-annotations="enabled"&gt;
&lt;security:expression-handler ref="expressionHandler"/&gt;
&lt;/security:global-method-security&gt;

&lt;bean id="expressionHandler" class=
"org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler"&gt;
	&lt;property name="permissionEvaluator" ref="myPermissionEvaluator"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在“myPermissionEvaluator”是实现“PermissionEvaluator”bean。通常这将从ACL实现模块叫做“AclPermissionEvaluator”。见"Contacts"示例应用程序配置更多的细节.</p>
</div>
</div>
<div class="sect4">
<h5 id="true--24"><a class="anchor" href="#true--24"></a>方法安全性元注释</h5>
<div class="paragraph">
<p>你可以使用元数据注释方法安全性提高代码的可读性。</p>
</div>
<div class="paragraph">
<p>如果你发现你是在代码库重复相同的复杂表达式。尤其方便</p>
</div>
<div class="paragraph">
<p>例如,考虑以下几点</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PreAuthorize("#contact.name == authentication.name")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of repeating this everywhere, we can create a meta annotation that can be used instead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("#contact.name == authentication.name")
public @interface ContactPermission {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>元注释可用于任何Spring安全方法的安全注释.</p>
</div>
<div class="paragraph">
<p>为了保持符合jsr - 250规范的注释不支持元注释.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="advanced-topics" class="sect0"><a class="anchor" href="#advanced-topics"></a>额外的话题</h1>
<div class="paragraph">
<p>在本部分中,我们将介绍功能,这需要一个前一章节的知识以及一些更高级的和不常使用的功能框架。</p>
</div>
<div class="sect1">
<h2 id="domain-acls"><a class="anchor" href="#domain-acls"></a>域对象的安全(acl)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="domain-acls-overview"><a class="anchor" href="#domain-acls-overview"></a>概述</h3>
<div class="paragraph">
<p>复杂的应用需要的往往不是简单的得到在web请求或方法调用级别来定义访问权限。而是，安全决议需要包括谁（认证），其中（的MethodInvocation）和什么（一些领域对象）。换句话说，授权决策还需要考虑一个方法调用的实际域对象实例的主题。</p>
</div>
<div class="paragraph">
<p>想象你正在设计申请宠物诊所。将会有两个主要基于spring的应用程序的用户组:宠物诊所的工作人员,以及宠物诊所的客户。员工将获得的所有数据,而你的客户只能看到自己的客户记录。使它更有趣,你的客户可以让其他用户看到他们的客户记录,例如"puppy preschool"的导师或当地的"Pony Club"的总统。使用Spring安全为基础,有几种方法可以使用:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>写下你的业务方法执行的安全。你可以咨询一个集合内的<code>Customer</code>域对象实例来确定哪些用户可以访问。通过使用<code>SecurityContextHolder.getContext().getAuthentication()</code>,你将能够访问<code>Authentication</code>的对象.</p>
</li>
<li>
<p>写一个 <code>AccessDecisionVoter</code>执行的安全<code>GrantedAuthority[]</code>存储在<code>Authentication</code>对象。这将意味着你的<code>AuthenticationManager</code>需要填充的<code>Authentication</code>自定义<code>GrantedAuthority[]</code>代表每一个<code>Customer</code>访问域对象实例.</p>
</li>
<li>
<p>写一个<code>AccessDecisionVoter</code> 执行安全和直接打开目标客户的域对象。这将意味着你的选民需要访问一个DAO,允许它来检索<code>Customer</code> 的对象。它将访问的<code>Customer</code> 对象的集合的批准用户和做出适当的决定.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每一个这些方法是完全合法的。然而,第一对授权检查你的业务代码。主要问题包括增强的困难的单元测试和重用会更困难的<code>Customer</code>授权逻辑。获得“GrantedAuthority[]的从<code>Authentication</code>对象也很好,但不会扩展到大量的<code>Customer</code>。如果用户可以访问5000`Customer`(不可能在这种情况下,但试想一下,如果它是一个受欢迎的兽医大小马俱乐部!)所需的内存消耗和时间来构造对象将是不受欢迎的<code>Authentication</code>。最后的方法,直接从外部代码打开<code>Customer</code>,可能是最好的三个。实现关注点分离,不滥用内存或CPU周期,但它仍然是低效的,“AccessDecisionVoter”和最终的商业方法本身将执行调用DAO负责检索<code>AccessDecisionVoter</code>对象。两个访问每个方法调用显然是不可取的。此外,每个方法列出你需要编写自己的访问控制列表(ACL)从头持久性和业务逻辑.</p>
</div>
<div class="paragraph">
<p>幸运的是,还有另一个选择,我们下面会讲到.</p>
</div>
</div>
<div class="sect2">
<h3 id="domain-acls-key-concepts"><a class="anchor" href="#domain-acls-key-concepts"></a>关键概念</h3>
<div class="paragraph">
<p>Spring Security的ACL服务运送<code>spring-security-acl-xxx.jar</code>.您需要将这个JAR添加到类路径中使用Spring安全域对象实例的安全功能.</p>
</div>
<div class="paragraph">
<p>Spring Security的域对象实例的安全能力中心的概念一个访问控制列表(ACL)。每个域对象实例系统中有自己的ACL,和ACL记录的细节,谁能和不能使用域对象。有鉴于此,Spring Security提供三个主要ACL-related功能应用程序:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种有效地检索ACL条目你所有的域对象(和修改ACL).</p>
</li>
<li>
<p>确保给定的方式主要是允许的工作与你的对象,之前被称为方法.</p>
</li>
<li>
<p>确保给定的方式主要是允许使用对象(或者他们返回),后被称为方法.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第一个要点,Spring Security ACL的的一个主要功能模块提供了一个高性能的方式检索ACL。这个ACL库能力是极其重要的,因为每一个域对象实例系统中可能有多个访问控制条目,并且每个ACL可能继承其他树形结构中的ACL(这是开箱即用的支持由Spring Security,非常常用)。Spring Security的ACL能力都是被仔细设计以提供高性能检索ACL,加上可插入的缓存,deadlock-minimizing数据库更新、独立于ORM框架(我们直接使用JDBC),适当的封装,和透明的数据库更新.</p>
</div>
<div class="paragraph">
<p>给定数据库ACL的操作模块的核心,让我们探索使用四个主要表的默认实现。下面表的大小在一个典型的Spring Security ACL部署,最后列出的表行:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ACL_SID允许我们唯一地标识系统中的任何本金或权威("SID" 代表"security identity")。唯一列ID、文本表示的SID,国旗表明是否文本表示是指主体名称或<code>GrantedAuthority</code>.因此,有一个为每个独特的主体或<code>GrantedAuthority</code>行。的上下文中使用时获得许可,SID通常称为"recipient".</p>
</li>
<li>
<p>ACL_CLASS允许我们唯一地标识系统中任何域对象类。只列ID和Java类名。因此,有一行我们希望每一个独特的类存储ACL权限.</p>
</li>
<li>
<p>ACL_OBJECT_IDENTITY门店信息系统中每个独特的域对象实例。列包含ID,ACL_CLASS表的外键,所以我们知道唯一标识符ACL_CLASS实例我们提供信息,父,ACL_SID表的外键表示域对象实例的所有者,以及我们是否允许ACL条目继承任何父ACL。我们已经为每个域对象实例一行我们存储ACL权限.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>*最后,ACL_ENTRY存储个人权限分配给每个收件人。ACL_OBJECT_IDENTITY列包括一个外键,收件人ACL_SID(外键),是否我们将审计,整数位屏蔽代表实际的权限被授予或拒绝。我们为每个收件人接收一行允许使用一个域对象.</p>
</div>
<div class="paragraph">
<p>如最后一段中所述,ACL系统使用整数位屏蔽。别担心,你不需要知道的细微之处,转向使用ACL系统,但是我想说的是,我们有32位我们可以打开或关闭。每一个位代表一个许可,并默认权限阅读(0),写(1),创建(2)、删除(第3位)和管理(4)。很容易实现自己的“许可”实例如果你希望使用其他权限,和其余的ACL框架将没有知识的扩展.</p>
</div>
<div class="paragraph">
<p>重要的是要理解,域对象的数量在系统完全没有影响我们选择使用整数位屏蔽。虽然你有32位用于权限,你可以有数十亿的域对象实例(这将意味着数十亿行ACL_OBJECT_IDENTITY而且很可能ACL_ENTRY)。我们这一点,因为我们发现有时人们错误地认为他们需要一点对于每一个可能的域对象,这并非如此.</p>
</div>
<div class="paragraph">
<p>现在我们已经提供了一个基本的概述ACL系统做什么,看起来在一个表结构,让我们探索的关键接口。关键接口:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Acl</code>:每一个域对象都有且只有一个Acl的对象,内部持有AccessControlEntry的年代以及知道的Acl的所有者。Acl不直接引用到域对象,而是一个<code>ObjectIdentity</code>.Acl的存储在ACL_OBJECT_IDENTITY表.</p>
</li>
<li>
<p><code>AccessControlEntry</code>:一个Acl拥有多个“AccessControlEntry”年代,通常缩写为ace框架。每个ACE是指一个特定的元组的“许可”,“Sid”和“Acl”。ACE还可以授予或non-granting和包含审计设置。ACE ACL_ENTRY表中存储。</p>
</li>
<li>
<p><code>Permission</code>:权限代表一个特定不变的位元遮罩,为钻头提供了便利的函数屏蔽和输出信息。上面给出的基本权限(字节0到4)中包含“BasePermission”类。</p>
</li>
<li>
<p><code>Sid</code>:ACL模块需要指校长和“GrantedAuthority[]的年代。提供了一个间接层的Sid的界面,这是一种“安全标识”的缩写。常见的类包括“PrincipalSid”(代表校长在一个“身份验证”对象)和“GrantedAuthoritySid”。安全身份信息存储在ACL_SID表。</p>
</li>
<li>
<p><code>ObjectIdentity</code>:每个域对象内部ACL表示模块由一个“ObjectIdentity”。默认实现叫做“ObjectIdentityImpl”。</p>
</li>
<li>
<p><code>AclService</code>:检索Acl的适用于一个给定的“ObjectIdentity”。包括实现(JdbcAclService),检索操作委托给一个“LookupStrategy”。“LookupStrategy”为检索ACL信息提供了一个高度优化的策略,使用“(BasicLookupStrategy”批处理检索)和支持自定义实现利用物化视图,分级查询和performance-centric相似,non-ANSI SQL功能。</p>
</li>
<li>
<p><code>MutableAclService</code>:允许提出了修改Acl的持久性。这并不是最重要的如果你不希望使用这个接口。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意我们的开箱即用的AclService和相关数据库类都使用ANSI SQL.这是主要的数据库.在写这篇文章的时候,系统已经成功测试了使用超音速SQL,PostgreSQL,Microsoft SQL Server和Oracle.</p>
</div>
<div class="paragraph">
<p>两个样本船与演示Spring Security ACL模块。第一个是联系人样本,另一个是文档管理系统(DMS)样本。我们建议采取一看这些例子.</p>
</div>
</div>
<div class="sect2">
<h3 id="domain-acls-getting-started"><a class="anchor" href="#domain-acls-getting-started"></a>开始</h3>
<div class="paragraph">
<p>要开始使用Spring Security ACL的功能,你需要你的ACL信息存储在某个地方。这需要实例化的<code>DataSource</code>使用Spring。<code>DataSource</code>然后注入<code>JdbcMutableAclService</code>和<code>BasicLookupStrategy</code> 实例。后者提供高性能的ACL检索功能,和前提供增变基因功能。指的一个样本船与Spring Security配置的一个示例。您还需要用四个ACL-specific填充数据库表中列出的最后一部分(参见ACL样本的适当的SQL语句).</p>
</div>
<div class="paragraph">
<p>一旦您创建了所需的模式和实例化<code>JdbcMutableAclService</code>,接下来将需要确保您的域模型支持互操作性的Spring Security ACL包。希望<code>ObjectIdentityImpl</code> 将是足够的,因为它提供了大量的方法可以使用它。大部分人都有包含 <code>public Serializable getId()</code>的方法。如果返回类型是长,或兼容长(例如int),你会发现你不需要提供进一步的考虑<code>ObjectIdentity</code>问题。许多地方的ACL模块依赖长标识符。如果你不使用长(或int,字节等),有一个非常好的机会你需要重新实现的类。我们不打算支持非long标识符在Spring Security的ACL模块,多头已经兼容所有数据库序列,最常见的标识符的数据类型和长度足够容纳所有常见的使用场景。</p>
</div>
<div class="paragraph">
<p>以下代码片段显示了如何创建一个Acl,或修改现有<code>Acl</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Prepare the information we'd like in our access control entry (ACE)
ObjectIdentity oi = new ObjectIdentityImpl(Foo.class, new Long(44));
Sid sid = new PrincipalSid("Samantha");
Permission p = BasePermission.ADMINISTRATION;

// Create or update the relevant ACL
MutableAcl acl = null;
try {
acl = (MutableAcl) aclService.readAclById(oi);
} catch (NotFoundException nfe) {
acl = aclService.createAcl(oi);
}

// Now grant some permissions via an access control entry (ACE)
acl.insertAce(acl.getEntries().length, p, sid, true);
aclService.updateAcl(acl);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中,我们检索ACL的44号"Foo" 域对象标识符。我们添加一个ACE,然后名叫"Samantha"能"administer"的对象。代码片段相对明显,除了insertAce方法。insertAce方法的第一个参数是确定在什么位置Acl新条目将被插入。在上面的示例中,我们只是把新的现有ACE。最后一个参数是一个布尔值指示是否允许或拒绝。大部分时间它将授予(真实的),但如果是否认(假),实际上是被屏蔽的权限.</p>
</div>
<div class="paragraph">
<p>Spring Security并不提供任何特殊的集成自动创建、更新或删除acl DAO或存储库操作的一部分。相反,您需要编写代码如上图所示为你单独的域对象.值得考虑使用AOP在服务层与服务层自动把ACL信息操作.我们发现这在过去的一个相当有效的方法.</p>
</div>
<div class="paragraph">
<p>一旦你使用上述技术将一些ACL信息存储在数据库中,下一步是实际使用ACL信息作为授权决策逻辑的一部分。这里有许多选择。您可以编写自己的<code>AccessDecisionVoter</code>或<code>AfterInvocationProvider</code> 分别触发一个方法调用之前或之后。这些课程将使用<code>AclService</code>来检索相关的ACL,然后调用的ACL。i`Acl.isGranted(Permission[] permission, Sid[] sids, boolean administrativeMode)<code>决定是否授予或拒绝许可。或者,您可以使用我们的`AclEntryVoter</code>, <code>AclEntryAfterInvocationProvider</code> 或 <code>AclEntryAfterInvocationCollectionFilteringProvider</code>类。所有这些类提供一个declarative-based方法评估ACL信息在运行时,释放你需要编写任何代码。请参阅示例应用程序来学习如何使用这些类。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="preauth"><a class="anchor" href="#preauth"></a>Pre-Authentication场景</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在有些情况下,您希望使用Spring安全授权,但是用户已经被一些外部系统可靠地验证之前访问应用程序。我们称这种情况为 "pre-authenticated"场景。例子包括 X.509,Siteminder和身份验证的Java EE容器的应用程序正在运行。当使用pre-authentication,Spring Security</p>
</div>
<div class="paragraph">
<p>*识别用户的请求</p>
</div>
<div class="paragraph">
<p>*为用户获得当局</p>
</div>
<div class="paragraph">
<p>细节将取决于外部身份验证机制。用户可能会被他们的证书信息的X.509,或通过一个HTTP请求头Siteminder的情况。如果依靠容器身份验证,用户将被调用<code>getUserPrincipal()</code> 的方法传入的HTTP请求。在某些情况下,外部机制可能为用户提供角色/权威信息但在其他当局必须获得一个单独的源,如<code>UserDetailsService</code>.</p>
</div>
<div class="sect2">
<h3 id="truepre-authentication"><a class="anchor" href="#truepre-authentication"></a>Pre-Authentication框架类</h3>
<div class="paragraph">
<p>因为大多数pre-authentication机制遵循相同的模式,Spring Security一组类,提供一个内部框架实现pre-authenticated身份验证提供者。这个删除复制和允许添加新的实现结构化的方式,无需写一切从头开始。你不需要知道这些类,如果希望使用类似于<a href="#x509">X.509 authentication</a>,因为它已经有了一个名称空间配置选项,简单的使用和开始使用。如果你需要使用显式的bean配置或计划编写自己的实现提供的实现如何工作的理解将是有用的。你会发现类“org.springframework.security.web.authentication.preauth”。我们在适当的地方提供一个大纲你应该咨询Javadoc和源.</p>
</div>
<div class="sect3">
<h4 id="true--25"><a class="anchor" href="#true--25"></a>抽象的预认证处理过滤器</h4>
<div class="paragraph">
<p>这个类将检查的当前内容安全上下文,如果空,它将尝试从HTTP请求中提取用户信息并提交<code>AuthenticationManager</code>,子类覆盖以下方法来获得这些信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected abstract Object getPreAuthenticatedPrincipal(HttpServletRequest request);

protected abstract Object getPreAuthenticatedCredentials(HttpServletRequest request);</code></pre>
</div>
</div>
<div class="paragraph">
<p>把这些后,过滤器将包含返回的数据创建一个<code>PreAuthenticatedAuthenticationToken</code>并提交身份验证。由"authentication",我们或许真的只是意味着进一步的处理负荷用户的部门,而不是按照标准的Spring Security验证架构。</p>
</div>
<div class="paragraph">
<p>像其他Spring安全身份验证过滤器,pre-authentication过滤器有一个<code>authenticationDetailsSource</code>属性,默认情况下将创建一个<code>WebAuthenticationDetails</code> 对象来存储更多的信息,比如会话标识符和原始IP地址在 <code>Authentication</code> 对象的属性<code>details</code>。在这种情况下,用户角色信息可从pre-authentication获取机制,数据也存储在这个属性,实现<code>GrantedAuthoritiesContainer</code>接口的细节。这使的身份验证提供者阅读部门外部分配给用户。接下来我们将看一个具体的例子.</p>
</div>
<div class="sect4">
<h5 id="j2ee-preauth-details"><a class="anchor" href="#j2ee-preauth-details"></a>基于J2ee的前验证Web身份验证源细节</h5>
<div class="paragraph">
<p>如果过滤器配置了一个<code>authenticationDetailsSource</code>这类的一个实例,权威的信息是通过调用<code>isUserInRole(String role)</code>的一组预先确定的方法为每一个"mappable roles"配置的类这些来自一个<code>MappableAttributesRetriever</code>.可能的实现包括硬编码应用程序上下文中的一个列表和阅读的角色信息<code>&lt;security-role&gt;</code>在<code>web.xml</code>文件.pre-authentication示例应用程序使用了后一种方法.</p>
</div>
<div class="paragraph">
<p>有一个额外的阶段(或属性)的角色被映射到Spring Security  <code>GrantedAuthority</code>对象使用一个配置<code>Attributes2GrantedAuthoritiesMapper</code>。默认只会添加通常具备ROLE_前缀的名字,但它让你完全控制行为</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true--26"><a class="anchor" href="#true--26"></a>前验证身份验证提供者</h4>
<div class="paragraph">
<p>re-authenticated提供者有更多比为用户负载的<code>UserDetails</code>对象。它通过委托给一个<code>AuthenticationUserDetailsService</code>.后者是类似于标准<code>UserDetailsService</code>但以一个 <code>Authentication</code>对象而不是用户名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface AuthenticationUserDetailsService {
UserDetails loadUserDetails(Authentication token) throws UsernameNotFoundException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个接口可能也其他用途,但pre-authentication它允许访问官方包装在“身份验证”对象,正如我们在前一节中看到的。<code>PreAuthenticatedGrantedAuthoritiesUserDetailsService</code>这类,或者,它可能代表一个标准的<code>UserDetailsService</code> 通过<code>UserDetailsByNameServiceWrapper</code> 实现.</p>
</div>
</div>
<div class="sect3">
<h4 id="truehttp403"><a class="anchor" href="#truehttp403"></a>Http403禁止入口点</h4>
<div class="paragraph">
<p><code>AuthenticationEntryPoint</code>是讨论的<a href="#tech-intro-auth-entry-point">technical overview</a> 一章。通常它负责启动未经过身份验证的用户的身份验证过程(当他们试图访问受保护的资源),但是在pre-authenticated情况下不适用。你只会配置 <code>ExceptionTranslationFilter</code>与这个类的一个实例,如果你不使用pre-authentication结合其他身份验证机制。它将被称为<code>AbstractPreAuthenticatedProcessingFilter</code>如果用户被拒绝的结果在一个空的身份验证。它总是返回一个“403”错误.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true--27"><a class="anchor" href="#true--27"></a>具体实现</h3>
<div class="paragraph">
<p>X.509认证被 <a href="#x509">own chapter</a>覆盖.下面我们来看看一些类,它们提供支持其他pre-authenticated场景.</p>
</div>
<div class="sect3">
<h4 id="true-siteminder"><a class="anchor" href="#true-siteminder"></a>请求头身份验证(Siteminder)</h4>
<div class="paragraph">
<p>设置特定的HTTP请求。一个众所周知的例子是Siteminder,通过用户名在一个标题叫<code>SM_USER</code> 。这种机制是类 <code>RequestHeaderAuthenticationFilter</code>支持,只是从标题中提取用户名。它默认使用的名称<code>SM_USER</code> 作为标题名称。看到更多的细节的Javadoc.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注意,当使用这样的一个系统,框架执行任何身份验证检查和<em>extremely</em>重要外部系统的正确配置和保护所有访问应用程序。如果攻击者能够伪造原始请求的头文件没有被发现之后,他们可以选择任何他们希望的用户名.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="truesiteminder"><a class="anchor" href="#truesiteminder"></a>Siteminder示例配置</h5>
<div class="paragraph">
<p>一个典型的配置使用这个过滤器看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;security:http&gt;
&lt;!-- Additional http configuration omitted --&gt;
&lt;security:custom-filter position="PRE_AUTH_FILTER" ref="siteminderFilter" /&gt;
&lt;/security:http&gt;

&lt;bean id="siteminderFilter" class="org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter"&gt;
&lt;property name="principalRequestHeader" value="SM_USER"/&gt;
&lt;property name="authenticationManager" ref="authenticationManager" /&gt;
&lt;/bean&gt;

&lt;bean id="preauthAuthProvider" class="org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider"&gt;
&lt;property name="preAuthenticatedUserDetailsService"&gt;
	&lt;bean id="userDetailsServiceWrapper"
		class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt;
	&lt;property name="userDetailsService" ref="userDetailsService"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;

&lt;security:authentication-manager alias="authenticationManager"&gt;
&lt;security:authentication-provider ref="preauthAuthProvider" /&gt;
&lt;/security:authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们认为这里<a href="#ns-config">security namespace</a>是用于配置。还假定您已经添加了一个<code>UserDetailsService</code>(称为"userDetailsService")到您的配置加载用户的角色.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truejava-ee"><a class="anchor" href="#truejava-ee"></a>Java EE容器认证</h4>
<div class="paragraph">
<p><code>J2eePreAuthenticatedProcessingFilter</code>将从 <code>userPrincipal</code>属性中提取 <code>HttpServletRequest</code>.使用这个过滤器通常会结合使用Java EE角色如上所述在&lt; &lt; j2ee-preauth-details &gt; &gt;表示.</p>
</div>
<div class="paragraph">
<p>有一个示例应用程序代码中使用这种方法,从github得到的代码从github,如果你对这些文件感兴趣你可以看下，代码是在<code>samples/xml/preauth</code>目录中.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ldap"><a class="anchor" href="#ldap"></a>LDAP 身份验证</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="ldap-overview"><a class="anchor" href="#ldap-overview"></a>概述</h3>
<div class="paragraph">
<p>LDAP作为一个中央存储库对用户信息和身份验证服务是常用的组织.它也可以用于存储应用程序用户的角色信息.这里有一些不同的场景对于如何配置LDAP服务器，因此Spring Security LDAP提供者是完全可配置的，它使用单独的策略为身份验证和角色接口检索,并提供默认的实现,可以配置为处理各种情况.在使用之前你应该熟悉Spring Security LDAP.以下链接提供了一个很好的介绍涉及的概念和使用OpenLDAP免费的LDAP服务器建立一个目录指南http://www.zytrax.com/books/ldap/[<a href="http://www.zytrax.com/books/ldap/" class="bare">http://www.zytrax.com/books/ldap/</a>].
一些熟悉的JNDI api用于访问LDAP从Java也可能是有用的。我们在LDAP不使用任何第三方LDAP库(Mozilla,JLDAP等等),但Spring 的广泛使用是由LDAP,如果你打算添加您自己的定制,对这方面有所了解对你的项目可能是有用的.</p>
</div>
<div class="paragraph">
<p>使用LDAP身份验证时,重要的是要确保你正确配置LDAP连接池。如果你不熟悉如何做到这一点,你可以参考
<a href="http://docs.oracle.com/javase/jndi/tutorial/ldap/connect/config.html">Java LDAP documentation</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="true-ldap-spring-security"><a class="anchor" href="#true-ldap-spring-security"></a>使用LDAP Spring Security</h3>
<div class="paragraph">
<p>在Spring的LDAP身份验证安全大致可以分为以下几个阶段</p>
</div>
<div class="ulist">
<ul>
<li>
<p>获得独特的LDAP"Distinguished Name",或DN,登录名。这通常意味着执行搜索的目录,除非用户名的具体映射DNs是提前知道。所以用户可能输入名称登录"joe",但实际LDAP名称用于验证将完整的DN,如<code>uid=joe,ou=users,dc=spring,dc=io</code>.</p>
</li>
<li>
<p>验证用户,通过"binding",用户操作的用户的密码与密码属性执行远程"compare" 目录条目的DN.</p>
</li>
<li>
<p>加载当局为用户的列表.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>唯一的例外是当LDAP目录只是被用于检索用户信息并在本地对其进行身份验证.这个不可能设置有限的读访问属性目录,如用户密码.</p>
</div>
<div class="paragraph">
<p>下面,我们将看看一些配置场景。完整的可用配置选项的信息,请查阅安全模式名称空间(信息应该在XML编辑器中可用).</p>
</div>
</div>
<div class="sect2">
<h3 id="ldap-server"><a class="anchor" href="#ldap-server"></a>配置LDAP服务器</h3>
<div class="paragraph">
<p>你需要做的第一件事是配置的服务器身份验证应该发生。这是通过使用 <code>&lt;ldap-server&gt;</code> 的元素从安全名称空间。这可以配置为指向外部LDAP服务器,使用的<code>url</code>属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ldap-server url="ldap://springframework.org:389/dc=springframework,dc=org" /&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="trueusing-an-embedded-test-server"><a class="anchor" href="#trueusing-an-embedded-test-server"></a>Using an Embedded Test Server</h4>
<div class="paragraph">
<p><code>&lt;ldap-server&gt;</code> 元素也可以用来创建一个嵌入式服务器,它可以是非常有用的进行测试和演示。在这种情况下,你没有使用它的url属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ldap-server root="dc=springframework,dc=org"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们指定目录是"dc=springframework,dc=org",这是默认的.这种方式,使用名称空间解析器将创建一个嵌入式Apache目录服务器的类路径和扫描任何LDIF文件,它将尝试加载到服务器。你可以定制这种行为使用ldif的属性,它定义了一个ldif资源加载:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ldap-server ldif="classpath:users.ldif" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使它更容易与LDAP同步,因为它可以方便工作与外部服务器。它还将用户从复杂bean配置需要隔离一个Apache连接目录服务器。使用普通的Spring bean配置将会更加混乱。你必须要有必要的Apache Directory依赖性jar用于您的应用程序使用。如LDAP示例应用程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="true--28"><a class="anchor" href="#true--28"></a>使用绑定验证</h4>
<div class="paragraph">
<p>这是最常见的LDAP身份验证场景.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ldap-authentication-provider user-dn-pattern="uid={0},ou=people"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个简单的例子将获得用户的DN替代模式和提供的用户登录名试图绑定,用户的登录密码。如果你所有的用户都是存储在单个节点的目录下这很好,如果您希望配置LDAP搜索筛选器来定位用户,你可以使用以下</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ldap-authentication-provider user-search-filter="(uid={0})"
	user-search-base="ou=people"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用上面的服务器定义,这将执行搜索在DN <code>ou=people,dc=springframework,dc=org</code>使用<code>user-search-filter</code> 属性的值作为一个过滤器。用户登录名是代替过滤器的参数名称,所以它将搜索条目<code>uid</code>属性等于用户名。如果<code>user-search-base</code> 并不提供,从根搜索.</p>
</div>
</div>
<div class="sect3">
<h4 id="true--29"><a class="anchor" href="#true--29"></a>加载机构</h4>
<div class="paragraph">
<p>当局是如何从组加载在LDAP目录中由以下属性控制</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>group-search-base</code>.定义了目录树下的一部分应该执行哪一组搜索。</p>
</li>
<li>
<p><code>group-role-attribute</code>.属性包含的名称定义的权限组条目。默认为<code>cn</code></p>
</li>
<li>
<p>组搜索过滤器。过滤器用于搜索组成员。默认是 <code>uniqueMember={0}</code>,对应于<code>groupOfUniqueNames</code>的LDAP类脚注:(注意,这是不同于缺省配置底层<code>DefaultLdapAuthoritiesPopulator</code>使用<code>member={0}</code>。]。在这种情况下,替换参数是用户的专有名称。可以使用参数<code>{1}</code>如果你想过滤的登录名.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此,如果我们使用以下配置</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ldap-authentication-provider user-dn-pattern="uid={0},ou=people"
		group-search-base="ou=groups" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>和经过验证的成功作为用户"ben",随后的加载下当局将执行搜索的目录条目的<code>ou=groups,dc=springframework,dc=org</code>,寻找条目包含的属性<code>uniqueMember</code>价值<code>uid=ben,ou=people,dc=springframework,dc=org</code>。默认的权限名称前缀<code>ROLE_</code> 前缀。你可以改变这个使用 <code>role-prefix</code>属性。如果你不想要任何前缀,使用<code>role-prefix="none"</code>.加载机构的更多信息,请参阅<code>DefaultLdapAuthoritiesPopulator</code>类的Javadoc.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true--30"><a class="anchor" href="#true--30"></a>实现类</h3>
<div class="paragraph">
<p>上面的名称空间配置选项我们使用易于使用,更比使用Spring bean简洁明确。有些情况下,您可能需要了解如何配置Spring Security LDAP直接在您的应用程序上下文。您可能希望定制的一些类的行为,例如。如果你使用名称空间配置,那么你可以跳过这一节和下一个.</p>
</div>
<div class="paragraph">
<p>LDAP provider,<code>LdapAuthenticationProvider</code>,实际上并不做太多工作本身,而是代表其他两个bean,一个<code>LdapAuthenticator</code> 和一个<code>LdapAuthoritiesPopulator</code>分别负责验证用户和检索用户的组<code>GrantedAuthority</code>.</p>
</div>
<div class="sect3">
<h4 id="ldap-ldap-authenticators"><a class="anchor" href="#ldap-ldap-authenticators"></a>Ldap身份验证实现</h4>
<div class="paragraph">
<p>authenticator还负责检索所需的用户属性。这是因为权限的属性可能取决于正在使用的身份验证类型。例如,如果绑定用户,与用户可能需要阅读的权限有关.</p>
</div>
<div class="paragraph">
<p>目前有两种身份验证策略提供Spring安全:</p>
</div>
<div class="paragraph">
<p>*直接向LDAP服务器的身份验证("bind" 身份验证)。</p>
</div>
<div class="paragraph">
<p>*密码比较,用户提供的密码是与一个存储在存储库中。这可以通过检索密码属性的值和检查本地或通过执行LDAP"compare"操作,提供的密码在哪里传递到服务器进行比较和真正的密码值是没有检索到.</p>
</div>
<div class="sect4">
<h5 id="ldap-ldap-authenticators-common"><a class="anchor" href="#ldap-ldap-authenticators-common"></a>常用功能</h5>
<div class="paragraph">
<p>之前可以验证一个用户(通过策略),专有名称(DN)必须从登录名获得提供给应用程序.这可以通过简单的模式匹配(通过设置<code>setUserDnPatterns</code>数组属性)或通过设置<code>userSearch</code>属性.对于DN模式匹配方法,格式是使用一个标准的Java模式,将登录名代替参数<code>{0}</code>.他应该相对于DN模式,配置<code>SpringSecurityContextSource</code> 将绑定到部分(参见<a href="#ldap-context-source">connecting to the LDAP server</a> 更多这方面的信息).<code>ldap://monkeymachine.co.uk/dc=springframework,dc=org</code>和有一个模式<code>uid={0},ou=greatapes</code>,"gorilla" 的登录名将会映射到一个DN`uid=gorilla,ou=greatapes,dc=springframework,dc=org`. 每个配置的DN模式将尝试直到找到一个匹配，有关使用搜索的信息,看到部分下面的<a href="#ldap-searchobjects">search objects</a>，结合这两种方法也可以使用——模式首先会检查,如果没有找到匹配DN,将使用搜索.</p>
</div>
</div>
<div class="sect4">
<h5 id="ldap-ldap-authenticators-bind"><a class="anchor" href="#ldap-ldap-authenticators-bind"></a>绑定认证者</h5>
<div class="paragraph">
<p>org.springframework.security.ldap BindAuthenticator实现身份验证绑定验证策略。它只是试图将用户绑定.</p>
</div>
</div>
<div class="sect4">
<h5 id="ldap-ldap-authenticators-password"><a class="anchor" href="#ldap-ldap-authenticators-password"></a>身份验证密码比较</h5>
<div class="paragraph">
<p><code>PasswordComparisonAuthenticator</code>实现了密码比较验证策略.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ldap-context-source"><a class="anchor" href="#ldap-context-source"></a>连接到LDAP服务器</h4>
<div class="paragraph">
<p>上面讨论的bean必须能够连接到服务器。他们都必须提供一个<code>SpringSecurityContextSource</code>这是SpringLDAP的<code>ContextSource</code>的延伸。除非你有特殊要求,您通常会配置一个DefaultSpringSecurityContextSource bean,可以配置LDAP服务器的URL和可选的"manager"的用户的用户名和密码,使用时将默认绑定到服务器(而不是匿名绑定)。更多信息,读取这个类的Javadoc和SpringLDAP的<code>AbstractContextSource</code>”.</p>
</div>
</div>
<div class="sect3">
<h4 id="ldap-searchobjects"><a class="anchor" href="#ldap-searchobjects"></a>LDAP搜索对象</h4>
<div class="paragraph">
<p>通常需要一个比DN-matching定位目录中的用户条目更复杂的策略，这可以封装在一个<code>LdapUserSearch</code>实例,可以提供身份验证实现.例如,让他们来定位用户.提供的实现是<code>FilterBasedLdapUserSearch</code>.</p>
</div>
<div class="sect4">
<h5 id="ldap-searchobjects-filter"><a class="anchor" href="#ldap-searchobjects-filter"></a>滤波器基于Ldap用户搜索</h5>
<div class="paragraph">
<p>这个bean使用LDAP目录中的过滤器匹配用户对象。Javadoc的过程解释相应的搜索方法
<a href="http://java.sun.com/j2se/1.4.2/docs/api/javax/naming/directory/DirContext.html#search(javax.naming.Name%2C%2520java.lang.String%2C%2520java.lang.Object%5B%5D%2C%2520javax.naming.directory.SearchControls)">JDK DirContext class</a>.作为解释,搜索筛选器可以提供参数。这个类,唯一有效的参数是<code>{0}</code>将取代用户的登录名.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ldap-authorities"><a class="anchor" href="#ldap-authorities"></a>Ldap当局填充器</h4>
<div class="paragraph">
<p>验证用户成功后,<code>LdapAuthenticationProvider</code> 将试图通过调用配置LdapAuthoritiesPopulator bean加载一组当局用户.<code>DefaultLdapAuthoritiesPopulator</code> 是一个实现加载当局通过搜索目录组的用户成员(通常这些将<code>groupOfNames</code>”或<code>groupOfUniqueNames</code>加入目录中的条目)详细内容,请参阅这个类的Javadoc中它是如何工作的.</p>
</div>
<div class="paragraph">
<p>如果你只想使用LDAP身份验证,但加载当局从不同来源(比如数据库),那么您可以提供自己的实现这个接口和注入.</p>
</div>
</div>
<div class="sect3">
<h4 id="ldap-bean-config"><a class="anchor" href="#ldap-bean-config"></a>Spring Bean 配置</h4>
<div class="paragraph">
<p>典型的配置中,我们这里讨论使用一些bean,看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="contextSource"
		class="org.springframework.security.ldap.DefaultSpringSecurityContextSource"&gt;
&lt;constructor-arg value="ldap://monkeymachine:389/dc=springframework,dc=org"/&gt;
&lt;property name="userDn" value="cn=manager,dc=springframework,dc=org"/&gt;
&lt;property name="password" value="password"/&gt;
&lt;/bean&gt;

&lt;bean id="ldapAuthProvider"
	class="org.springframework.security.ldap.authentication.LdapAuthenticationProvider"&gt;
&lt;constructor-arg&gt;
&lt;bean class="org.springframework.security.ldap.authentication.BindAuthenticator"&gt;
	&lt;constructor-arg ref="contextSource"/&gt;
	&lt;property name="userDnPatterns"&gt;
	&lt;list&gt;&lt;value&gt;uid={0},ou=people&lt;/value&gt;&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;
&lt;/constructor-arg&gt;
&lt;constructor-arg&gt;
&lt;bean
	class="org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator"&gt;
	&lt;constructor-arg ref="contextSource"/&gt;
	&lt;constructor-arg value="ou=groups"/&gt;
	&lt;property name="groupRoleAttribute" value="ou"/&gt;
&lt;/bean&gt;
&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将设置提供程序访问LDAP服务器URL`ldap://monkeymachine:389/dc=springframework,dc=org`.身份验证将由试图结合DN`uid=&lt;user-login-name&gt;,ou=people,dc=springframework,dc=org`.成功的身份验证之后,角色分配给用户通过搜索下的DN`ou=groups,dc=springframework,dc=org`用默认的过滤器<code>(member=&lt;user&#8217;s-DN&gt;)</code>.角色名称将从每一个"ou"属性开始匹配.</p>
</div>
<div class="paragraph">
<p>配置一个用户搜索对象,使用过滤器<code>(uid=&lt;user-login-name&gt;)</code> 的使用而不是DN-pattern(或补充),您将配置以下bean</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="userSearch"
	class="org.springframework.security.ldap.search.FilterBasedLdapUserSearch"&gt;
&lt;constructor-arg index="0" value=""/&gt;
&lt;constructor-arg index="1" value="(uid={0})"/&gt;
&lt;constructor-arg index="2" ref="contextSource" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>并使用它通过设置<code>BindAuthenticator</code> bean的 <code>userSearch</code>属性.authenticator将调用搜索对象来获得正确的用户作为该用户的DN之前绑定.</p>
</div>
</div>
<div class="sect3">
<h4 id="ldap-custom-user-details"><a class="anchor" href="#ldap-custom-user-details"></a>LDAP Attributes and Customized UserDetails</h4>
<div class="paragraph">
<p>身份验证使用<code>LdapAuthenticationProvider</code> 的最终结果是一样的一个正常的Spring安全身份验证使用标准的<code>UserDetailsService</code>界面。创建一个<code>UserDetails</code>”对象并返回存储在<code>Authentication</code>”对象。作为<code>UserDetailsService</code>使用,一个常见需求是能够定制这个实现和添加额外的属性。当使用LDAP,这些通常会从用户条目属性。<code>UserDetails</code>对象的创建是由提供者的<code>UserDetailsContextMapper</code>策略,负责从LDAP上下文映射用户对象和数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface UserDetailsContextMapper {

UserDetails mapUserFromContext(DirContextOperations ctx, String username,
		Collection&lt;GrantedAuthority&gt; authorities);

void mapUserToContext(UserDetails user, DirContextAdapter ctx);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>唯一重要的是第一个方法进行身份验证。如果您提供该接口的一个实现,它注入<code>LdapAuthenticationProvider</code>,你能够控制如何创建UserDetails对象。Spring 的第一个参数是一个实例LDAP的<code>DirContextOperations</code>可以让你接触的LDAP属性加载在身份验证。 <code>username</code>参数是用于验证和最后一个参数是集当局为用户加载的配置 <code>LdapAuthoritiesPopulator</code>.</p>
</div>
<div class="paragraph">
<p>上下文数据加载略有不同的方式取决于您正在使用的身份验证类型。 <code>BindAuthenticator</code>,返回的上下文绑定操作将被用于读取属性,否则数据将从配置读取使用标准的背景下获得<code>ContextSource</code>(当配置搜索来定位用户,这将是搜索返回的数据对象).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ldap-active-directory"><a class="anchor" href="#ldap-active-directory"></a>活动目录的认证</h3>
<div class="paragraph">
<p>活动目录支持自己的标准身份验证选项,和正常的使用模式不适合太明显与标准<code>LdapAuthenticationProvider</code>.通常执行身份验证使用域用户名(<code>user@domain</code>),而不是使用LDAP专有名称.为了更简单,Spring Security 3.1有一个身份验证提供者是一个典型的定制活动目录设置.</p>
</div>
<div class="sect3">
<h4 id="trueactive-directory-ldap"><a class="anchor" href="#trueactive-directory-ldap"></a>Active Directory Ldap身份验证提供者</h4>
<div class="paragraph">
<p>配置ActiveDirectoryLdapAuthenticationProvider非常简单。你只需要提供域名和LDAP服务器的URL提供地址脚注:[还可以获得使用DNS查找服务器的IP地址。当前不支持,但是希望在以后的版本可以实现)。一个例子配置会看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="adAuthenticationProvider"
class="org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider"&gt;
	&lt;constructor-arg value="mydomain.com" /&gt;
	&lt;constructor-arg value="ldap://adserver.mydomain.com/" /&gt;
&lt;/bean&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意,不需要指定一个单独的<code>ContextSource</code>来定义服务器位置- bean是完全自包含的。用户名为<code>sharon</code>,例如,将能够验证通过输入用户名<code>sharon</code>或完整的Active Directory`userPrincipalName`,即 <code>sharon@mydomain.com</code>.用户的目录条目将被定位,并可能返回的属性中使用自定义创建的UserDetails对象(<code>UserDetailsContextMapper</code>可以被注入为此,如上所述)。所有与目录发生交互用户的身份。没有一个"manager"用户的概念.</p>
</div>
<div class="paragraph">
<p>默认情况下,用户当局正在从<code>memberOf</code> 获得用户输入的属性值。政府再分配给用户可以使用被定制<code>UserDetailsContextMapper</code>。你也可以注入一个<code>GrantedAuthoritiesMapper</code>提供者实例来控制政府最终在 <code>Authentication</code>对象.</p>
</div>
<div class="sect4">
<h5 id="true--31"><a class="anchor" href="#true--31"></a>活动目录错误代码</h5>
<div class="paragraph">
<p>默认情况下,一个失败的结果将导致一个标准的Spring Security`BadCredentialsException`,如果你设置的属性<code>convertSubErrorCodesToExceptions</code>  是<code>true</code>, 异常消息将解析试图提取活性Directory-specific错误代码,提高一个更具体的异常。检查类Javadoc的更多信息。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="taglibs"><a class="anchor" href="#taglibs"></a>JSP 标签库</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security有自己的标签库提供基本支持访问安全信息并在jsp应用安全约束.</p>
</div>
<div class="sect2">
<h3 id="true-taglib"><a class="anchor" href="#true-taglib"></a>宣布Taglib</h3>
<div class="paragraph">
<p>要使用的任何标签,必须有安全JSP 标签库:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="taglibs-authorize"><a class="anchor" href="#taglibs-authorize"></a>授权标签</h3>
<div class="paragraph">
<p>这个标签是用来确定是否应评估其内容。在Spring Security 3.0中,可以以两种方式使用脚注:[遗留的选项从Spring Security 2.0也支持,但不推荐.].第一种方法使用一个<a href="#el-access-web">web-security expression</a>,<code>access</code> 属性中指定的标签,表达式求值将委托给<code>SecurityExpressionHandler&lt;FilterInvocation&gt;</code> 中定义的应用程序(你应该启用web表达式<code>&lt;http&gt;</code>的名称空间配置,以确保这个服务是可用的).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;sec:authorize access="hasRole('supervisor')"&gt;

此内容将只对用户可见的"supervisor"权威的&lt; tt &gt; GrantedAuthority &lt; / tt &gt;。

&lt;/sec:authorize&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在与Spring Security PermissionEvaluator共同使用时,标签也可以用来检查权限.例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;sec:authorize access="hasPermission(#domain,'read') or hasPermission(#domain,'write')"&gt;

作为一个请求属性命名的"domain",这个内容只会看到读写权限对象用户.

&lt;/sec:authorize&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个常见的需求是只显示一个特定的链接,如果用户实际上是允许点击它。我们如何能提前确定事情是否会被允许吗?这个标签也可以在另一种操作模式,允许您定义一个特定的URL属性。如果允许用户调用的URL,然后标记的身体将被评估,否则它将被忽略。所以你可能类似</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;sec:authorize url="/admin"&gt;

This content will only be visible to users who are authorized to send requests to the "/admin" URL.

&lt;/sec:authorize&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在你的程序内使用这个标签也必须的一个实例<code>WebInvocationPrivilegeEvaluator</code>,如果您正在使用名称空间,将自动注册。这是一 个<code>DefaultWebInvocationPrivilegeEvaluator</code>的实例，它创建了一个虚拟网络提供的URL请求,并调用安全拦截器请求是否会成功或失败，这允许您代表您定义的访问控制设置中使用<code>intercept-url</code>声明<code>&lt;http&gt;</code>的名称空间配置省去了重复的信息(如所需的角色)在您的jsp.这种方法还可以加上一个<code>method</code>属性,提供HTTP方法,更具体的匹配.</p>
</div>
<div class="paragraph">
<p>布尔结果评估标签(是否允许或拒绝访问)通过设置<code>var</code>属性变量名称可以存储在一个页面上下文范围变量,避免复制和重新评估在页面中的其他点.</p>
</div>
<div class="sect3">
<h4 id="true--32"><a class="anchor" href="#true--32"></a>禁用标记授权进行测试</h4>
<div class="paragraph">
<p>隐藏链接在页面不防止未经授权的用户访问URL。他们可以直接在浏览器中类型,例如，作为您的测试过程的一部分,您可能想要显示隐藏领域为了检查环节是安全的后端。如果你设置系统属性 <code>spring.security.disableUISecurity</code> 为 <code>true</code>,<code>authorize</code>的标签仍然会跑但不会隐藏其内容,默认情况下它也会包含<code>&lt;span class="securityHiddenUI"&gt;&#8230;&#8203;&lt;/span&gt;</code> 标签。这允许你显示"hidden"与一个特定的CSS样式等内容不同的背景颜色。尝试运行此属性启用的"tutorial"示例应用程序，例如.</p>
</div>
<div class="paragraph">
<p>你也可以设置<code>spring.security.securedUIPrefix</code>和<code>spring.security.securedUISuffix</code>属性,如果你想改变周围的文字从默认的<code>跨度</code>标签（或使用空字符串完全删除）.如果你想改变周围文本从默认“跨度”标签(或使用空字符串完全删除它).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true--33"><a class="anchor" href="#true--33"></a>身份验证标记</h3>
<div class="paragraph">
<p>这个标签允许访问当前存储在安全内 <code>Authentication</code>对象,它直接在JSP中 呈现一个属性对象.所以,例如,如果principal`属性的<code>Authentication</code>是Spring Security的<code>UserDetails</code>的对象的一个实例,之后用<code>&lt;sec:authentication property="principal.username" /&gt;</code> 将会显示当前用户的名称.</p>
</div>
<div class="paragraph">
<p>当然,这种事情没有必要使用JSP标记,有些人喜欢保持尽可能少的逻辑视图.您可以在你的MVC控制器访问<code>Authentication</code>对象(通过调用<code>SecurityContextHolder.getContext().getAuthentication()</code>)并将数据直接添加到您的模型渲染的视图.</p>
</div>
</div>
<div class="sect2">
<h3 id="truethe-accesscontrollist-tag"><a class="anchor" href="#truethe-accesscontrollist-tag"></a>The accesscontrollist Tag</h3>
<div class="paragraph">
<p>这个标记只在使用Spring Security的ACL模块,它检查一个以逗号分隔的所需权限指定的域对象.如果当前用户所有的权限,然后标记的内容将被评估。如果他们不这样做,它将被忽略.例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;sec:accesscontrollist hasPermission="1,2" domainObject="${someObject}"&gt;

这将显示用户在给定对象上的所有权限所代表的值“1”或“2”.

&lt;/sec:accesscontrollist&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在程序内容中,权限被传递到“PermissionFactory”中定义中定义,将它们转换为ACL`Permission`的实例,所以他们支持任何格式工厂,他们不一定是整数,字符串可以像<code>READ</code>或<code>WRITE</code>.如果没有找到<code>PermissionFactory</code> ,将使用<code>DefaultPermissionFactory</code>的一个实例.程序中的“AclService”将被用于加载Acl的实例提供对象.Acl的将调用所需的权限,以检查是否都是合法的.</p>
</div>
<div class="paragraph">
<p>这个标签还支持<code>var</code>属性,以同样的方式<code>authorize</code> 的标签.</p>
</div>
</div>
<div class="sect2">
<h3 id="truecsrfinput"><a class="anchor" href="#truecsrfinput"></a>csrfInput标签</h3>
<div class="paragraph">
<p>如果启用了CSRF保护,这个标签插入一个隐藏表单字段的正确名称和值CSRF保护令牌。如果没有启用CSRF保护,这个标签输出.对于任何的<code>&lt;form:form&gt;</code> 标签使用,通常Spring Security自动插入一个CSRF表单字段.但如果由于某种原因你不能使用<code>&lt;form:form&gt;</code>,你可以使用<code>&lt;form:form&gt;</code>更换.</p>
</div>
<div class="paragraph">
<p>你应该把这个标签在一个HTML <code>&lt;form&gt;&lt;/form&gt;</code>形式的块,通常地方其他输入字段.不要将这个标签放置在一个Spring <code>&lt;form:form&gt;&lt;/form:form&gt;</code>,block—Spring Security会自动处理 Spring.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">	&lt;form method="post" action="/do/something"&gt;
		&lt;sec:csrfInput /&gt;
		Name:&lt;br /&gt;
		&lt;input type="text" name="name" /&gt;
		...
	&lt;/form&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truecsrfmetatags"><a class="anchor" href="#truecsrfmetatags"></a>csrfMetaTags标签</h3>
<div class="paragraph">
<p>如果启用了CSRF保护,这个标签插入元素标记包含CSRF保护令牌表单字段和标题名称和CSRF保护令牌的值。这些元素标记可用于使用CSRF保护在JavaScript应用程序.</p>
</div>
<div class="paragraph">
<p>你应该把<code>csrfMetaTags</code>在一个 HTML <code>&lt;head&gt;&lt;/head&gt;</code> ,通常地方其他元标记。一旦你使用这个标签,你可以使用JavaScript访问表单字段的名称,标题名称.JQuery中使用这个例子使这项任务变得更加简单.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSRF Protected JavaScript Page&lt;/title&gt;
		&lt;meta name="description" content="This is the description for this page" /&gt;
		&lt;sec:csrfMetaTags /&gt;
		&lt;script type="text/javascript" language="javascript"&gt;

			var csrfParameter = $("meta[name='_csrf_parameter']").attr("content");
			var csrfHeader = $("meta[name='_csrf_header']").attr("content");
			var csrfToken = $("meta[name='_csrf']").attr("content");

			// using XMLHttpRequest directly to send an x-www-form-urlencoded request
			var ajax = new XMLHttpRequest();
			ajax.open("POST", "http://www.example.org/do/something", true);
			ajax.setRequestHeader("Content-Type", "application/x-www-form-urlencoded data");
			ajax.send(csrfParameter + "=" + csrfToken + "&amp;name=John&amp;...");

			// using XMLHttpRequest directly to send a non-x-www-form-urlencoded request
			var ajax = new XMLHttpRequest();
			ajax.open("POST", "http://www.example.org/do/something", true);
			ajax.setRequestHeader(csrfHeader, csrfToken);
			ajax.send("...");

			// using JQuery to send an x-www-form-urlencoded request
			var data = {};
			data[csrfParameter] = csrfToken;
			data["name"] = "John";
			...
			$.ajax({
				url: "http://www.example.org/do/something",
				type: "POST",
				data: data,
				...
			});

			// using JQuery to send a non-x-www-form-urlencoded request
			var headers = {};
			headers[csrfHeader] = csrfToken;
			$.ajax({
				url: "http://www.example.org/do/something",
				type: "POST",
				headers: headers,
				...
			});

		&lt;script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		...
	&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不启用CSRF保护,<code>csrfMetaTags</code>输出.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jaas"><a class="anchor" href="#jaas"></a>Java Authentication and Authorization Service (JAAS) Provider</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="true--34"><a class="anchor" href="#true--34"></a>概述</h3>
<div class="paragraph">
<p>Spring Security提供一个包可以将身份验证请求委托给Java身份验证和授权服务(JAAS).这个包是在下面详细讨论.</p>
</div>
</div>
<div class="sect2">
<h3 id="jaas-abstractjaasauthenticationprovider"><a class="anchor" href="#jaas-abstractjaasauthenticationprovider"></a>Jaas远程准入Provider摘要</h3>
<div class="paragraph">
<p><code>AbstractJaasAuthenticationProvider</code>提供JAAS <code>AuthenticationProvider</code>实现的基础.子类必须实现方法,创建了<code>LoginContext</code>. <code>AbstractJaasAuthenticationProvider</code>有许多依赖关系,下面讨论它</p>
</div>
<div class="sect3">
<h4 id="jaas-callbackhandler"><a class="anchor" href="#jaas-callbackhandler"></a>JAAS回调处理程序</h4>
<div class="paragraph">
<p>大多数JAAS <code>LoginModule</code>的年代需要一个回调。这些回调通常用于获得用户的用户名和密码.</p>
</div>
<div class="paragraph">
<p>在Spring Security部署中,Spring Security负责这个用户交互(通过身份验证机制),因此,当委托到JAAS身份验证请求,Spring安全的身份验证机制已经完全填充一个身份验证的对象包含所有所需的JAAS LoginModule的信息.</p>
</div>
<div class="paragraph">
<p>因此,为Spring Security JAAS包提供了两个默认回调处理程序,<code>JaasNameCallbackHandler</code>和<code>JaasPasswordCallbackHandler</code>.每一个回调处理程序实现<code>JaasAuthenticationCallbackHandler</code>.在大多数情况下,这些回调处理程序可以简单地使用不了解内部力学.</p>
</div>
<div class="paragraph">
<p>对于那些需要完全控制回调行为,内部<code>AbstractJaasAuthenticationProvider</code>用<code>InternalCallbackHandler</code> 包装这些<code>JaasAuthenticationCallbackHandler</code>.<code>InternalCallbackHandler</code>是类实现JAAS正常的CallbackHandler接口。任何时候使用JAAS LoginModule的,它是通过一个应用程序上下文列表配置InternalCallbackHandler年代。如果LoginModule的请求一个回调兑<code>InternalCallbackHandler</code>,回调是循序传递到<code>JaasAuthenticationCallbackHandler</code>被包装.</p>
</div>
</div>
<div class="sect3">
<h4 id="jaas-authoritygranter"><a class="anchor" href="#jaas-authoritygranter"></a>JAAS授权授与者</h4>
<div class="paragraph">
<p>JAAS和主程序一起工作。甚至"roles"在JAAS表示为主体，Spring Security, 另一方面,
与<code>Authentication</code>对象,每个<code>Authentication</code>对象包含一个校长,和多个<code>GrantedAuthority</code> .促进这些不同概念之间的映射,Spring Security的JAAS包包括一个<code>AuthorityGranter</code>接口.</p>
</div>
<div class="paragraph">
<p><code>AuthorityGranter</code> 负责检查JAAS并返回一组字符串的,代表权利分配给主程序.对于每一个权威返回字符串.为每个字符串,返回权威<code>AbstractJaasAuthenticationProvider</code>创建了一个“JaasGrantedAuthority”(实现Spring Security的<code>GrantedAuthority</code> 接口)包含字符串和JAAS程序<code>AuthorityGranter</code>通过.<code>AbstractJaasAuthenticationProvider</code>获得JAAS,首先成功地验证用户的使用JAAS LoginModule的凭证,然后访问LoginContext将它返回.调用<code>LoginContext.getSubject().getPrincipals()</code>,与每个生成的<code>AuthorityGranter</code>主要传递给每个定义为与<code>AbstractJaasAuthenticationProvider.setAuthorityGranters(List)</code>的内容.</p>
</div>
<div class="paragraph">
<p>Spring Security不包括任何生产<code>AuthorityGranter</code>,每一个JAAS都有一个特定实现的意义。然而,有一个<code>TestAuthorityGranter</code>的单元测试演示了一个简单的<code>AuthorityGranter</code>实现.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jaas-defaultjaasauthenticationprovider"><a class="anchor" href="#jaas-defaultjaasauthenticationprovider"></a>默认Jaas身份验证提供</h3>
<div class="paragraph">
<p><code>DefaultJaasAuthenticationProvider</code>允许将一个JAAS配置的对象注入依赖项。然后使用JAAS配置的注入创建一个<code>LoginContext</code>.这意味着<code>DefaultJaasAuthenticationProvider</code>不绑定任何特定实现的<code>Configuration</code>因为<code>JaasAuthenticationProvider</code>.</p>
</div>
<div class="sect3">
<h4 id="jaas-inmemoryconfiguration"><a class="anchor" href="#jaas-inmemoryconfiguration"></a>在内存配置</h4>
<div class="paragraph">
<p>为了使<code>Configuration</code>容易注入一个<code>DefaultJaasAuthenticationProvider</code>, 默认在内存中实现名为“InMemoryConfiguration”.实现构造函数接受一个<code>Map</code>,每个键代表登录配置名称和值代表一个数组<code>AppConfigurationEntry</code> 。如果没有找到<code>Map</code>映射提供了<code>InMemoryConfiguration</code>还支持一个默认的<code>AppConfigurationEntry</code>对象<code>Array</code>,使用详情,请参阅“InMemoryConfiguration”的类级别的javadoc.</p>
</div>
</div>
<div class="sect3">
<h4 id="jaas-djap-config"><a class="anchor" href="#jaas-djap-config"></a>默认的Jaas身份验证提供者配置示例</h4>
<div class="paragraph">
<p>而 <code>InMemoryConfiguration</code>的Spring可以更详细配置standarad JAAS配置文件.它在文中 <code>DefaultJaasAuthenticationProvider</code>比<code>JaasAuthenticationProvider</code> 更灵活,因为它不依赖默认配置的实现.</p>
</div>
<div class="paragraph">
<p>使用<code>InMemoryConfiguration</code>配置一个例子<code>DefaultJaasAuthenticationProvider</code> .注意,自定义的“配置”可以很容易地实现注入<code>DefaultJaasAuthenticationProvider</code> .</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="jaasAuthProvider"
class="org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider"&gt;
&lt;property name="configuration"&gt;
&lt;bean class="org.springframework.security.authentication.jaas.memory.InMemoryConfiguration"&gt;
&lt;constructor-arg&gt;
	&lt;map&gt;
	&lt;!--
	SPRINGSECURITY is the default loginContextName
	for AbstractJaasAuthenticationProvider
	--&gt;
	&lt;entry key="SPRINGSECURITY"&gt;
	&lt;array&gt;
	&lt;bean class="javax.security.auth.login.AppConfigurationEntry"&gt;
		&lt;constructor-arg value="sample.SampleLoginModule" /&gt;
		&lt;constructor-arg&gt;
		&lt;util:constant static-field=
			"javax.security.auth.login.AppConfigurationEntry$LoginModuleControlFlag.REQUIRED"/&gt;
		&lt;/constructor-arg&gt;
		&lt;constructor-arg&gt;
		&lt;map&gt;&lt;/map&gt;
		&lt;/constructor-arg&gt;
		&lt;/bean&gt;
	&lt;/array&gt;
	&lt;/entry&gt;
	&lt;/map&gt;
	&lt;/constructor-arg&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="authorityGranters"&gt;
&lt;list&gt;
	&lt;!-- You will need to write your own implementation of AuthorityGranter --&gt;
	&lt;bean class="org.springframework.security.authentication.jaas.TestAuthorityGranter"/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jaas-jaasauthenticationprovider"><a class="anchor" href="#jaas-jaasauthenticationprovider"></a>Jaas Provider准入</h3>
<div class="paragraph">
<p><code>JaasAuthenticationProvider</code> 假定默认的<code>Configuration</code>的一个实例http://download.oracle.com/javase/1.4.2/docs/guide/security/jaas/spec/com/sun/security/auth/login/ConfigFile.html[ ConfigFile].这种假设是为了尝试更新<code>Configuration</code>.<code>JaasAuthenticationProvider</code>使用默认配置的创建<code>LoginContext</code>.</p>
</div>
<div class="paragraph">
<p>假设我们有一个JAAS登录配置文件,<code>/WEB-INF/login.conf</code>, 用下面的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt" data-lang="txt">JAASTest {
	sample.SampleLoginModule required;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>像所有Spring Security beans,<code>JaasAuthenticationProvider</code>通过应用程序上下文配置.下面的定义将对应于上面的JAAS登录配置文件</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="jaasAuthenticationProvider"
class="org.springframework.security.authentication.jaas.JaasAuthenticationProvider"&gt;
&lt;property name="loginConfig" value="/WEB-INF/login.conf"/&gt;
&lt;property name="loginContextName" value="JAASTest"/&gt;
&lt;property name="callbackHandlers"&gt;
&lt;list&gt;
&lt;bean
	class="org.springframework.security.authentication.jaas.JaasNameCallbackHandler"/&gt;
&lt;bean
	class="org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler"/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;property name="authorityGranters"&gt;
	&lt;list&gt;
	&lt;bean class="org.springframework.security.authentication.jaas.TestAuthorityGranter"/&gt;
	&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jaas-apiprovision"><a class="anchor" href="#jaas-apiprovision"></a>项目运行</h3>
<div class="paragraph">
<p>如果配置,“JaasApiIntegrationFilter”将试图运行“JaasAuthenticationToken”上的<code>Subject</code>。这意味着可以使用访问<code>Subject</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Subject subject = Subject.getSubject(AccessController.getContext());</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种集成可以很容易地使用<a href="#nsa-http-jaas-api-provision">jaas-api-provision</a>配置属性。当集成遗留或外部依赖JAAS Subject API被填充,这个特性很有用</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cas"><a class="anchor" href="#cas"></a>CAS 身份验证</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="cas-overview"><a class="anchor" href="#cas-overview"></a>Overview</h3>
<div class="paragraph">
<p>JA-SIG产生一个企业范围的单点登录系统称为CAS。与其他计划,JA-SIG中央身份验证服务是开源的,广泛使用,容易理解,平台独立,支持代理功能。Spring Security完全支持ca,并提供了一个简单的迁移路径从Spring Security的单个应用程序部署到多个应用程序部署的企业级CAS服务器.</p>
</div>
<div class="paragraph">
<p>你可以从at <a href="http://www.ja-sig.org/cas了解更多CAS.您还需要访问这个网站下载CAS服务器文件" class="bare">http://www.ja-sig.org/cas了解更多CAS.您还需要访问这个网站下载CAS服务器文件</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="cas-how-it-works"><a class="anchor" href="#cas-how-it-works"></a>CAS如何工作</h3>
<div class="paragraph">
<p>而中科院网站包含文档的细节CAS的体系结构,提出总体概述了Spring Security.Spring Security 3.x支持中科院。在撰写本文时,还在使用CAS服务器3.4版.</p>
</div>
<div class="paragraph">
<p>在您的企业,您需要设置一个CAS服务器。CAS服务器只是一个标准的WAR文件,所以设置您的服务器没有什么困难。在WAR文件您将定制登录和其他单点登录页面显示给用户.</p>
</div>
<div class="paragraph">
<p>当部署一个CAS 3.4服务器,您还需要指定一个<code>AuthenticationHandler</code>在<code>deployerConfigContext.xml</code>包含ca。<code>AuthenticationHandler</code>有一个简单的方法,该方法返回一个布尔判断是否一个给定的证书是有效的.你<code>AuthenticationHandler</code>的实现需要链接到某种类型的后端身份验证存储库,如LDAP服务器或数据库,CAS本身包含许多<code>AuthenticationHandler</code>的协助.当你下载服务器和部署war文件时,它被设置为成功进行身份验证的用户输入一个密码匹配他们的用户名,用于测试.</p>
</div>
<div class="sect3">
<h4 id="cas-sequence"><a class="anchor" href="#cas-sequence"></a>Spring Security和CAS交互序列</h4>
<div class="paragraph">
<p>基本的web浏览器之间的交互,CAS服务器和春天Security-secured服务如下:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>web用户浏览服务的公共页面.CAS或Spring Security不参与。</p>
</li>
<li>
<p>最终用户请求一个页面或者安全bean的使用是安全的。Spring Security的ExceptionTranslationFilter将检测到<code>AccessDeniedException</code>或<code>AuthenticationException</code>.</p>
</li>
<li>
<p>因为用户的<code>Authentication</code>的对象(或缺乏)引起了<code>AuthenticationException</code>,<code>ExceptionTranslationFilter</code>将调用配置的<code>AuthenticationEntryPoint</code>。如果使用CAS,这将是<code>CasAuthenticationEntryPoint</code> 类.</p>
</li>
<li>
<p><code>CasAuthenticationEntryPoint</code>会将用户的浏览器重定向到CAS服务器。它也将显示一个<code>service</code> 参数,这是春天的回调URL安全服务(应用程序)。例如,浏览器的URL重定向可能是https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas。</p>
</li>
<li>
<p>用户的浏览器重定向到ca后,他们将提示输入用户名和密码。如果用户提供了一个会话cookie这表明他们之前登录的,他们不会被提示重新登录(这个过程有一个例外,我们稍后将讨论)。中科院将使用<code>PasswordHandler</code>(或果使用CAS 3.0`AuthenticationHandler`)以上讨论决定是否用户名和密码是有效的。</p>
</li>
<li>
<p>成功登录之后,中科院重定向用户的浏览器将回到原来的服务。它还将包括一个<code>ticket</code>参数,这是一个不透明的字符串代表"service ticket".继续我们前面的例子中,浏览器重定向到URL <a href="https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ。" class="bare">https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ。</a></p>
</li>
<li>
<p>服务的web应用程序中,<code>CasAuthenticationFilter</code>总是侦听请求<code>/login/cas</code>(这是可配置的,但是我们将使用默认本介绍)。处理过滤器将构造一个<code>UsernamePasswordAuthenticationToken</code>代表服务票证。校长就等于<code>CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER</code>,同时将服务票证凭据不透明值。这种身份验证请求将被交给<code>AuthenticationManager</code>配置。</p>
</li>
<li>
<p><code>AuthenticationManager</code>实现<code>ProviderManager</code>,这是依次配置了 <code>CasAuthenticationProvider</code>. <code>CasAuthenticationProvider</code>只响应包含<code>UsernamePasswordAuthenticationToken</code>(如<code>CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER</code>)和<code>CasAuthenticationToken</code> (稍后讨论).</p>
</li>
<li>
<p><code>CasAuthenticationProvider</code>将验证服务票据使用<code>TicketValidator</code>实现。这通常是一个<code>Cas20ServiceTicketValidator</code>这是一个类包含在CAS客户端库。如果应用程序需要验证代理机票,使用 <code>Cas20ProxyTicketValidator</code> .<code>TicketValidator</code> 发出一个HTTPS请求CAS服务器以验证服务票证。它可能还包括一个代理回调URL,包括在这个例子:https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&amp;ticket=ST-0-ER94xMJmn6pha35CQRoZ&amp;pgtUrl=https / /server3.company.com/webapp/login/cas/proxyreceptor。</p>
</li>
<li>
<p>CAS服务器,验证请求将被接收。如果提供的服务票证匹配服务URL票发行,中科院将提供积极响应XML显示用户名。如果任何代理参与身份验证(下面讨论),代理列表中也包含在XML响应。</p>
</li>
<li>
<p>[OPTIONAL] 如果请求CAS验证服务包括代理回调URL(在<code>pgtUrl</code> 参数),中科院将包括一个 <code>pgtIou</code>字符串在XML响应。这种<code>pgtIou</code>代表一个借据proxy-granting机票。CAS服务器会创建自己的HTTPS连接回<code>pgtUrl</code>.这是相互CAS服务器进行身份验证,声称服务URL。HTTPS连接将被用来发送一个代理发放门票最初的web应用程序.例如,https://server3.company.com/webapp/login/cas/proxyreceptor?pgtIou=PGTIOU-0-R0zlgrl4pdAQwBvJWO3vnNpevwqStbSGcq3vKB2SqSFFRnjPHt&amp;pgtId=PGT-1-si9YkkHLrtACBo64rmsi3v2nf7cpCResXg5MpESZFArbaZiOKH。</p>
</li>
<li>
<p><code>Cas20TicketValidator</code>将收到CAS服务器解析XML。它将返回到<code>CasAuthenticationProvider</code>的<code>TicketResponse</code>,其中包括用户名(强制),代理列表(如果有涉及),和proxy-granting票借据(如果请求代理回调)。</p>
</li>
<li>
<p>接下来的<code>CasAuthenticationProvider</code>将称之为<code>CasProxyDecider</code>配置. <code>CasProxyDecider</code>表明代理列表中 <code>TicketResponse</code>是否接受服务。几个实现提供SpringSecurity:`RejectProxyTickets`,<code>AcceptAnyCasProxy</code>和 <code>NamedCasProxyDecider</code>。这些名字在很大程度上是自解释的,除了 <code>NamedCasProxyDecider</code>允许<code>List</code> 提供可信的代理。</p>
</li>
<li>
<p><code>CasAuthenticationProvider</code>将下一个请求的<code>AuthenticationUserDetailsService</code>加载<code>GrantedAuthority</code> 对象,适用于用户包含在 <code>Assertion</code>.</p>
</li>
<li>
<p>如果没有问题,<code>CasAuthenticationProvider</code>构造CasAuthenticationToken包括细节包含在<code>TicketResponse</code>和<code>GrantedAuthority</code>.</p>
</li>
<li>
<p>控制然后返回<code>CasAuthenticationFilter</code>,把<code>CasAuthenticationToken</code>创建安全上下文.</p>
</li>
<li>
<p><code>AuthenticationException</code>导致用户的浏览器被重定向到原始页面 (or a <a href="#form-login-flow-handling">custom destination</a>根据配置).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>很好,你还在这里!现在让我们看看这是如何配置的</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cas-client"><a class="anchor" href="#cas-client"></a>配置客户案件</h3>
<div class="paragraph">
<p>由于Spring Security中科院的web应用程序是很容易.这是假设你已经知道使用Spring安全的基本知识,下面这些是不会再覆盖。我们假设基于命名空间的配置使用,根据需要添加在CAS bean。每个部分建立在前一节。一个完整的<a href="#cas-sample">CAS sample application</a>可以在Spring Security样本找到.</p>
</div>
<div class="sect3">
<h4 id="cas-st"><a class="anchor" href="#cas-st"></a>门票远程准入服务</h4>
<div class="paragraph">
<p>本节描述如何设置Spring Security验证Service Tickets。很多时候这都是一个web应用程序需要。您需要添加一个“ServiceProperties”bean到您的应用程序上下文。这代表你的CAS服务:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties"&gt;
&lt;property name="service"
	value="https://localhost:8443/cas-sample/login/cas"/&gt;
&lt;property name="sendRenew" value="false"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>service</code>必须等于一个URL,将由<code>CasAuthenticationFilter</code>监控.<code>sendRenew</code>的默认值为false,但如果应用程序尤其敏感应该设置为true.这个参数的作用是告诉CAS登录服务,一个单点登录登录是不可接受的。相反,用户将需要重新输入自己的用户名和密码来访问服务.</p>
</div>
<div class="paragraph">
<p>下面的bean应该配置开始CAS认证过程(假设您正在使用一个名称空间配置):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;security:http entry-point-ref="casEntryPoint"&gt;
...
&lt;security:custom-filter position="CAS_FILTER" ref="casFilter" /&gt;
&lt;/security:http&gt;

&lt;bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;/bean&gt;

&lt;bean id="casEntryPoint"
	class="org.springframework.security.cas.web.CasAuthenticationEntryPoint"&gt;
&lt;property name="loginUrl" value="https://localhost:9443/cas/login"/&gt;
&lt;property name="serviceProperties" ref="serviceProperties"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>CAS操作,<code>ExceptionTranslationFilter</code>必须有它<code>authenticationEntryPoint</code>属性设置为<code>CasAuthenticationEntryPoint</code>”bean.这可以很容易地通过使用 <a href="#ns-entry-point-ref">entry-point-ref</a>,是在上面的示例中完成的。<code>CasAuthenticationEntryPoint</code>必须参考的ServiceProperties bean(如上所述),它提供了企业的CAS登录服务器的URL.就是用户的浏览器重定向.</p>
</div>
<div class="paragraph">
<p><code>CasAuthenticationFilter</code> 已经和属性<code>UsernamePasswordAuthenticationFilter</code> 非常相似(用于基于表单的登录)。您可以使用这些属性来定制诸如认证成功和失败的行为.</p>
</div>
<div class="paragraph">
<p>接下来,您需要添加一个“CasAuthenticationProvider”及其合作者:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;security:authentication-manager alias="authenticationManager"&gt;
&lt;security:authentication-provider ref="casAuthenticationProvider" /&gt;
&lt;/security:authentication-manager&gt;

&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
&lt;property name="authenticationUserDetailsService"&gt;
	&lt;bean class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt;
	&lt;constructor-arg ref="userService" /&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="serviceProperties" ref="serviceProperties" /&gt;
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ServiceTicketValidator"&gt;
	&lt;constructor-arg index="0" value="https://localhost:9443/cas" /&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="key" value="an_id_for_this_auth_provider_only"/&gt;
&lt;/bean&gt;

&lt;security:user-service id="userService"&gt;
&lt;security:user name="joe" password="joe" authorities="ROLE_USER" /&gt;
...
&lt;/security:user-service&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>CasAuthenticationProvider</code> 使用<code>UserDetailsService</code>实例加载权限用户,一旦被CAS认证。我们已经演示了一个简单的内存设置。注意,<code>CasAuthenticationProvider</code> 并不实际使用密码进行身份验证,但它使用当局.</p>
</div>
<div class="paragraph">
<p>如果你参考<a href="#cas-how-it-works">How CAS Works</a> 部分beans 是合理的.</p>
</div>
<div class="paragraph">
<p>这对CAS完成最基本的配置。如果你没有做任何错误,您的web应用程序框架内应该记录地工作CAS的单点登录。没Spring Security 的其他部分的安全需要关心事实CAS处理身份验证。在下面几节中我们将讨论一些更高级的配置(可选).</p>
</div>
</div>
<div class="sect3">
<h4 id="cas-singlelogout"><a class="anchor" href="#cas-singlelogout"></a>Single Logout</h4>
<div class="paragraph">
<p>CAS协议支持单注销和Spring Security 很容易地添加到您的安全配置。下面是更新Spring Security配置处理单注销</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;security:http entry-point-ref="casEntryPoint"&gt;
...
&lt;security:logout logout-success-url="/cas-logout.jsp"/&gt;
&lt;security:custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/&gt;
&lt;security:custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/&gt;
&lt;/security:http&gt;

&lt;!-- This filter handles a Single Logout Request from the CAS Server --&gt;
&lt;bean id="singleLogoutFilter" class="org.jasig.cas.client.session.SingleSignOutFilter"/&gt;

&lt;!-- This filter redirects to the CAS Server to signal Single Logout should be performed --&gt;
&lt;bean id="requestSingleLogoutFilter"
	class="org.springframework.security.web.authentication.logout.LogoutFilter"&gt;
&lt;constructor-arg value="https://localhost:9443/cas/logout"/&gt;
&lt;constructor-arg&gt;
	&lt;bean class=
		"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"/&gt;
&lt;/constructor-arg&gt;
&lt;property name="filterProcessesUrl" value="/logout/cas"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>logout</code>元素记录用户的本地应用程序,但不与CAS服务器终止会话或任何其他已经登录的应用程序。<code>requestSingleLogoutFilter</code>的过滤器将允许 <code>/spring_security_cas_logout</code>请求的url重定向应用程序配置的CAS服务器注销url。然后CAS服务器将发送一个注销请求签署的所有服务.<code>singleLogoutFilter</code>处理单注销请求通过在静态<code>Map</code> 查找的HttpSession然后无效.</p>
</div>
<div class="paragraph">
<p>也许会困惑,为什么<code>logout</code> 元素和<code>singleLogoutFilter</code>是必要的。最佳实践是在当地注销以来首次 <code>SingleSignOutFilter</code>只是将HttpSession的存储在一个静态的<code>Map</code>,以调用无效。与上面的配置中,注销的流程是</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/logout</code> 的用户请求将记录用户的本地应用程序并发送用户注销成功页面。</p>
</li>
<li>
<p>注销成功页面 <code>/cas-logout.jsp</code>’,为了注销的所有应用程序应该指导用户点击一个链接指向的<code>/logout/cas</code>。</p>
</li>
<li>
<p>当用户单击链接时,用户被重定向到中科院单注销URL(<a href="https://localhost:9443/cas/logout" class="bare">https://localhost:9443/cas/logout</a>).</p>
</li>
<li>
<p>在CAS服务器端,CAS单注销URL然后提交单注销所有中科院服务的请求。在中科院服务方面,JASIG invaliditing的<code>SingleSignOutFilter</code>处理注销请求的原始会话。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下一步是添加到你的web.xml中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
&lt;filter-class&gt;
	org.springframework.web.filter.CharacterEncodingFilter
&lt;/filter-class&gt;
&lt;init-param&gt;
	&lt;param-name&gt;encoding&lt;/param-name&gt;
	&lt;param-value&gt;UTF-8&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;listener&gt;
&lt;listener-class&gt;
	org.jasig.cas.client.session.SingleSignOutHttpSessionListener
&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cas-pt-client"><a class="anchor" href="#cas-pt-client"></a>验证与CAS无状态的服务</h4>
<div class="paragraph">
<p>本节描述如何使用CAS认证服务。换句话说,本节将讨论如何建立一个客户使用服务,与 CAS进行身份验证。下一节描述了如何设置使用CAS无状态的服务进行身份验证.</p>
</div>
<div class="sect4">
<h5 id="cas-pt-client-config"><a class="anchor" href="#cas-pt-client-config"></a>配置CAS获得代理发放门票</h5>
<div class="paragraph">
<p>为了验证一个无状态服务,应用程序需要获得一个代理发放门票(页面表)。本节描述如何配置Spring Security获得页面表构建在thencas-st[Service Ticket Authentication] 配置.</p>
</div>
<div class="paragraph">
<p>第一步是包括<code>ProxyGrantingTicketStorage</code>在你的Spring Security配置。这是用于存储页面表所获得<code>CasAuthenticationFilter</code>,这样他们可以用来获得代理票。一个示例配置如下所示</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!--
NOTE: In a real application you should not use an in
		memory implementation. You will also want to ensure
		to clean up expired tickets by calling ProxyGrantingTicketStorage.cleanup()
--&gt;
&lt;bean id="pgtStorage" class="org.jasig.cas.client.proxy.ProxyGrantingTicketStorageImpl"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步是更新的<code>CasAuthenticationProvider</code>能够获得代理票。将 <code>Cas20ServiceTicketValidator</code>替换为一个<code>Cas20ProxyTicketValidator</code>. <code>proxyCallbackUrl</code>应该设置为一个应用程序将接收页面表的URL.最后,配置也应该参考<code>ProxyGrantingTicketStorage</code>所以它可以使用页面表获取代理机票。你可以找到一个例子,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
...
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator"&gt;
	&lt;constructor-arg value="https://localhost:9443/cas"/&gt;
		&lt;property name="proxyCallbackUrl"
		value="https://localhost:8443/cas-sample/login/cas/proxyreceptor"/&gt;
	&lt;property name="proxyGrantingTicketStorage" ref="pgtStorage"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一步是在 <code>ProxyGrantingTicketStorage</code>更新 <code>CasAuthenticationFilter</code> 接受页面表和存储。重要的是<code>proxyReceptorUrl</code>与<code>proxyCallbackUrl</code>匹配的<code>Cas20ProxyTicketValidator</code>.一个示例配置如下所示</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="casFilter"
		class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
	...
	&lt;property name="proxyGrantingTicketStorage" ref="pgtStorage"/&gt;
	&lt;property name="proxyReceptorUrl" value="/login/cas/proxyreceptor"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="cas-pt-client-sample"><a class="anchor" href="#cas-pt-client-sample"></a>使用代理调用无状态服务票</h5>
<div class="paragraph">
<p>现在Spring Security获得页面表,您可以使用它们来创建代理门票可以用来验证无状态的服务,<a href="#cas-sample">CAS sample application</a>在<code>ProxyTicketSampleServlet</code>包含一个工作示例。可以找到示例代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected void doGet(HttpServletRequest request, HttpServletResponse response)
	throws ServletException, IOException {
// NOTE: The CasAuthenticationToken can also be obtained using
// SecurityContextHolder.getContext().getAuthentication()
final CasAuthenticationToken token = (CasAuthenticationToken) request.getUserPrincipal();
// proxyTicket could be reused to make calls to the CAS service even if the
// target url differs
final String proxyTicket = token.getAssertion().getPrincipal().getProxyTicketFor(targetUrl);

// Make a remote call using the proxy ticket
final String serviceUrl = targetUrl+"?ticket="+URLEncoder.encode(proxyTicket, "UTF-8");
String proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, "UTF-8");
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cas-pt"><a class="anchor" href="#cas-pt"></a>代理身份验证票</h4>
<div class="paragraph">
<p><code>CasAuthenticationProvider</code> 的区分有状态的和无状态的客户。一个有状态的客户被认为是提交<code>CasAuthenticationFilter</code>的<code>filterProcessUrl</code>.无状态的客户的任何一个身份验证请求<code>CasAuthenticationFilter</code>比<code>filterProcessUrl</code>另一个URL更好.</p>
</div>
<div class="paragraph">
<p>因为远程协议没有办法展示自己的HttpSession,它不可能依赖于默认的做法将安全上下文存储在会话请求之间。此外,由于CAS服务器无效罚单后,在后续请求中验证了<code>TicketValidator</code>呈现相同的代理机票不会工作.</p>
</div>
<div class="paragraph">
<p>一个显而易见的选择是为远程协议客户不使用CAS。然而,这将消除许多CAS。作为一个中间立场,<code>CasAuthenticationProvider</code>使用<code>StatelessTicketCache</code>.这是仅用于无状态的客户主要使用等于<code>CasAuthenticationFilter.CAS_STATELESS_IDENTIFIER</code>.发生了什么是<code>CasAuthenticationProvider</code>将存储产生的<code>CasAuthenticationToken</code>放在<code>StatelessTicketCache</code>,键控代理机票。因此,远程协议客户可以呈现相同的代理机票和 <code>CasAuthenticationProvider</code>不需要接触CAS服务器进行验证(除了第一个请求)。一旦验证,除了最初的目标服务代理机票可以用于url.</p>
</div>
<div class="paragraph">
<p>本节建立在前面几节容纳代理机票验证.第一步是指定验证所有工件如下所示</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties"&gt;
...
&lt;property name="authenticateAllArtifacts" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步是指定<code>serviceProperties</code>和<code>authenticationDetailsSource</code>和<code>CasAuthenticationFilter</code>。“serviceProperties”属性指示 <code>CasAuthenticationFilter</code>尝试所有的工件进行身份验证,而不是只有出现在<code>filterProcessUrl</code>.<code>ServiceAuthenticationDetailsSource</code>创建了一个<code>ServiceAuthenticationDetails</code> 确保当前URL,基于<code>HttpServletRequest</code>,用作服务URL时验证票。方法用于生成服务URL可以被注入一个自定义定制的<code>AuthenticationDetailsSource</code> ,返回一个自定义<code>ServiceAuthenticationDetails</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
...
&lt;property name="serviceProperties" ref="serviceProperties"/&gt;
&lt;property name="authenticationDetailsSource"&gt;
	&lt;bean class=
	"org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource"&gt;
	&lt;constructor-arg ref="serviceProperties"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还需要更新<code>CasAuthenticationProvider</code>处理代理票。将<code>Cas20ServiceTicketValidator</code>替换为一个<code>Cas20ProxyTicketValidator</code>.您需要配置代理的<code>statelessTicketCache</code>,你想接受。你可以找到一个例子,下面的更新需要接受所有代理.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
...
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator"&gt;
	&lt;constructor-arg value="https://localhost:9443/cas"/&gt;
	&lt;property name="acceptAnyProxy" value="true"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="statelessTicketCache"&gt;
	&lt;bean class="org.springframework.security.cas.authentication.EhCacheBasedTicketCache"&gt;
	&lt;property name="cache"&gt;
		&lt;bean class="net.sf.ehcache.Cache"
			init-method="initialise" destroy-method="dispose"&gt;
		&lt;constructor-arg value="casTickets"/&gt;
		&lt;constructor-arg value="50"/&gt;
		&lt;constructor-arg value="true"/&gt;
		&lt;constructor-arg value="false"/&gt;
		&lt;constructor-arg value="3600"/&gt;
		&lt;constructor-arg value="900"/&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="x509"><a class="anchor" href="#x509"></a>X.509 Authentication</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="x509-overview"><a class="anchor" href="#x509-overview"></a>概述</h3>
<div class="paragraph">
<p>最常用的X.509 证书身份验证是验证服务器在使用SSL的身份,从浏览器通常在使用HTTPS。浏览器会自动检查服务器证书的已发布(即数字签名)的一个受信任的证书颁发机构的列表维护。</p>
</div>
<div class="paragraph">
<p>您还可以使用SSL与"mutual authentication";服务器将请求从客户端作为一个有效的证书的SSL握手。服务器将验证客户端通过检查其签署的证书是一个可接受的权威。如果提供了一个有效的证书,它可以通过servlet API的应用程序。Spring Security X.509模块提取证书使用一个过滤器。它将证书映射到一个应用程序用户和加载用户的组授予机关使用标准的Spring安全基础设施。</p>
</div>
</div>
<div class="sect2">
<h3 id="true-x-509-web"><a class="anchor" href="#true-x-509-web"></a>增加X.509认证您的Web应用程序</h3>
<div class="paragraph">
<p>X.509客户端身份验证非常简单。只是<code>&lt;x509/&gt;</code> 元素添加到您的http安全性名称空间配置.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
	&lt;x509 subject-principal-regex="CN=(.*?)," user-service-ref="userService"/&gt;;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>元素有两个可选属性:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subject-principal-regex</code>正则表达式用来提取用户名从证书的主题名称。上面所示的默认值。这是用户名,将传递给“UserDetailsService”为用户负载当局。</p>
</li>
<li>
<p><code>user-service-ref</code>.这是的bean Id`UserDetailsService`用于x.如果只有一个定义在应用程序上下文它不需要.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>subject-principal-regex</code>应该包含一个组。例如默认表达式"CN=(.*?)," 与常见的名称字段。如果证书的主题名称是"CN=Jimi Hendrix, OU=&#8230;&#8203;",这将给一个用户名"Jimi Hendrix",不分大小写。所以"emailAddress=(.?),"匹配"EMAILADDRESS=<a href="mailto:jimi@hendrix.org">jimi@hendrix.org</a>,CN=&#8230;&#8203;"给一个用户名"<a href="mailto:jimi@hendrix.org">jimi@hendrix.org</a>",如果客户端提供一个证书,成功提取有效的用户名,然后应该有一个有效的安全上下文中的<code>Authentication</code>对象.如果没有找到证书,或没有相应的用户可能会发现然后安全上下文仍将是空的。这意味着您可以轻松地使用 X.509年与其他选项,如基于表单的登录身份验证.</p>
</div>
</div>
<div class="sect2">
<h3 id="x509-ssl-config"><a class="anchor" href="#x509-ssl-config"></a>在Tomcat中设置SSL</h3>
<div class="paragraph">
<p>有一些证书的<code>samples/certificate</code>的目录在春季安全项目.您可以使用这些启用SSL进行测试如果你不想生成自己的.文件的服务器.jks包含服务器证书、私钥和发行证书的证书颁发机构.也有一些客户端证书文件从示例应用程序用户.你可以在你的浏览器安装这些启用SSL客户机身份验证.</p>
</div>
<div class="paragraph">
<p>在SSL支持下tomcat运行,下降的<code>server.jks</code>文件到tomcat的配置的目录并添加以下连接器的`server.xml`l的文件</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" scheme="https" secure="true"
			clientAuth="true" sslProtocol="TLS"
			keystoreFile="${catalina.home}/conf/server.jks"
			keystoreType="JKS" keystorePass="password"
			truststoreFile="${catalina.home}/conf/server.jks"
			truststoreType="JKS" truststorePass="password"
/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你仍然希望SSL连接成功<code>clientAuth</code>也可以被设置为<code>want</code>,即使客户没有提供一个证书。客户不提供证书将无法获得的任何对象的访问Spring Security,除非你使用一个non-X.509认证机制,如表单身份验证.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="runas"><a class="anchor" href="#runas"></a>run - as验证替换</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="runas-overview"><a class="anchor" href="#runas-overview"></a>概述</h3>
<div class="paragraph">
<p><code>AbstractSecurityInterceptor</code> 能够暂时取代<code>Authentication</code>对象在<code>SecurityContext</code>和<code>SecurityContextHolder</code> 安全对象回调阶段。这只发生如果最初的<code>Authentication</code> 对象是成功处理的<code>AuthenticationManager</code>和<code>AccessDecisionManager</code>.<code>RunAsManager</code>将指示更换<code>Authentication</code>对象,如果有的话,应该使用在<code>SecurityInterceptorCallback</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="runas-config"><a class="anchor" href="#runas-config"></a>Configuration</h3>
<div class="paragraph">
<p>Spring Security提供<code>RunAsManager</code> 接口:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Authentication buildRunAs(Authentication authentication, Object object,
	List&lt;ConfigAttribute&gt; config);

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个方法返回<code>Authentication</code>对象应该取代现有的身份验证的对象方法调用的持续时间。如果方法返回<code>null</code>,它表明你没有更换。第二种方法是使用<code>AbstractSecurityInterceptor</code> 启动验证配置属性的一部分。 <code>supports(Class)</code>的方法被调用以确保安全拦截器将安全对象实现配置的`RunAsManager支持的类型安全拦截器.</p>
</div>
<div class="paragraph">
<p>一个具体实现<code>RunAsManager</code>提供Spring Security,如果 <code>ConfigAttribute</code>从 <code>RUN_AS_</code>开始，<code>RunAsManagerImpl</code>的类返回一个替代<code>RunAsUserToken</code>.如果找到任何此类<code>ConfigAttribute</code>,替换“RunAsUserToken”将包含相同的主要,凭证,当局为最初的<code>Authentication</code>对象.伴随着一个新的<code>GrantedAuthorityImpl</code> 为每个<code>RUN_AS_</code> <code>ConfigAttribute</code>.每一个新的<code>GrantedAuthorityImpl</code>将前缀 <code>ROLE_</code>,其次是<code>RUN_AS</code>  <code>ConfigAttribute</code>.例如, <code>RUN_AS_SERVER</code>将导致更换<code>RunAsUserToken</code>包含<code>ROLE_RUN_AS_SERVER</code>授予权力.</p>
</div>
<div class="paragraph">
<p>替代<code>RunAsUserToken</code>就像任何其他身份验证的对象。需要验证的 <code>Authentication</code> ,可能通过一个合适的<code>AuthenticationManager</code>代表团。<code>RunAsImplAuthenticationProvider</code> 执行身份验证。它只是接受任何有效的 <code>RunAsUserToken</code> .</p>
</div>
<div class="paragraph">
<p>为了确保恶意代码不创建一个<code>RunAsUserToken</code>和现在它保证接受‘<code>RunAsImplAuthenticationProvider</code>,散列键存储在所有生成的令牌. <code>RunAsManagerImpl</code>和<code>RunAsImplAuthenticationProvider</code> 中创建bean相同的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="runAsManager"
	class="org.springframework.security.access.intercept.RunAsManagerImpl"&gt;
&lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;

&lt;bean id="runAsAuthenticationProvider"
	class="org.springframework.security.access.intercept.RunAsImplAuthenticationProvider"&gt;
&lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使用相同的密钥,每个<code>RunAsUserToken</code>可以验证它是由一个<code>RunAsManagerImpl</code>批准。出于安全原因 <code>RunAsManagerImpl</code>创造后是不可变的</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="crypto"><a class="anchor" href="#crypto"></a>Spring Security Crypto模块</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="spring-security-crypto-introduction"><a class="anchor" href="#spring-security-crypto-introduction"></a>引言</h3>
<div class="paragraph">
<p>Spring Security Crypto模块提供了对称加密，支持密钥的生成、编码和密码。该代码是分布式的核心模块的一部分
但没有任何其他Spring Security (或Spring) 代码的依赖关系。</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-crypto-encryption"><a class="anchor" href="#spring-security-crypto-encryption"></a>加密器</h3>
<div class="paragraph">
<p>加密类提供了构造对称加密工厂方法,使用这个类 您可以创建字节加密器加密数据在byte[]形式， 你也可以构建textencryptors加密文本字符串，且加密是线程安全的。</p>
</div>
<div class="sect3">
<h4 id="spring-security-crypto-encryption-bytes"><a class="anchor" href="#spring-security-crypto-encryption-bytes"></a>BytesKeyGenerator</h4>
<div class="paragraph">
<p>使用encryptors.standard工厂方法构建 "standard" 字节加密机:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Encryptors.standard("password", "salt");</code></pre>
</div>
</div>
<div class="paragraph">
<p>"standard" 采用的加密方法是：256-bit AES using PKCS #5&#8217;s PBKDF2 (Password-Based Key Derivation Function #2). 这种方法要求 Java 6. 该密码用于生成密钥应存放在安全的地方，不能共享。salt是用来防止在事件中的密钥对密钥的字典攻击，你的加密的数据被泄露 一个16字节的随机初始化向量也适用，所以每个加密的消息是唯一的。</p>
</div>
<div class="paragraph">
<p>所提供的salt应在十六进制编码的字符串形式，是随机的，并至少有8个字节的长度。这种salt可以用keygenerator生成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String salt = KeyGenerators.string().generateKey(); // generates a random 8-byte salt that is then hex-encoded</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-security-crypto-encryption-text"><a class="anchor" href="#spring-security-crypto-encryption-text"></a>TextEncryptor</h4>
<div class="paragraph">
<p>使用encryptors.text工厂方法构建一个标准textencryptor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Encryptors.text("password", "salt");</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>TextEncryptor使用一个标准的bytesencryptor加密文本数据。加密结果返回为十六进制编码的字符串，便于存储在文件系统或数据库中。</pre>
</div>
</div>
<div class="paragraph">
<p>使用encryptors.queryabletext工厂方法构建一个“可查询”textencryptor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Encryptors.queryableText("password", "salt");</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个可查询的textencryptor和标准textencryptor之间的差异做初始化向量 vector(iv) 处理.iv用于查询的textencryptor#加密操作是共享的，或不变的，而不是随机生成的。这意味着同一个文本加密的多次将始终产生相同的加密结果。这是不太安全的，但需要对加密的数据，需要进行查询。可查询加密文本的一个例子是一个OAuth的apikey。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-crypto-keygenerators"><a class="anchor" href="#spring-security-crypto-keygenerators"></a>keygenerators</h3>
<div class="paragraph">
<p>keygenerators类构造密钥生成器不同类型提供了许多便利的工厂方法。 使用这个类，你可以创建一个byteskeygenerator生成byte[]秘钥。你也可以建立一个stringkeygenerator生成字符串键。keygenerators线程是安全的。</p>
</div>
<div class="sect3">
<h4 id="truebyteskeygenerator"><a class="anchor" href="#truebyteskeygenerator"></a>BytesKeyGenerator</h4>
<div class="paragraph">
<p>使用keygenerators.securerandom工厂方法生成的实例byteskeygenerator提供支持:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">KeyGenerator generator = KeyGenerators.secureRandom();
byte[] key = generator.generateKey();</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认密钥长度为8字节.还有一个keygenerators.securerandom变异提供密钥长度控制:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">KeyGenerators.secureRandom(16);</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用keygenerators.shared工厂方法来构建一个byteskeygenerator每次调用，总是返回相同的关键:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">KeyGenerators.shared(16);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truestringkeygenerator"><a class="anchor" href="#truestringkeygenerator"></a>StringKeyGenerator</h4>
<div class="paragraph">
<p>使用keygenerators.string工厂方法构建一个8字节，提供keygenerator进制编码，每个键为字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">KeyGenerators.string();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-crypto-passwordencoders"><a class="anchor" href="#spring-security-crypto-passwordencoders"></a>passwordencoders</h3>
<div class="paragraph">
<p>Spring Security Crypto模块的密码包提供了编码密码支持. <code>PasswordEncoder</code> 是中心的服务接口，并具有以下签名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface PasswordEncoder {

String encode(String rawPassword);

boolean matches(String rawPassword, String encodedPassword);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果rawpassword编码，等于encodedpassword，方法返回true，此方法的目的是支持基于密码的身份验证方案。</p>
</div>
<div class="paragraph">
<p><code>BCryptPasswordEncoder</code> 实现使用广泛支持的“BCrypt”算法哈希密码。BCrypt的使用16字节的随机salt值是故意减慢的算法，以阻碍密码破解。它可以使用“强度”参数，从4到31的“强度”参数来调整它的数量。值越高，就必须做更多的工作来计算哈希值。默认值为10。您可以在部署的系统中更改此值，而不影响现有的密码，因为该值也存储在编码的散列中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Create an encoder with strength 16
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16);
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>`Pbkdf2PasswordEncoder`实现使用PBKDF2算法哈希密码。为了打败密码破解PBKDF2是故意慢的算法，调整需要。用5秒来验证你的系统上的密码。</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Create an encoder with all the defaults
Pbkdf2PasswordEncoder encoder = new Pbkdf2PasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrency"><a class="anchor" href="#concurrency"></a>并发支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在大多数环境中，安全存储在每一个 <code>Thread</code> 基础. 这意味着当工作是在一个新的 <code>Thread</code>,<code>SecurityContext</code> 失去了 Spring Security provides提供了一些基础设施，以帮助使这更容 易为用户，Spring Security提供了低级别的抽象，用于在多线程环境中使用 Spring Security，事实上，这是Spring Security建立与整合 <a href="#servletapi-start-runnable">AsyncContext.start(Runnable)</a> 和 <a href="#mvc-async">Spring MVC 异步集成</a>.</p>
</div>
<div class="sect2">
<h3 id="truedelegatingsecuritycontextrunnable"><a class="anchor" href="#truedelegatingsecuritycontextrunnable"></a>DelegatingSecurityContextRunnable</h3>
<div class="paragraph">
<p>最基本的建筑块内Spring Security&#8217;s并发支持<code>DelegatingSecurityContextRunnable</code>. 不包委托<code>Runnable</code>为了初始化的<code>SecurityContextHolder</code> 用指定的<code>SecurityContext</code>为代表。然后调用委托运行保障明确<code>SecurityContextHolder</code>以后<code>DelegatingSecurityContextRunnable</code> 有些东西看起来就像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public void run() {
try {
	SecurityContextHolder.setContext(securityContext);
	delegate.run();
} finally {
	SecurityContextHolder.clearContext();
}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然很简单，但这使得它无缝的securitycontext从一个线程转移到另一个。这很重要，因为，在大多数情况下，每个线程的基础上的securitycontextholder行为都可能使用了Spring Security的 <a href="#nsa-global-method-security">&lt;global-method-security&gt;</a> 来支持你的服务，你现在可以很容易地转移 <code>SecurityContext</code> 当前 <code>Thread</code>到 <code>Thread</code> 调用安全服务。下面是你如何做这件事的一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Runnable originalRunnable = new Runnable() {
public void run() {
	// invoke secured service
}
};

SecurityContext context = SecurityContextHolder.getContext();
DelegatingSecurityContextRunnable wrappedRunnable =
	new DelegatingSecurityContextRunnable(originalRunnable, context);

new Thread(wrappedRunnable).start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码执行以下步骤:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建一个<code>Runnable</code> 这是我们的invoking安全服务，但请注意这是不相关的Spring Security。</p>
</li>
<li>
<p>获得<code>SecurityContext</code>我们希望从<code>SecurityContextHolder</code>中初始化<code>DelegatingSecurityContextRunnable</code>。</p>
</li>
<li>
<p>使用<code>DelegatingSecurityContextRunnable</code>创建一个线程。</p>
</li>
<li>
<p>自从创建了<code>DelegatingSecurityContextRunnable</code>和<code>SecurityContext</code>从<code>SecurityContextHolder</code>这里有一个快捷方式的构造函数，下面的代码与前面的代码相同：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Runnable originalRunnable = new Runnable() {
public void run() {
	// invoke secured service
}
};

DelegatingSecurityContextRunnable wrappedRunnable =
	new DelegatingSecurityContextRunnable(originalRunnable);

new Thread(wrappedRunnable).start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们有的代码是简单使用的,但它仍然需要使用我们的 Spring Security知识。 在下一节中，我们将看看我们如何利用<code>DelegatingSecurityContextExecutor</code>隐藏的因素来使用Spring Security。</p>
</div>
</div>
<div class="sect2">
<h3 id="truedelegatingsecuritycontextexecutor"><a class="anchor" href="#truedelegatingsecuritycontextexecutor"></a>DelegatingSecurityContextExecutor</h3>
<div class="paragraph">
<p>在前面的章节中，我们发现，它是很容易使用的<code>DelegatingSecurityContextRunnable</code>,但它是不理想，不方便的，因为我们必须意识到Spring Security 是为了使用它.让我们看看<code>DelegatingSecurityContextExecutor</code>如何能屏蔽我们的任何代码知识，如果我们使用Spring Security.</p>
</div>
<div class="paragraph">
<p>设计<code>DelegatingSecurityContextExecutor</code>是非常相似于<code>DelegatingSecurityContextRunnable</code>除非它接受委托<code>Executor</code>而不是一个代表<code>Runnable</code>。你可以看到一个例子，它可能会被用在下面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">SecurityContext context = SecurityContextHolder.createEmptyContext();
Authentication authentication =
	new UsernamePasswordAuthenticationToken("user","doesnotmatter", AuthorityUtils.createAuthorityList("ROLE_USER"));
context.setAuthentication(authentication);

SimpleAsyncTaskExecutor delegateExecutor =
	new SimpleAsyncTaskExecutor();
DelegatingSecurityContextExecutor executor =
	new DelegatingSecurityContextExecutor(delegateExecutor, context);

Runnable originalRunnable = new Runnable() {
public void run() {
	// invoke secured service
}
};

executor.execute(originalRunnable);</code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码执行以下步骤:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建<code>SecurityContext</code>用于我们的<code>DelegatingSecurityContextExecutor</code>。请注意，在这个例子中，我们简单地手工创建<code>SecurityContext</code>。然而在哪里或者怎么得到并不重要<code>SecurityContext</code> (i.e. 我们可以从这里获得<code>SecurityContextHolder</code> 如果我们想要)。</p>
</li>
<li>
<p>创建一个delegateexecutor是在执行提交`Runnable``s</p>
</li>
<li>
<p>最后我们创建一个 <code>DelegatingSecurityContextExecutor</code>这是在包装任何运行，传递到执行的方法<code>DelegatingSecurityContextRunnable</code>. 在这个实例中，将包里的delegateexec运行， <code>SecurityContext</code> 将每一个Runnable提交给我们 <code>DelegatingSecurityContextExecutor</code>. 如果我们运行后台任务，需要由一个具有提升权限的用户运行，这是非常好的，</p>
</li>
<li>
<p>在这一点上，你可能会问自己 "我该如何保护我所学过的 Spring Security代码知识?"来代替创建<code>SecurityContext`andthe`DelegatingSecurityContextExecutor</code> 在我们的代码中, 我们可以注入一个已经初始化的实例<code>DelegatingSecurityContextExecutor</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
private Executor executor; // becomes an instance of our DelegatingSecurityContextExecutor

public void submitRunnable() {
Runnable originalRunnable = new Runnable() {
	public void run() {
	// invoke secured service
	}
};
executor.execute(originalRunnable);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们的代码是不可知的 <code>SecurityContext</code> 正在传播到<code>Thread</code>,然后<code>originalRunnable</code> 被执行，然后<code>SecurityContextHolder</code> 被清除。在这个示例中，同一个用户正在被用于执行每个线程.如果我们想使用户从 <code>SecurityContextHolder</code> at the time we invoked <code>executor.execute(Runnable)</code> (i.e. the currently logged in user) 处理 <code>originalRunnable</code>? 是可以做到的  removing the <code>SecurityContext</code>我们的争论是 <code>DelegatingSecurityContextExecutor</code>构造函数，比如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">SimpleAsyncTaskExecutor delegateExecutor = new SimpleAsyncTaskExecutor();
DelegatingSecurityContextExecutor executor =
	new DelegatingSecurityContextExecutor(delegateExecutor);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在任何时候 <code>executor.execute(Runnable)</code> 执行 <code>SecurityContext</code> 是首先获得的 <code>SecurityContextHolder</code> 然后 <code>SecurityContext</code> 是用来创建 <code>DelegatingSecurityContextRunnable</code>的. 这意味着我们正在执行的 <code>Runnable</code> 使用相同的用户来调用 <code>executor.execute(Runnable)</code> 代码.</p>
</div>
</div>
<div class="sect2">
<h3 id="truespring-security-concurrency"><a class="anchor" href="#truespring-security-concurrency"></a>Spring Security Concurrency 并发类</h3>
<div class="paragraph">
<p>指javadoc额外的集成与java并发API和Spring的抽象任务，一旦你理解了以前的代码你会发现，他们的解释是很单一的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DelegatingSecurityContextCallable</p>
</li>
<li>
<p>DelegatingSecurityContextExecutor</p>
</li>
<li>
<p>DelegatingSecurityContextExecutorService</p>
</li>
<li>
<p>DelegatingSecurityContextRunnable</p>
</li>
<li>
<p>DelegatingSecurityContextScheduledExecutorService</p>
</li>
<li>
<p>DelegatingSecurityContextSchedulingTaskExecutor</p>
</li>
<li>
<p>DelegatingSecurityContextAsyncTaskExecutor</p>
</li>
<li>
<p>DelegatingSecurityContextTaskExecutor</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc"><a class="anchor" href="#mvc"></a>Spring MVC 整合</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 本节涵盖了进一步的细节的集成， 提供了一些可选的集成与Spring MVC</p>
</div>
<div class="sect2">
<h3 id="mvc-enablewebmvcsecurity"><a class="anchor" href="#mvc-enablewebmvcsecurity"></a>@EnableWebMvcSecurity</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security 4.0, <code>@EnableWebMvcSecurity</code> 是 不好的. 更换 <code>@EnableWebSecurity</code> w这决定将基于加入Spring MVC的特点。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使MVC和Spring Security更好的整合与集成<code>@EnableWebSecurity</code> 对你的配置的注释。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security 提供配置使用 Spring MVC&#8217;s <a href="http://docs.spring.io/spring-framework/docs/4.1.x/spring-framework-reference/htmlsingle/#mvc-config-customize">WebMvcConfigurerAdapter</a>. 这意味着，如果你使用的是更高级的选项，如 <code>WebMvcConfigurationSupport</code> ，那么你将需要手动提供 Spring Security 配置.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mvc-requestmatcher"><a class="anchor" href="#mvc-requestmatcher"></a>MvcRequestMatcher</h3>
<div class="paragraph">
<p>Spring Security 提供如何深度整合Spring MVC 匹配的网址和 <code>MvcRequestMatcher</code>.
这是有帮助的，以确保您的Security规则匹配用于处理您的请求的逻辑.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>它总是建议提供授权规则匹配的<code>HttpServletRequest</code>和方法的安全性.</p>
</div>
<div class="paragraph">
<p>通过匹配提供授权规则<code>HttpServletRequest</code>是很好的，因为它很早就发生在代码路径，https://en.wikipedia.org/wiki/Attack_surface[attack surface].方法安全性确保如果有人绕过了Web权限规则，您的应用程序仍然是安全的.
这是你该知道的 <a href="https://en.wikipedia.org/wiki/Defense_in_depth_(computing)">Defence in Depth</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>考虑一个控制器映射如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping("/admin")
public String admin() {</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们想通过限制访问该控制器的方法来管理用户, 一个开发人员可以通过匹配的 <code>HttpServletRequest</code> 得到以下的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.antMatchers("/admin").hasRole("ADMIN");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者在xml中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/admin" access="hasRole('ADMIN')"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何配置URL <code>/admin</code>将经过身份验证的用户作为管理用户.
然而, 这取决于我们 Spring MVC配置, URL <code>/admin.html</code>也会告诉我们<code>admin()</code> 方法.</p>
</div>
<div class="paragraph">
<p>问题是，我们的安全规则只是保护 <code>/admin</code>.
我们可以为所有的排列添加额外的规则 Spring MVC,但这将是相当冗长而乏味的.</p>
</div>
<div class="paragraph">
<p>相反，我们可以利用Spring Security&#8217;s <code>MvcRequestMatcher</code>.
下面的配置会保护，Spring MVC将匹配利用Spring MVC匹配URL的URL。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.mvcMatchers("/admin").hasRole("ADMIN");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在XML中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;http request-matcher="mvc"&gt;
	&lt;intercept-url pattern="/admin" access="hasRole('ADMIN')"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-authentication-principal"><a class="anchor" href="#mvc-authentication-principal"></a>@AuthenticationPrincipal</h3>
<div class="paragraph">
<p>Spring Security provides <code>AuthenticationPrincipalArgumentResolver</code> 能解决问题 <code>Authentication.getPrincipal()</code> 对于 Spring MVC 争论. 通过使用 <code>@EnableWebSecurity</code> 您将自动将此添加到您的 Spring MVC 配置. 如果你使用 XML 基于你的配置, 你必须自己添加这个。例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:annotation-driven&gt;
		&lt;mvc:argument-resolvers&gt;
				&lt;bean class="org.springframework.security.web.method.annotation.AuthenticationPrincipalArgumentResolver" /&gt;
		&lt;/mvc:argument-resolvers&gt;
&lt;/mvc:annotation-driven&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦 <code>AuthenticationPrincipalArgumentResolver</code> 是正确配置的，您可以完全完成 Spring Security 在Spring MVC层。</p>
</div>
<div class="paragraph">
<p>考虑一个自定义的情况 <code>UserDetailsService</code>返回一个 <code>Object</code> 实现 <code>UserDetails</code> 你自己的 <code>CustomUser</code> <code>Object</code>. 和 <code>CustomUser</code> 当前已验证的用户可以使用以下代码访问:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser() {
	Authentication authentication =
	SecurityContextHolder.getContext().getAuthentication();
	CustomUser custom = (CustomUser) authentication == null ? null : authentication.getPrincipal();

	// .. find messags for this user and return them ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>至于 Spring Security 3.2 我们可以更直接地通过添加注释来解决这个问题。例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.security.core.annotation.AuthenticationPrincipal;

// ...

@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser(@AuthenticationPrincipal CustomUser customUser) {

	// .. find messags for this user and return them ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时，它可能是必要的，以某种方式来改造.
比如, 如果 <code>CustomUser</code> 需要是最终它不能被扩展。
在这种情况下 <code>UserDetailsService</code> 可能会返回一个 <code>Object</code> 实现 <code>UserDetails</code>并提供了一个命名的方法 <code>getCustomUser</code> 访问 <code>CustomUser</code>.
比如，他看起来是这个样子的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CustomUserUserDetails extends User {
		// ...
		public CustomUser getCustomUser() {
				return customUser;
		}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以访问 <code>CustomUser</code> 使用 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html">SpEL expression</a> 使用 <code>Authentication.getPrincipal()</code> 作为根对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.security.core.annotation.AuthenticationPrincipal;

// ...

@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser(@AuthenticationPrincipal(expression = "customUser") CustomUser customUser) {

	// .. find messags for this user and return them ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以进一步消除我们的依赖 Spring Security通过标记 <code>@AuthenticationPrincipal</code> 我们有我们自己的元注释注释. 下面，我们展示了如何我们可以这样做的注释命名 <code>@CurrentUser</code>.</p>
</div>
<div class="paragraph">
<p>NOTE:重要的是要认识到消除依赖 Spring Security,它是将创建的消耗应用程序 <code>@CurrentUser</code>. 这一步不是严格要求，但有助于隔离你的依赖 Spring Security 到一个更重要的位置.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target({ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@AuthenticationPrincipal
public @interface CurrentUser {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在<code>@CurrentUser</code> 已指定, 我们可以用它来信号来解决我们的 <code>CustomUser</code>当前已验证的用户孤立了我们依赖 Spring Security 到一个单一的文件.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser(@CurrentUser CustomUser customUser) {

	// .. find messags for this user and return them ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-async"><a class="anchor" href="#mvc-async"></a>Spring MVC 异步集成</h3>
<div class="paragraph">
<p>Spring Web MVC 3.2+ 有极好的支持 <a href="http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-ann-async">Asynchronous Request Processing</a>. 没有额外的配置, Spring Security 将自动设置 <code>SecurityContext</code> 到 <code>Thread</code>执行 <code>Callable</code> 由你的控制器返回. 例如，下面的方法将自动有它的 <code>Callable</code> 执行的 <code>SecurityContext</code> 这是可用的，当 <code>Callable</code> 被创建:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping(method=RequestMethod.POST)
public Callable&lt;String&gt; processUpload(final MultipartFile file) {

return new Callable&lt;String&gt;() {
	public Object call() throws Exception {
	// ...
	return "someView";
	}
};
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Associating SecurityContext to Callable&#8217;s</div>
<div class="paragraph">
<p>从技术上讲, Spring Security 结合 <code>WebAsyncManager</code>.  <code>SecurityContext</code>这是用来处理 <code>Callable</code> 是 <code>SecurityContext</code> 存在于 <code>SecurityContextHolder</code> 此时 <code>startCallableProcessing</code> 被调用.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>没有一个自动集成与 <code>DeferredResult</code>由控制器返回.
这是因为 <code>DeferredResult</code> 是由用户处理的，因此没有自动整合的方式。
当然, 你依然可以用 <a href="#concurrency">Concurrency Support</a>提供透明的集成与 Spring Security.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-csrf"><a class="anchor" href="#mvc-csrf"></a>Spring MVC 和 CSRF 整合</h3>
<div class="sect3">
<h4 id="true--35"><a class="anchor" href="#true--35"></a>自动令牌包</h4>
<div class="paragraph">
<p>Spring Security 将自动 <a href="#csrf-include-csrf-token">include the CSRF Token</a> 使用形式为 <a href="http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/view.html#view-jsp-formtaglib-formtag">Spring MVC form tag</a>. 比如说, 下面的 JSP:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page"
	xmlns:c="http://java.sun.com/jsp/jstl/core"
	xmlns:form="http://www.springframework.org/tags/form" version="2.0"&gt;
	&lt;jsp:directive.page language="java" contentType="text/html" /&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"&gt;
	&lt;!-- ... --&gt;

	&lt;c:url var="logoutUrl" value="/logout"/&gt;
	&lt;form:form action="${logoutUrl}"
		method="post"&gt;
	&lt;input type="submit"
		value="Log out" /&gt;
	&lt;input type="hidden"
		name="${_csrf.parameterName}"
		value="${_csrf.token}"/&gt;
	&lt;/form:form&gt;

	&lt;!-- ... --&gt;
&lt;/html&gt;
&lt;/jsp:root&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>将输出HTML，类似于下面的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- ... --&gt;

&lt;form action="/context/logout" method="post"&gt;
&lt;input type="submit" value="Log out"/&gt;
&lt;input type="hidden" name="_csrf" value="f81d4fae-7dec-11d0-a765-00a0c91e6bf6"/&gt;
&lt;/form&gt;

&lt;!-- ... --&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-csrf-resolver"><a class="anchor" href="#mvc-csrf-resolver"></a>解决 CsrfToken</h4>
<div class="paragraph">
<p>Spring Security 提供 <code>CsrfTokenArgumentResolver</code> 就能自动解决 <code>CsrfToken</code>  Spring MVC 争论.
通过使用 <a href="#jc-hello-wsca">@EnableWebSecurity</a> 您将自动将此添加到您的 Spring MVC 配置.
如果你使用基于XML的配置，您必须自己手动添加.</p>
</div>
<div class="paragraph">
<p>一旦 <code>CsrfTokenArgumentResolver</code> 是正确配置的，你可以暴露 <code>CsrfToken</code> 你的静态HTML为基础的应用.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
public class CsrfController {

	@RequestMapping("/csrf")
	public CsrfToken csrf(CsrfToken token) {
		return token;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>重要的是要保持 <code>CsrfToken</code> 从其他域的一个秘密.
这意味着如果你正在使https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS[Cross Origin Sharing (CORS)], 你应该 <strong>NOT</strong> 暴露 <code>CsrfToken</code> 到任何外部域.</p>
</div>
</div>
</div>
</div>
</div>
<h1 id="data" class="sect0"><a class="anchor" href="#data"></a>Spring Data 整合</h1>
<div class="paragraph">
<p>Spring Security 提供 Spring  Data整合允许在您的查询中引用当前的用户.
它很有用，但要包括在查询用户支持分页结果由于过滤后，结果规模不会减少。</p>
</div>
<div class="sect1">
<h2 id="data-configuration"><a class="anchor" href="#data-configuration"></a>Spring 数据 &amp; Spring 安全配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要使用这种支持，提供一个类型的 <code>SecurityEvaluationContextExtension</code>.
在Java配置中, 他看起来会是这个样子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public SecurityEvaluationContextExtension securityEvaluationContextExtension() {
	return new SecurityEvaluationContextExtension();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在XMl配置中, 他看起来会是这个样子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.security.data.repository.query.SecurityEvaluationContextExtension"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-query"><a class="anchor" href="#data-query"></a>安全的表达 @Query</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如今 Spring Security 可以在您的查询中使用，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Repository
public interface MessageRepository extends PagingAndSortingRepository&lt;Message,Long&gt; {
	@Query("select m from Message m where m.to.id = ?#{ principal?.id }")
	Page&lt;Message&gt; findInbox(Pageable pageable);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查 <code>Authentication.getPrincipal().getId()</code>看看是否 平等于容器 <code>Message</code>.
请注意，这个示例假定您已定制了一个对象的，该对象是具有一个身份属性.
通过暴露 <code>SecurityEvaluationContextExtension</code> bean, 所有的<a href="#common-expressions">Common Security Expressions</a> 可用在 Query.</p>
</div>
</div>
</div>
<h1 id="trueappendix" class="sect0"><a class="anchor" href="#trueappendix"></a>Appendix</h1>
<div class="sect1">
<h2 id="appendix-schema"><a class="anchor" href="#appendix-schema"></a>安全数据库模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有使用的框架和本附录提供了一个单一的参考点和给 他们所有的不同的数据库模式. 你只需要为你需要的部分提供functonality表.</p>
</div>
<div class="paragraph">
<p>DDL声明给出了 HSQLDB 数据库.您可以使用这些作为定义您正在使用的数据库的架构的指导方针.</p>
</div>
<div class="sect2">
<h3 id="true--36"><a class="anchor" href="#true--36"></a>用户模式</h3>
<div class="paragraph">
<p>JDBC 的标准实现了<code>UserDetailsService</code> (<code>JdbcDaoImpl</code>) 需要表加载密码, 帐户状态(可用或者不可用)和权力名单 (角色) 给用户. 您将需要调整此架构以与您正在使用的数据库语言相匹配.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>create table users(
	username varchar_ignorecase(50) not null primary key,
	password varchar_ignorecase(50) not null,
	enabled boolean not null
);

create table authorities (
	username varchar_ignorecase(50) not null,
	authority varchar_ignorecase(50) not null,
	constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="true--37"><a class="anchor" href="#true--37"></a>集团机关</h4>
<div class="paragraph">
<p>Spring Security 2.0 介绍了当前组支持 <code>JdbcDaoImpl</code>.如果组启用表，结构如下. 您将需要调整此架构以与您正在使用的数据库语言相匹配.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>create table groups (
	id bigint generated by default as identity(start with 0) primary key,
	group_name varchar_ignorecase(50) not null
);

create table group_authorities (
	group_id bigint not null,
	authority varchar(50) not null,
	constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
	id bigint generated by default as identity(start with 0) primary key,
	username varchar(50) not null,
	group_id bigint not null,
	constraint fk_group_members_group foreign key(group_id) references groups(id)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，这些表只需要由您使用所提供的JDBC <code>UserDetailsService</code> 实施. 如果你自己写或选择实施 <code>AuthenticationProvider</code> 没有 <code>UserDetailsService</code>,然后只要接口的合同是满意的，你有完整的自由来存储的数据。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true-schema"><a class="anchor" href="#true-schema"></a>持续登录 (记住我) Schema</h3>
<div class="paragraph">
<p>此表用于存储更安全的使用的数据 <a href="#remember-me-persistent-token">persistent token</a> remember-me 实施. 如果你正在使用 <code>JdbcTokenRepositoryImpl</code> 无论是直接或通过命名空间，您都将需要此表. 请记住调整此架构以与您正在使用的数据库语言相匹配.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>create table persistent_logins (
	username varchar(64) not null,
	series varchar(64) primary key,
	token varchar(64) not null,
	last_used timestamp not null
);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dbschema-acl"><a class="anchor" href="#dbschema-acl"></a>ACL Schema</h3>
<div class="paragraph">
<p>有四个表所使用 Spring Security <a href="#domain-acls">ACL</a> 实施.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>acl_sid</code> Store身份确认和安全通过ALC系统来保障， 这些可以适用于唯一的或者多个负责人。</p>
</li>
<li>
<p><code>acl_class</code>定义域的对象类型的ACL应用。 <code>class</code>列储存java类对象名称。</p>
</li>
<li>
<p><code>acl_object_identity</code> 储存的具体领域对象的标识的定义.</p>
</li>
<li>
<p><code>acl_entry</code> 储存的ACL权限适用于一个特定的对象标识和安全标识。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>它假定数据库将自动生成每个身份的主键。 <code>JdbcMutableAclService</code> 必须能够检索这些时，它已创建了一个新的行 <code>acl_sid</code> 或者 <code>acl_class</code>表。它有两个属性定义需要检索这些值的SQL <code>classIdentityQuery</code> 和 <code>sidIdentityQuery</code>. 这两个默认 <code>call identity()</code></p>
</div>
<div class="paragraph">
<p>ACL加工创建JRC包含在hypersql创建ACL模式的文件 (HSQLDB), PostgreSQL, MySQL/MariaDB, Microsoft SQL Server, and Oracle 数据库。 这些架构也被证明在以下几个部分.</p>
</div>
<div class="sect3">
<h4 id="truehypersql"><a class="anchor" href="#truehypersql"></a>HyperSQL</h4>
<div class="paragraph">
<p>默认架构的工作，采用的是单元测试的框架内嵌入的HSQLDB数据库.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl" data-lang="ddl">create table acl_sid(
	id bigint generated by default as identity(start with 100) not null primary key,
	principal boolean not null,
	sid varchar_ignorecase(100) not null,
	constraint unique_uk_1 unique(sid,principal)
);

create table acl_class(
	id bigint generated by default as identity(start with 100) not null primary key,
	class varchar_ignorecase(100) not null,
	constraint unique_uk_2 unique(class)
);

create table acl_object_identity(
	id bigint generated by default as identity(start with 100) not null primary key,
	object_id_class bigint not null,
	object_id_identity bigint not null,
	parent_object bigint,
	owner_sid bigint,
	entries_inheriting boolean not null,
	constraint unique_uk_3 unique(object_id_class,object_id_identity),
	constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),
	constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),
	constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id)
);

create table acl_entry(
	id bigint generated by default as identity(start with 100) not null primary key,
	acl_object_identity bigint not null,
	ace_order int not null,
	sid bigint not null,
	mask integer not null,
	granting boolean not null,
	audit_success boolean not null,
	audit_failure boolean not null,
	constraint unique_uk_4 unique(acl_object_identity,ace_order),
	constraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id),
	constraint foreign_fk_5 foreign key(sid) references acl_sid(id)
);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truepostgresql"><a class="anchor" href="#truepostgresql"></a>PostgreSQL</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl" data-lang="ddl">create table acl_sid(
	id bigserial not null primary key,
	principal boolean not null,
	sid varchar(100) not null,
	constraint unique_uk_1 unique(sid,principal)
);

create table acl_class(
	id bigserial not null primary key,
	class varchar(100) not null,
	constraint unique_uk_2 unique(class)
);

create table acl_object_identity(
	id bigserial primary key,
	object_id_class bigint not null,
	object_id_identity bigint not null,
	parent_object bigint,
	owner_sid bigint,
	entries_inheriting boolean not null,
	constraint unique_uk_3 unique(object_id_class,object_id_identity),
	constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),
	constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),
	constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id)
);

create table acl_entry(
	id bigserial primary key,
	acl_object_identity bigint not null,
	ace_order int not null,
	sid bigint not null,
	mask integer not null,
	granting boolean not null,
	audit_success boolean not null,
	audit_failure boolean not null,
	constraint unique_uk_4 unique(acl_object_identity,ace_order),
	constraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id),
	constraint foreign_fk_5 foreign key(sid) references acl_sid(id)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>你将不得不分别地设置 <code>classIdentityQuery</code>和 <code>sidIdentityQuery</code> 性能 <code>JdbcMutableAclService</code> 以下的值, :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>select currval(pg_get_serial_sequence('acl_class', 'id'))</code></p>
</li>
<li>
<p><code>select currval(pg_get_serial_sequence('acl_sid', 'id'))</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="truemysql-and-mariadb"><a class="anchor" href="#truemysql-and-mariadb"></a>MySQL and MariaDB</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl" data-lang="ddl">CREATE TABLE acl_sid (
	id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
	principal BOOLEAN NOT NULL,
	sid VARCHAR(100) NOT NULL,
	UNIQUE KEY unique_acl_sid (sid, principal)
) ENGINE=InnoDB;

CREATE TABLE acl_class (
	id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
	class VARCHAR(100) NOT NULL,
	UNIQUE KEY uk_acl_class (class)
) ENGINE=InnoDB;

CREATE TABLE acl_object_identity (
	id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
	object_id_class BIGINT UNSIGNED NOT NULL,
	object_id_identity BIGINT NOT NULL,
	parent_object BIGINT UNSIGNED,
	owner_sid BIGINT UNSIGNED,
	entries_inheriting BOOLEAN NOT NULL,
	UNIQUE KEY uk_acl_object_identity (object_id_class, object_id_identity),
	CONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id),
	CONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id),
	CONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id)
) ENGINE=InnoDB;

CREATE TABLE acl_entry (
	id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
	acl_object_identity BIGINT UNSIGNED NOT NULL,
	ace_order INTEGER NOT NULL,
	sid BIGINT UNSIGNED NOT NULL,
	mask INTEGER UNSIGNED NOT NULL,
	granting BOOLEAN NOT NULL,
	audit_success BOOLEAN NOT NULL,
	audit_failure BOOLEAN NOT NULL,
	UNIQUE KEY unique_acl_entry (acl_object_identity, ace_order),
	CONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id),
	CONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id)
) ENGINE=InnoDB;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truemicrosoft-sql-server"><a class="anchor" href="#truemicrosoft-sql-server"></a>Microsoft SQL Server</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl" data-lang="ddl">CREATE TABLE acl_sid (
	id BIGINT NOT NULL IDENTITY PRIMARY KEY,
	principal BIT NOT NULL,
	sid VARCHAR(100) NOT NULL,
	CONSTRAINT unique_acl_sid UNIQUE (sid, principal)
);

CREATE TABLE acl_class (
	id BIGINT NOT NULL IDENTITY PRIMARY KEY,
	class VARCHAR(100) NOT NULL,
	CONSTRAINT uk_acl_class UNIQUE (class)
);

CREATE TABLE acl_object_identity (
	id BIGINT NOT NULL IDENTITY PRIMARY KEY,
	object_id_class BIGINT NOT NULL,
	object_id_identity BIGINT NOT NULL,
	parent_object BIGINT,
	owner_sid BIGINT,
	entries_inheriting BIT NOT NULL,
	CONSTRAINT uk_acl_object_identity UNIQUE (object_id_class, object_id_identity),
	CONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id),
	CONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id),
	CONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id)
);

CREATE TABLE acl_entry (
	id BIGINT NOT NULL IDENTITY PRIMARY KEY,
	acl_object_identity BIGINT NOT NULL,
	ace_order INTEGER NOT NULL,
	sid BIGINT NOT NULL,
	mask INTEGER NOT NULL,
	granting BIT NOT NULL,
	audit_success BIT NOT NULL,
	audit_failure BIT NOT NULL,
	CONSTRAINT unique_acl_entry UNIQUE (acl_object_identity, ace_order),
	CONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id),
	CONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id)
);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueoracle-database"><a class="anchor" href="#trueoracle-database"></a>Oracle Database</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl" data-lang="ddl">CREATE TABLE acl_sid (
	id NUMBER(38) NOT NULL PRIMARY KEY,
	principal NUMBER(1) NOT NULL CHECK (principal in (0, 1)),
	sid NVARCHAR2(100) NOT NULL,
	CONSTRAINT unique_acl_sid UNIQUE (sid, principal)
);
CREATE SEQUENCE acl_sid_sequence START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER acl_sid_id_trigger
	BEFORE INSERT ON acl_sid
	FOR EACH ROW
BEGIN
	SELECT acl_sid_sequence.nextval INTO :new.id FROM dual;
END;

CREATE TABLE acl_class (
	id NUMBER(38) NOT NULL PRIMARY KEY,
	class NVARCHAR2(100) NOT NULL,
	CONSTRAINT uk_acl_class UNIQUE (class)
);
CREATE SEQUENCE acl_class_sequence START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER acl_class_id_trigger
	BEFORE INSERT ON acl_class
	FOR EACH ROW
BEGIN
	SELECT acl_class_sequence.nextval INTO :new.id FROM dual;
END;

CREATE TABLE acl_object_identity (
	id NUMBER(38) NOT NULL PRIMARY KEY,
	object_id_class NUMBER(38) NOT NULL,
	object_id_identity NUMBER(38) NOT NULL,
	parent_object NUMBER(38),
	owner_sid NUMBER(38),
	entries_inheriting NUMBER(1) NOT NULL CHECK (entries_inheriting in (0, 1)),
	CONSTRAINT uk_acl_object_identity UNIQUE (object_id_class, object_id_identity),
	CONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id),
	CONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id),
	CONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id)
);
CREATE SEQUENCE acl_object_identity_sequence START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER acl_object_identity_id_trigger
	BEFORE INSERT ON acl_object_identity
	FOR EACH ROW
BEGIN
	SELECT acl_object_identity_sequence.nextval INTO :new.id FROM dual;
END;

CREATE TABLE acl_entry (
	id NUMBER(38) NOT NULL PRIMARY KEY,
	acl_object_identity NUMBER(38) NOT NULL,
	ace_order INTEGER NOT NULL,
	sid NUMBER(38) NOT NULL,
	mask INTEGER NOT NULL,
	granting NUMBER(1) NOT NULL CHECK (granting in (0, 1)),
	audit_success NUMBER(1) NOT NULL CHECK (audit_success in (0, 1)),
	audit_failure NUMBER(1) NOT NULL CHECK (audit_failure in (0, 1)),
	CONSTRAINT unique_acl_entry UNIQUE (acl_object_identity, ace_order),
	CONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id),
	CONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id)
);
CREATE SEQUENCE acl_entry_sequence START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER acl_entry_id_trigger
	BEFORE INSERT ON acl_entry
	FOR EACH ROW
BEGIN
	SELECT acl_entry_sequence.nextval INTO :new.id FROM dual;
END;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix-namespace"><a class="anchor" href="#appendix-namespace"></a>安全空间</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本附录提供了在安全命名空间中可用的元素以及它们创建的基础上的信息的元素的引用 (个别类的知识，和他们是如何一起工作的，假设你可以找到项目中的javadoc更多信息和本文档中的其他部分)。 如果您以前没有使用过命名空间，请阅读这部分。 <a href="#ns-config">introductory chapter</a> 对命名空间的配置, 这是作为一个补充的信息。 使用一个很好的质量的XML编辑器，同时编辑一个基于架构的配置建议，这将提供有关的元素和属性的上下文信息，以及解释他们的目的。 命名空间是写在 <a href="http://www.relaxng.org/">RELAX NG</a> 的紧凑的格式，后来转为XSD架构. 如果您对这种格式很熟悉，您可能希望检查它。 <a href="https://raw.githubusercontent.com/spring-projects/spring-security/master/config/src/main/resources/org/springframework/security/config/spring-security-4.1.rnc">schema file</a> 直接。</p>
</div>
<div class="sect2">
<h3 id="nsa-web"><a class="anchor" href="#nsa-web"></a>Web应用安全</h3>
<div class="sect3">
<h4 id="nsa-debug"><a class="anchor" href="#nsa-debug"></a>&lt;debug&gt;</h4>
<div class="paragraph">
<p>启用Spring Security调试基础设施。这将给人类提供可读的 (多线) 调试信息以监视安全筛选器的请求. 这可能包括敏感信息，如请求参数或头文件，并且只在开发环境中使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="nsa-http"><a class="anchor" href="#nsa-http"></a>&lt;http&gt;</h4>
<div class="paragraph">
<p>如果你能使用 <code>&lt;http&gt;</code> 在您的应用程序中的元素 <code>FilterChainProxy</code> bean 叫做 "springSecurityFilterChain"创建和元素内的配置是用来在内部建立一个过滤器链
<code>FilterChainProxy</code>.  作为Spring Security 3.1, 额外的 <code>http</code> 元素可以用来添加额外的过滤链脚注:[ See the <a href="#ns-web-xml">introductory chapter</a> 为你建立映射 <code>web.xml</code> ].
一些核心过滤器总是在一个过滤器链中创建，其他一些核心过滤器将被添加到堆栈中，这取决于当前的属性和子元素. 标准过滤器的位置是固定的 (看
<a href="#filter-stack">the filter order table</a> 在命名空间介绍中，删除一个与以前版本的框架的常见错误源，当用户在该框架中明确地配置了过滤器链时
<code>FilterChainProxy</code> bean.如果你需要完全控制配置的话，你仍然可以这样做。</p>
</div>
<div class="paragraph">
<p>所需要参考所有过滤器 <code>AuthenticationManager</code>将自动注入由命名空间配置创建的内部实例(看到<a href="#ns-auth-manager">introductory chapter</a> 为更多的 <code>AuthenticationManager</code>).每个<code>&lt;http&gt;</code>命名空间块总是创建一个<code>SecurityContextPersistenceFilter</code>,一个 <code>ExceptionTranslationFilter</code>和一个<code>FilterSecurityInterceptor</code>. 这些都是固定的，不能被替代品替代</p>
</div>
<div class="sect4">
<h5 id="nsa-http-attributes"><a class="anchor" href="#nsa-http-attributes"></a>&lt;http&gt; 属性</h5>
<div class="paragraph">
<p><code>&lt;http&gt;</code>的属性元素控制核心过滤器上的一些属性。</p>
</div>
<div id="nsa-http-access-decision-manager-ref" class="ulist">
<ul>
<li>
<p><strong>access-decision-manager-ref</strong>
可选属性指定的标识 <code>AccessDecisionManager</code> 实现应该用于授权的HTTP请求. 通过一个默认的 <code>AffirmativeBased</code> 实现用于与一个 <code>RoleVoter</code>和 <code>AuthenticatedVoter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-authentication-manager-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-manager-ref</strong>
参考的 <code>AuthenticationManager</code> 用来 <code>FilterChain</code> 通过这个HTTP元素创建。</p>
</li>
</ul>
</div>
<div id="nsa-http-auto-config" class="ulist">
<ul>
<li>
<p><strong>auto-config</strong>
自动注册登录表单，基本认证，注销服务。如果设置为“真”，所有这些功能都被添加 (虽然您仍然可以通过提供相应的元素来自定义每个元素的配置)。如果未指定，默认为“假”。不建议使用此属性。使用明确的配置元素，而不是避免混乱。</p>
</li>
</ul>
</div>
<div id="nsa-http-create-session" class="ulist">
<ul>
<li>
<p><strong>create-session</strong>
控制一个Spring Security类的创建，包括以下:</p>
<div class="ulist">
<ul>
<li>
<p><code>always</code> - Spring Security 如果不存在，将主动创建一个会话。</p>
</li>
<li>
<p><code>ifRequired</code> -Spring Security只会创建一个会话，如果是必需的 (默认值)。</p>
</li>
<li>
<p><code>never</code> - Spring Security 永远不会创建一个会话, 如果是应用程序它将会使用一个会话。</p>
</li>
<li>
<p><code>stateless</code> - Spring Security 不会创建一个会话，忽略获得一个会话的会话Spring。 <code>Authentication</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="nsa-http-disable-url-rewriting" class="ulist">
<ul>
<li>
<p><strong>disable-url-rewriting</strong>
防止会话标识被添加到应用程序中的网址。
 客户端必须使用该属性设置为 <code>true</code>. 默认值是 <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-entry-point-ref" class="ulist">
<ul>
<li>
<p><strong>entry-point-ref</strong>
通常情况下 <code>AuthenticationEntryPoint</code> 使用的将取决于已配置的身份验证机制。 此属性允许这种行为是通过定义一个定制的重写 <code>AuthenticationEntryPoint</code> bean 这将启动认证过程。</p>
</li>
</ul>
</div>
<div id="nsa-http-jaas-api-provision" class="ulist">
<ul>
<li>
<p><strong>jaas-api-provision</strong>
如果可用，运行请求作为 <code>Subject</code> 获得的 <code>JaasAuthenticationToken</code>这是通过添加一个 <code>JaasApiIntegrationFilter</code> bean 到堆栈。默认值为 <code>false</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-name" class="ulist">
<ul>
<li>
<p><strong>name</strong>
一个bean标识符，用于指在上下文中的其他地方的bean.</p>
</li>
</ul>
</div>
<div id="nsa-http-once-per-request" class="ulist">
<ul>
<li>
<p><strong>once-per-request</strong>
对应于 <code>observeOncePerRequest</code> 财产 <code>FilterSecurityInterceptor</code>. 默认值为 <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong>
定义一个模式 <a href="#nsa-http">http</a> 元素控制将被过滤的请求通过它定义的过滤器列表。解释是依赖于配置的 <a href="#nsa-http-request-matcher">request-matcher</a>. 如果没有定义模式，所有的请求都将被匹配，所以最具体的模式应该首先声明。</p>
</li>
</ul>
</div>
<div id="nsa-http-realm" class="ulist">
<ul>
<li>
<p><strong>realm</strong>
设置用于基本身份验证的域名称 (如果启用). 对应于 <code>realmName</code> 财产 <code>BasicAuthenticationEntryPoint</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-request-matcher" class="ulist">
<ul>
<li>
<p><strong>request-matcher</strong>
定义 <code>RequestMatcher</code> 战略中使用的 <code>FilterChainProxy</code> 由 <code>intercept-url</code>创建的bean匹配传入的请求。 选择目前 <code>mvc</code>, <code>ant</code>, <code>regex</code> 和 <code>ciRegex</code>, Spring MVC, ant, 正则表达式和不区分大小写的正则表达式。为每个创建一个单独的实例<a href="#nsa-intercept-url">intercept-url</a> 元素的使用 <a href="#nsa-intercept-url-pattern">pattern</a> 和 <a href="#nsa-intercept-url-method">method</a> 属性，Ant路径匹配使用 <code>AntPathRequestMatcher</code> 和正则表达式匹配使用 <code>RegexRequestMatcher</code>. 看到这些类Javadoc详情究竟如何进行匹配。Ant路径是默认策略。</p>
</li>
</ul>
</div>
<div id="nsa-http-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
一个参考到bean的实现 <code>RequestMatcher</code> 这将决定是否 <code>FilterChain</code>应使用， 这是一个更强大的替代。 <a href="#nsa-http-pattern">pattern</a>.</p>
</li>
</ul>
</div>
<div id="nsa-http-security" class="ulist">
<ul>
<li>
<p><strong>security</strong>
一个请求模式可以被映射到一个空的过滤链，通过设置这个属性 <code>none</code>. 没有安全将被应用，没有Spring Security的功能将是可用的。</p>
</li>
</ul>
</div>
<div id="nsa-http-security-context-repository-ref" class="ulist">
<ul>
<li>
<p><strong>security-context-repository-ref</strong>
允许注入一个自定义 <code>SecurityContextRepository</code> 进入 <code>SecurityContextPersistenceFilter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-servlet-api-provision" class="ulist">
<ul>
<li>
<p><strong>servlet-api-provision</strong>
提供的版本 <code>HttpServletRequest</code> 安全方法，如 <code>isUserInRole()</code>和 <code>getPrincipal()</code>这是通过添加一个 <code>SecurityContextHolderAwareRequestFilter</code> bean 到堆栈。默认值为 <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-use-expressions" class="ulist">
<ul>
<li>
<p><strong>use-expressions</strong>
使能在 <code>access</code> 属性，如章节所述 <a href="#el-access-web">expression-based access-control</a> 默认值为真。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-http-children"><a class="anchor" href="#nsa-http-children"></a>子元素 &lt;http&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-access-denied-handler">access-denied-handler</a></p>
</li>
<li>
<p><a href="#nsa-anonymous">anonymous</a></p>
</li>
<li>
<p><a href="#nsa-cors">cors</a></p>
</li>
<li>
<p><a href="#nsa-csrf">csrf</a></p>
</li>
<li>
<p><a href="#nsa-custom-filter">custom-filter</a></p>
</li>
<li>
<p><a href="#nsa-expression-handler">expression-handler</a></p>
</li>
<li>
<p><a href="#nsa-form-login">form-login</a></p>
</li>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
<li>
<p><a href="#nsa-http-basic">http-basic</a></p>
</li>
<li>
<p><a href="#nsa-intercept-url">intercept-url</a></p>
</li>
<li>
<p><a href="#nsa-jee">jee</a></p>
</li>
<li>
<p><a href="#nsa-logout">logout</a></p>
</li>
<li>
<p><a href="#nsa-openid-login">openid-login</a></p>
</li>
<li>
<p><a href="#nsa-port-mappings">port-mappings</a></p>
</li>
<li>
<p><a href="#nsa-remember-me">remember-me</a></p>
</li>
<li>
<p><a href="#nsa-request-cache">request-cache</a></p>
</li>
<li>
<p><a href="#nsa-session-management">session-management</a></p>
</li>
<li>
<p><a href="#nsa-x509">x509</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-access-denied-handler"><a class="anchor" href="#nsa-access-denied-handler"></a>&lt;access-denied-handler&gt;</h4>
<div class="paragraph">
<p>此元素允许您设置 <code>errorPage</code> 默认属性 <code>AccessDeniedHandler</code> 通过使用 <code>ExceptionTranslationFilter</code>,使用 <a href="#nsa-access-denied-handler-error-page">error-page</a> 属性，或使用该属性提供您自己的实现。<a href="#nsa-access-denied-handler-ref">ref</a>属性。这会在更详细的章节中讨论。 <a href="#access-denied-handler">ExceptionTranslationFilter</a>.</p>
</div>
<div class="sect4">
<h5 id="nsa-access-denied-handler-parents"><a class="anchor" href="#nsa-access-denied-handler-parents"></a>父元素 &lt;access-denied-handler&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-access-denied-handler-attributes"><a class="anchor" href="#nsa-access-denied-handler-attributes"></a>&lt;access-denied-handler&gt; Attributes</h5>
<div id="nsa-access-denied-handler-error-page" class="ulist">
<ul>
<li>
<p><strong>error-page</strong>
访问被拒绝页，一个经过验证的用户将被重定向到他们请求的一个没有权限访问的页面。</p>
</li>
</ul>
</div>
<div id="nsa-access-denied-handler-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义一个引用 Spring bean 类型 <code>AccessDeniedHandler</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-cors"><a class="anchor" href="#nsa-cors"></a>&lt;cors&gt;</h4>
<div class="paragraph">
<p>此元素允许配置 <code>CorsFilter</code>.
如果不 <code>CorsFilter</code>或者 <code>CorsConfigurationSource</code> 是指定在Spring MVC类路径中, a <code>HandlerMappingIntrospector</code> 被用作 <code>CorsConfigurationSource</code>.</p>
</div>
<div class="sect4">
<h5 id="nsa-cors-attributes"><a class="anchor" href="#nsa-cors-attributes"></a>&lt;cors&gt; 属性</h5>
<div class="paragraph">
<p><code>&lt;cors&gt;</code>的属性元素控制头元素。</p>
</div>
<div id="nsa-cors-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
指定一个指定的名称的属性的可选属性 <code>CorsFilter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-cors-configuration-source-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
指定一个指定的名称的属性的可选属性 <code>CorsConfigurationSource</code> 被注入到一个 <code>CorsFilter</code> 由XML命名空间创建。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-cors-parents"><a class="anchor" href="#nsa-cors-parents"></a>父元素 &lt;cors&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-headers"><a class="anchor" href="#nsa-headers"></a>&lt;headers&gt;</h4>
<div class="paragraph">
<p>此元素允许配置额外的 (security) 将发送的标题与响应。 它可以方便地配置几个头文件，也允许通过设置自定义头 <a href="#nsa-header">header</a>，可以发现在 <a href="#headers">Security Headers</a> 参考截面。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Cache-Control</code>, <code>Pragma</code>,和 <code>Expires</code> - 可以设置使用 <a href="#nsa-cache-control">cache-control</a>元。这将确保浏览器不缓存您的安全页。</p>
</li>
<li>
<p><code>Strict-Transport-Security</code> - 可以设置使用 <a href="#nsa-hsts">hsts</a>元。这保证了浏览器自动请求未来要求HTTPS。</p>
</li>
<li>
<p><code>X-Frame-Options</code> - 可以设置使用 <a href="#nsa-frame-options">frame-options</a> 元 <a href="http://en.wikipedia.org/wiki/Clickjacking#X-Frame-Options">X-Frame-Options </a> 可以用来阻止clickjacking攻击。</p>
</li>
<li>
<p><code>X-XSS-Protection</code> -可以用来设置 <a href="#nsa-xss-protection">xss-protection</a>元 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">X-XSS-Protection </a>可以通过浏览器来做基本的控制。</p>
</li>
<li>
<p><code>X-Content-Type-Options</code> -可以用来设置 <a href="#nsa-content-type-options">content-type-options</a>元。  <a href="http://blogs.msdn.com/b/ie/archive/2008/09/02/ie8-security-part-vi-beta-2-update.aspx">X-Content-Type-Options</a> 标头防止Internet Explorer MIME嗅探响应从宣布的内容类型。当下载扩展时这也适用于谷歌浏览器。</p>
</li>
<li>
<p><code>Public-Key-Pinning</code> or <code>Public-Key-Pinning-Report-Only</code> -可以用来设置 <a href="#nsa-hpkp">hpkp</a> 元。 这允许攻击者使用HTTPS的网站通过发布虚假证书的MIS或抵抗冒充。</p>
</li>
<li>
<p><code>Content-Security-Policy</code>或 <code>Content-Security-Policy-Report-Only</code> -可以用来设置 <a href="#nsa-content-security-policy">content-security-policy</a> element. <a href="https://www.w3.org/TR/CSP2/">Content Security Policy (CSP)</a> 是一种机制，Web应用程序可以利用减轻内容注入漏洞，如跨站脚本（XSS）。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="nsa-headers-attributes"><a class="anchor" href="#nsa-headers-attributes"></a>&lt;headers&gt; 属性</h5>
<div class="paragraph">
<p><code>&lt;headers&gt;</code>的属性元控制头元素。</p>
</div>
<div id="nsa-headers-defaults-disabled" class="ulist">
<ul>
<li>
<p><strong>defaults-disabled</strong>
可选属性，指定要禁用默认的Spring Security的HTTP响应头。默认是错误的 （包含默认标题）。</p>
</li>
</ul>
</div>
<div id="nsa-headers-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
可选属性，指定要禁用Spring Security的HTTP响应头。默认是错误的（标题是启用的）。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-headers-parents"><a class="anchor" href="#nsa-headers-parents"></a>父元素 &lt;headers&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-headers-children"><a class="anchor" href="#nsa-headers-children"></a>子元素 &lt;headers&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-cache-control">cache-control</a></p>
</li>
<li>
<p><a href="#nsa-content-security-policy">content-security-policy</a></p>
</li>
<li>
<p><a href="#nsa-content-type-options">content-type-options</a></p>
</li>
<li>
<p><a href="#nsa-frame-options">frame-options</a></p>
</li>
<li>
<p><a href="#nsa-header">header</a></p>
</li>
<li>
<p><a href="#nsa-hpkp">hpkp</a></p>
</li>
<li>
<p><a href="#nsa-hsts">hsts</a></p>
</li>
<li>
<p><a href="#nsa-xss-protection">xss-protection</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-cache-control"><a class="anchor" href="#nsa-cache-control"></a>&lt;cache-control&gt;</h4>
<div class="paragraph">
<p>添加 <code>Cache-Control</code>, <code>Pragma</code>, 和 <code>Expires</code> 标头，以确保浏览器不缓存您的安全页。</p>
</div>
<div class="sect4">
<h5 id="nsa-cache-control-attributes"><a class="anchor" href="#nsa-cache-control-attributes"></a>&lt;cache-control&gt; 属性</h5>
<div id="nsa-cache-control-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
指定是否禁用缓存控件。默认的错误。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-cache-control-parents"><a class="anchor" href="#nsa-cache-control-parents"></a>父元素 &lt;cache-control&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-hsts"><a class="anchor" href="#nsa-hsts"></a>&lt;hsts&gt;</h4>
<div class="paragraph">
<p>当可以添加时 <a href="http://tools.ietf.org/html/rfc6797">Strict-Transport-Security</a> 对任何安全请求的响应的标头。这允许服务器指示浏览器自动使用HTTPS为未来的要求。</p>
</div>
<div class="sect4">
<h5 id="nsa-hsts-attributes"><a class="anchor" href="#nsa-hsts-attributes"></a>&lt;hsts&gt; 属性</h5>
<div id="nsa-hsts-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
指定是否禁用严格的传输安全性。默认的错误。</p>
</li>
</ul>
</div>
<div id="nsa-hsts-include-subdomains" class="ulist">
<ul>
<li>
<p><strong>include-sub-domains</strong>
指定区域应包括。默认为true。</p>
</li>
</ul>
</div>
<div id="nsa-hsts-max-age-seconds" class="ulist">
<ul>
<li>
<p><strong>max-age-seconds</strong>
指定时间的主人应该是已知的最大量HSTS主机。默认一年。</p>
</li>
</ul>
</div>
<div id="nsa-hsts-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
requestmatcher实例如果被用来确定标题应设置，HttpServletRequest.isSecure()的默认值为真。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-hsts-parents"><a class="anchor" href="#nsa-hsts-parents"></a>父元素 &lt;hsts&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-hpkp"><a class="anchor" href="#nsa-hpkp"></a>&lt;hpkp&gt;</h4>
<div class="paragraph">
<p>当能够添加 <a href="https://tools.ietf.org/html/rfc7469">Public Key Pinning Extension for HTTP</a> 对任何安全请求的响应的标头。这允许攻击者使用HTTPS的网站通过发布虚假证书的MIS或抵抗冒充。</p>
</div>
<div class="sect4">
<h5 id="nsa-hpkp-attributes"><a class="anchor" href="#nsa-hpkp-attributes"></a>&lt;hpkp&gt; 属性</h5>
<div id="nsa-hpkp-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
指定HTTP（HPKP）公有键应禁用。默认为true。</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-include-subdomains" class="ulist">
<ul>
<li>
<p><strong>include-sub-domains</strong>
指定区域应包括。默认的错误。</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-max-age-seconds" class="ulist">
<ul>
<li>
<p><strong>max-age-seconds</strong>
设置公有键引脚头的最大年龄指令的值。默认60天。</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-report-only" class="ulist">
<ul>
<li>
<p><strong>report-only</strong>
指定如果浏览器只应报告引脚验证失败。默认为true。</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-report-uri" class="ulist">
<ul>
<li>
<p><strong>report-uri</strong>
指定的URI，浏览器应该报告PIN验证失败。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-hpkp-parents"><a class="anchor" href="#nsa-hpkp-parents"></a>父元素 &lt;hpkp&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-pins"><a class="anchor" href="#nsa-pins"></a>&lt;pins&gt;</h4>
<div class="paragraph">
<p>引脚列表。</p>
</div>
<div class="sect4">
<h5 id="nsa-pins-children"><a class="anchor" href="#nsa-pins-children"></a>子元素 &lt;pins&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pin">pin</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-pin"><a class="anchor" href="#nsa-pin"></a>&lt;pin&gt;</h4>
<div class="paragraph">
<p>指定使用base64编码SPKI指纹值和加密哈希算法的属性。</p>
</div>
<div class="sect4">
<h5 id="nsa-pin-attributes"><a class="anchor" href="#nsa-pin-attributes"></a>&lt;pin&gt; 属性</h5>
<div id="nsa-pin-algorithm" class="ulist">
<ul>
<li>
<p><strong>algorithm</strong>
密码散列算法。默认是SHA256。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-pin-parents"><a class="anchor" href="#nsa-pin-parents"></a>父元素 &lt;pin&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pins">pins</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-content-security-policy"><a class="anchor" href="#nsa-content-security-policy"></a>&lt;content-security-policy&gt;</h4>
<div class="paragraph">
<p>当可以添加 <a href="https://www.w3.org/TR/CSP2/">Content Security Policy (CSP)</a> 响应标头 CSP 是一种机制，Web应用程序可以利用减轻内容注入漏洞，如跨站脚本（XSS）。</p>
</div>
<div class="sect4">
<h5 id="nsa-content-security-policy-attributes"><a class="anchor" href="#nsa-content-security-policy-attributes"></a>&lt;content-security-policy&gt; 属性</h5>
<div id="nsa-content-security-policy-policy-directives" class="ulist">
<ul>
<li>
<p><strong>policy-directives</strong>
对于内容安全策略头文件的安全策略指令（S）或如果报表只设置为真，则只使用头文件的内容安全策略报告。</p>
</li>
</ul>
</div>
<div id="nsa-content-security-policy-report-only" class="ulist">
<ul>
<li>
<p><strong>report-only</strong>
设置为真，使内容安全策略报告只报告策略违规行为的标题。默认为假。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-content-security-policy-parents"><a class="anchor" href="#nsa-content-security-policy-parents"></a>父元素 &lt;content-security-policy&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-frame-options"><a class="anchor" href="#nsa-frame-options"></a>&lt;frame-options&gt;</h4>
<div class="paragraph">
<p>当可以添加 <a href="http://tools.ietf.org/html/draft-ietf-websec-x-frame-options">X-Frame-Options header</a>的响应，这会使得浏览器做一些安全检查和预防 <a href="http://en.wikipedia.org/wiki/Clickjacking">clickjacking</a> 攻击。</p>
</div>
<div class="sect4">
<h5 id="nsa-frame-options-attributes"><a class="anchor" href="#nsa-frame-options-attributes"></a>&lt;frame-options&gt; 属性</h5>
<div id="nsa-frame-options-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
如果禁用, 且不包括X帧选项报头，将默认为错误。</p>
</li>
</ul>
</div>
<div id="nsa-frame-options-policy" class="ulist">
<ul>
<li>
<p><strong>policy</strong></p>
<div class="ulist">
<ul>
<li>
<p><code>DENY</code> 页面不能被显示在一个框架中，无论该网站试图怎样做。当指定了帧选项策略时，这还是默认值。</p>
</li>
<li>
<p><code>SAMEORIGIN</code> 该页面只能在同一个页面上的同一个页面的框架中显示。</p>
</li>
<li>
<p><code>ALLOW-FROM origin</code> 该页只能显示在指定的原点的框中。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>换言之，如果你指定了拒绝，不仅将试图加载在一个框架中的页面失败时从其他网站加载，试图这样做会失败，从同一个网站加载。另一方面，如果你指定的sameorigin，你仍然可以使用在一个框架网页只要站点包括在一个框架是作为一个相同的服务页面。</p>
</div>
</li>
<li>
<p><strong>strategy</strong>
选择 <code>AllowFromStrategy</code> 来使用，当使用allow-from策略时。</p>
<div class="ulist">
<ul>
<li>
<p><code>static</code> 使用一个单一的静态allow-from价值。该值可以通过 <a href="#nsa-frame-options-value">value</a>属性.</p>
</li>
<li>
<p><code>regexp</code> 如果他们被允许使用regelur表达验证传入的请求和。正则表达式可以通过 <a href="#nsa-frame-options-value">value</a> 属性。 用于检索用于验证的值的请求参数可以被使用。 <a href="#nsa-frame-options-from-parameter">from-parameter</a>.</p>
</li>
<li>
<p><code>whitelist</code>一个逗号分离含有允许域列表。逗号分隔的可以通过设置 <a href="#nsa-frame-options-value">value</a>属性。 请求参数用于检索的值来验证可以指定使用的 <a href="#nsa-frame-options-from-parameter">from-parameter</a>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="nsa-frame-options-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
不是使用一个预定义的策略也可以使用一个自定义的` allowfromstrategy `。这个bean的引用可以通过ref属性指定。</p>
</li>
</ul>
</div>
<div id="nsa-frame-options-value" class="ulist">
<ul>
<li>
<p><strong>value</strong>
要使用的值是用allow-from的。 <a href="#nsa-frame-options-strategy">strategy</a>.</p>
</li>
</ul>
</div>
<div id="nsa-frame-options-from-parameter" class="ulist">
<ul>
<li>
<p><strong>from-parameter</strong>
指定的请求参数的名称使用时，使用正则表达式或白名单的allow-from策略。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-frame-options-parents"><a class="anchor" href="#nsa-frame-options-parents"></a>父元素 &lt;frame-options&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-xss-protection"><a class="anchor" href="#nsa-xss-protection"></a>&lt;xss-protection&gt;</h4>
<div class="paragraph">
<p>添加 <a href="http://blogs.msdn.com/b/ie/archive/2008/07/02/ie8-security-part-iv-the-xss-filter.aspx">X-XSS-Protection header</a> 协助防止响应 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent">reflected / Type-1 Cross-Site Scripting (XSS)</a> 攻击。 这不是一个对XSS攻击的充分保护！</p>
</div>
<div class="sect4">
<h5 id="nsa-xss-protection-attributes"><a class="anchor" href="#nsa-xss-protection-attributes"></a>&lt;xss-protection&gt; 属性</h5>
<div id="nsa-xss-protection-disabled" class="ulist">
<ul>
<li>
<p><strong>xss-protection-disabled</strong>
不包括标题 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent">reflected / Type-1 Cross-Site Scripting (XSS)</a>的保护。</p>
</li>
</ul>
</div>
<div id="nsa-xss-protection-enabled" class="ulist">
<ul>
<li>
<p><strong>xss-protection-enabled</strong>
明确使用eisable <a href="http://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent">reflected / Type-1 Cross-Site Scripting (XSS)</a> 的保护。</p>
</li>
</ul>
</div>
<div id="nsa-xss-protection-block" class="ulist">
<ul>
<li>
<p><strong>xss-protection-block</strong>
当true和XSS启用保护是真的，增加了mode=block的标头。这表明该页面不应该被加载的浏览器。当false和XSS启用保护是真的，页面仍然会呈现一个反映时检测到攻击但反应将被修改以防止攻击。请注意，有时有办法绕过这种模式，它可以经常次使阻塞页面更可取。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-xss-protection-parents"><a class="anchor" href="#nsa-xss-protection-parents"></a>父元素 &lt;xss-protection&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-content-type-options"><a class="anchor" href="#nsa-content-type-options"></a>&lt;content-type-options&gt;</h4>
<div class="paragraph">
<p>添加 X-Content-Type-Options 标头随着NOSNIFF值响应。 <a href="http://blogs.msdn.com/b/ie/archive/2008/09/02/ie8-security-part-vi-beta-2-update.aspx">disables MIME-sniffing</a>对 IE8+谷歌浏览器扩展。</p>
</div>
<div class="sect4">
<h5 id="nsa-content-type-options-attributes"><a class="anchor" href="#nsa-content-type-options-attributes"></a>&lt;content-type-options&gt; 属性</h5>
<div id="nsa-content-type-options-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
如果选择的指定类型无法使用，默认FALSE。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-content-type-options-parents"><a class="anchor" href="#nsa-content-type-options-parents"></a>父元素 &lt;content-type-options&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-header"><a class="anchor" href="#nsa-header"></a>&lt;header&gt;</h4>
<div class="paragraph">
<p>向响应中添加额外的头文件，需要指定名称和值。</p>
</div>
<div class="sect4">
<h5 id="nsa-header-attributes"><a class="anchor" href="#nsa-header-attributes"></a>&lt;header-attributes&gt; 属性</h5>
<div id="nsa-header-name" class="ulist">
<ul>
<li>
<p><strong>header-name</strong>
标头<code>name</code> 的名字。</p>
</li>
</ul>
</div>
<div id="nsa-header-value" class="ulist">
<ul>
<li>
<p><strong>value</strong>
<code>value</code> 添加的标头。</p>
</li>
</ul>
</div>
<div id="nsa-header-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
引用自定义实现的 <code>HeaderWriter</code> 接口。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-header-parents"><a class="anchor" href="#nsa-header-parents"></a>父元素 &lt;header&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-anonymous"><a class="anchor" href="#nsa-anonymous"></a>&lt;anonymous&gt;</h4>
<div class="paragraph">
<p>添加一个 <code>AnonymousAuthenticationFilter</code> to the stack and an <code>AnonymousAuthenticationProvider</code>. 需要的如果你正在使用 <code>IS_AUTHENTICATED_ANONYMOUSLY</code> 属性.</p>
</div>
<div class="sect4">
<h5 id="nsa-anonymous-parents"><a class="anchor" href="#nsa-anonymous-parents"></a>父元素 &lt;anonymous&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-anonymous-attributes"><a class="anchor" href="#nsa-anonymous-attributes"></a>&lt;anonymous&gt; 属性</h5>
<div id="nsa-anonymous-enabled" class="ulist">
<ul>
<li>
<p><strong>enabled</strong>
使用默认的命名空间设置，匿名“身份验证”设施将自动启用。您可以使用此属性禁用它。</p>
</li>
</ul>
</div>
<div id="nsa-anonymous-granted-authority" class="ulist">
<ul>
<li>
<p><strong>granted-authority</strong>
应分配给匿名请求的授予权限。通常，这是用来分配匿名请求特定的角色，它可以随后被用于授权决策。如果未设置，默认为 <code>ROLE_ANONYMOUS</code>.</p>
</li>
</ul>
</div>
<div id="nsa-anonymous-key" class="ulist">
<ul>
<li>
<p><strong>key</strong>
提供者和过滤器之间的密钥共享。这一般不需要设置。如果未设置，则默认为一个安全的随机生成的值。这意味着设置这个值可以提高启动时间，当使用匿名功能，因为安全的随机值可以需要一段时间才能产生。</p>
</li>
</ul>
</div>
<div id="nsa-anonymous-username" class="ulist">
<ul>
<li>
<p><strong>username</strong>
应分配给匿名请求的用户名。这允许被确定的主要，这可能是重要的日志记录和审计。如果未设置，默认为<code>anonymousUser</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-csrf"><a class="anchor" href="#nsa-csrf"></a>&lt;csrf&gt;将添加元素</h4>
<div class="literalblock">
<div class="content">
<pre>http://en.wikipedia.org/wiki/Cross-site_request_forgery[Cross Site Request Forger (CSRF)] protection to the application. It also updates the default RequestCache to only replay "GET" requests upon successful authentication. Additional information can be found in the &lt;&lt;csrf,Cross Site Request Forgery (CSRF)&gt;&gt; section of the reference.</pre>
</div>
</div>
<div class="sect4">
<h5 id="nsa-csrf-parents"><a class="anchor" href="#nsa-csrf-parents"></a>父元素 &lt;csrf&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-csrf-attributes"><a class="anchor" href="#nsa-csrf-attributes"></a>&lt;csrf&gt;属性</h5>
<div id="nsa-csrf-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
可选属性，指定要禁用的Spring Security的CSRF保护。默认值为假（CSRF保护功能）。这是强烈建议关闭CSRF保护功能。</p>
</li>
</ul>
</div>
<div id="nsa-csrf-token-repository-ref" class="ulist">
<ul>
<li>
<p><strong>token-repository-ref</strong>
使用的csrftokenrepository。默认值是 <code>HttpSessionCsrfTokenRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-csrf-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
requestmatcher实例被用来确定是否应使用CSRF。除了默认的是“GET”任何HTTP方法，“Trace”、“Head”、“Opitions”。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-custom-filter"><a class="anchor" href="#nsa-custom-filter"></a>&lt;custom-filter&gt;</h4>
<div class="paragraph">
<p>此元素用于将一个过滤器添加到筛选器链中。它不会创建任何额外的bean类，但被用来选择一个类型的bean <code>javax.servlet.Filter</code>已在应用程序上下文中定义，完整的细节可以在Spring Security维护的筛选器链中的特定位置处添加。 <a href="#ns-custom-filters">namespace chapter</a>.</p>
</div>
<div class="sect4">
<h5 id="nsa-custom-filter-parents"><a class="anchor" href="#nsa-custom-filter-parents"></a>父元素 &lt;custom-filter&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-custom-filter-attributes"><a class="anchor" href="#nsa-custom-filter-attributes"></a>&lt;custom-filter&gt;属性</h5>
<div id="nsa-custom-filter-after" class="ulist">
<ul>
<li>
<p><strong>after</strong>
过滤器自定义过滤后，应放置在链中。此功能只需要高级用户，希望混合自己的过滤器到安全过滤器链，并有一些知识的标准Spring Security过滤器。将筛选器名称映射到特定的Spring Security实现筛选器。</p>
</li>
</ul>
</div>
<div id="nsa-custom-filter-before" class="ulist">
<ul>
<li>
<p><strong>before</strong>
过滤器应立即在此之前，将自定义筛选器放置在链中。</p>
</li>
</ul>
</div>
<div id="nsa-custom-filter-position" class="ulist">
<ul>
<li>
<p><strong>position</strong>
如果你正在更换一个标准的过滤器。自定义筛选器应放置在链中的显式位置。</p>
</li>
</ul>
</div>
<div id="nsa-custom-filter-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义了一个实现的Spring bean的参考 <code>Filter</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-expression-handler"><a class="anchor" href="#nsa-expression-handler"></a>&lt;expression-handler&gt;</h4>
<div class="paragraph">
<p>定义 <code>SecurityExpressionHandler</code>如果启用基于表达式的访问控制，则将使用实例，如果默认实现（没有ACL支持）将用于不提供。</p>
</div>
<div class="sect4">
<h5 id="nsa-expression-handler-parents"><a class="anchor" href="#nsa-expression-handler-parents"></a>父元素 &lt;expression-handler&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
<li>
<p><a href="#nsa-websocket-message-broker">websocket-message-broker</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-expression-handler-attributes"><a class="anchor" href="#nsa-expression-handler-attributes"></a>&lt;expression-handler&gt; 属性</h5>
<div id="nsa-expression-handler-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义了一个实现的Spring Security的参考 <code>SecurityExpressionHandler</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-form-login"><a class="anchor" href="#nsa-form-login"></a>&lt;form-login&gt;</h4>
<div class="paragraph">
<p>用来添加一个<code>UsernamePasswordAuthenticationFilter</code> 到过滤器堆栈和一个 <code>LoginUrlAuthenticationEntryPoint</code> 到应用程序的环境， If no attributes are supplied, a login page will be generated automatically at the URL如果没有提供属性，将在网址中自动生成登录页 "/login"  脚注:[
此功能是真的只是提供了方便，并不只是用于生产 (在那里，一个视图技术将被选择，并可以用来提供一个自定义的登录页面，这个类 <code>DefaultLoginPageGeneratingFilter</code> 是 负责显示登录页面，将正常形式的登录和/或OpenID如果需要提供登录形式。
] 该行为可以使用自定义 <a href="#nsa-form-login-attributes"><code>&lt;form-login&gt;</code> Attributes</a>.</p>
</div>
<div class="sect4">
<h5 id="nsa-form-login-parents"><a class="anchor" href="#nsa-form-login-parents"></a>父元素 &lt;form-login&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-form-login-attributes"><a class="anchor" href="#nsa-form-login-attributes"></a>&lt;form-login&gt; 属性</h5>
<div id="nsa-form-login-always-use-default-target" class="ulist">
<ul>
<li>
<p><strong>always-use-default-target</strong>
如果设置 <code>true</code>, t用户将始终从给定的值开始 <a href="#nsa-form-login-default-target-url">default-target-url</a>, 何到达登录页面。映射到 <code>alwaysUseDefaultTargetUrl</code> 财产 <code>UsernamePasswordAuthenticationFilter</code>. 默认值是 <code>false</code>.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
参考一 <code>AuthenticationDetailsSource</code>将被认证过滤器使用。</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-failure-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-handler-ref</strong>
可以作为一种替代 <a href="#nsa-form-login-authentication-failure-url">authentication-failure-url</a>, 给您一个身份验证失败后的导航流的完全控制权。该值应该是一个 <code>AuthenticationFailureHandler</code> bean在应用程序上下文中。</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-failure-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-url</strong>
映射到 <code>authenticationFailureUrl</code>属性 <code>UsernamePasswordAuthenticationFilter</code>. 定义浏览器将被重定向到登录失败的网址。默认值为 <code>/login?error</code>,自动登录页面生成器自动处理，用一个错误信息重新绘制登录页面。</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-success-handler-ref</strong>
这可以作为一种替代<a href="#nsa-form-login-default-target-url">default-target-url</a> 和 <a href="#nsa-form-login-always-use-default-target">always-use-default-target</a>, 给您一个成功的认证后的导航流的完全控制。该值应该是一个 <code>AuthenticationSuccessHandler</code> bean在应用程序上下文中。默认情况下，实现 <code>SavedRequestAwareAuthenticationSuccessHandler</code>使用和注入 <a href="#nsa-form-login-default-target-url">default-target-url</a>.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-default-target-url" class="ulist">
<ul>
<li>
<p><strong>default-target-url</strong>
映射到 <code>defaultTargetUrl</code> 特性 <code>UsernamePasswordAuthenticationFilter</code>. 如果没有设置，默认值是“/”（应用程序的根）。登录后，用户将被带到这个网址，只要他们没有被要求登录，且他们试图访问一个有抵押的资源，他们将被带到最初的请求的网址。</p>
</li>
</ul>
</div>
<div id="nsa-form-login-login-page" class="ulist">
<ul>
<li>
<p><strong>login-page</strong>
应该用来显示登录页面的网址。映射到` loginformurl <code>特性 `LoginUrlAuthenticationEntryPoint</code>. 默认值为 "/login".</p>
</li>
</ul>
</div>
<div id="nsa-form-login-login-processing-url" class="ulist">
<ul>
<li>
<p><strong>login-processing-url</strong>
映射到 <code>filterProcessesUrl</code> 特性 <code>UsernamePasswordAuthenticationFilter</code>。默认值为 "/login"。</p>
</li>
</ul>
</div>
<div id="nsa-form-login-password-parameter" class="ulist">
<ul>
<li>
<p><strong>password-parameter</strong>
包含密码的请求参数的名称。默认为“password”。</p>
</li>
</ul>
</div>
<div id="nsa-form-login-username-parameter" class="ulist">
<ul>
<li>
<p><strong>username-parameter</strong>
包含用户名的请求参数的名称。默认为“username”。</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-success-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-success-forward-url</strong>
映射到 <code>ForwardAuthenticationSuccessHandler</code>  <code>authenticationSuccessHandler</code>特性 <code>UsernamePasswordAuthenticationFilter</code>。</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-failure-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-forward-url</strong>
映射到 <code>ForwardAuthenticationFailureHandler</code>  <code>authenticationFailureHandler</code> 特性 <code>UsernamePasswordAuthenticationFilter</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-http-basic"><a class="anchor" href="#nsa-http-basic"></a>&lt;http-basic&gt;</h4>
<div class="paragraph">
<p>添加一个 <code>BasicAuthenticationFilter</code> 和 <code>BasicAuthenticationEntryPoint</code> 对配置。后者将只用于作为配置入口点，如果未启用基于窗体的登录。</p>
</div>
<div class="sect4">
<h5 id="nsa-http-basic-parents"><a class="anchor" href="#nsa-http-basic-parents"></a>父元素 &lt;http-basic&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-http-basic-attributes"><a class="anchor" href="#nsa-http-basic-attributes"></a>&lt;http-basic&gt; 属性</h5>
<div id="nsa-http-basic-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
参考 <code>AuthenticationDetailsSource</code>将使用认证过滤器。</p>
</li>
</ul>
</div>
<div id="nsa-http-basic-entry-point-ref" class="ulist">
<ul>
<li>
<p><strong>entry-point-ref</strong>
设置 <code>AuthenticationEntryPoint</code> 用来 <code>BasicAuthenticationFilter</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-http-firewall"><a class="anchor" href="#nsa-http-firewall"></a>&lt;http-firewall&gt; 元</h4>
<div class="paragraph">
<p>实现的顶层元素 <code>HttpFirewall</code> 进入 <code>FilterChainProxy</code> 由命名空间创建，默认实现应该适用于大多数应用程序。</p>
</div>
<div class="sect4">
<h5 id="nsa-http-firewall-attributes"><a class="anchor" href="#nsa-http-firewall-attributes"></a>&lt;http-firewall&gt; 属性</h5>
<div id="nsa-http-firewall-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义了一个实现的Spring Bean的参考 <code>HttpFirewall</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-intercept-url"><a class="anchor" href="#nsa-intercept-url"></a>&lt;intercept-url&gt;</h4>
<div class="paragraph">
<p>此元素用于定义应用程序和配置如何处理它们的“网址”模式的集合 ，它被用来构建 <code>FilterInvocationSecurityMetadataSource</code> 通过使用 <code>FilterSecurityInterceptor</code>. 它还负责配置 <code>ChannelProcessingFilter</code> 如果特定的URL需要通过HTTPS访问，例如。 当匹配指定的模式对传入的请求时，匹配是在声明的元素的顺序中完成的。所以最具体的匹配模式应该是第一个，最普遍的应该是最后一个。</p>
</div>
<div class="sect4">
<h5 id="nsa-intercept-url-parents"><a class="anchor" href="#nsa-intercept-url-parents"></a>父元素 &lt;intercept-url&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-filter-security-metadata-source">filter-security-metadata-source</a></p>
</li>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-intercept-url-attributes"><a class="anchor" href="#nsa-intercept-url-attributes"></a>&lt;intercept-url&gt; 属性</h5>
<div id="nsa-intercept-url-access" class="ulist">
<ul>
<li>
<p><strong>access</strong>
列出将要存储在该目录中的访问属性 <code>FilterInvocationSecurityMetadataSource</code> 用于定义的网址模式/方法组合。这应该是一个逗号分隔的安全配置属性（如角色名称）的列表。</p>
</li>
</ul>
</div>
<div id="nsa-intercept-url-filters" class="ulist">
<ul>
<li>
<p><strong>filters</strong>
只能采取“none”的值，这将导致任何匹配的请求，完全绕过Spring Security过滤器链。没有其他的` &lt;HTTP&gt; ` 配置将有影响的请求，将没有安全上下文可供其持续时间。在请求期间访问安全方法将失败。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
此属性无效 <a href="#nsa-filter-security-metadata-source">filter-security-metadata-source</a>
</td>
</tr>
</table>
</div>
<div id="nsa-intercept-url-method" class="ulist">
<ul>
<li>
<p><strong>method</strong>
HTTP方法将使用与模式匹配传入的请求合并。如果省略，任何方法将匹配。如果一个相同的模式被指定，而没有一个方法，该方法特定的匹配将优先。</p>
</li>
</ul>
</div>
<div id="nsa-intercept-url-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong>
定义了网址路径的模式。内容将取决于 <code>request-matcher</code> 从包含HTTP元素属性，所以将默认的Ant路径语法。</p>
</li>
</ul>
</div>
<div id="nsa-intercept-url-requires-channel" class="ulist">
<ul>
<li>
<p><strong>requires-channel</strong>
“http”或“https”取决于一个特定的URL模式应该访问的HTTP或HTTPS区别。 lternatively值“any”可以用来当没有偏好。如果这个属性是存在于any <code>&lt;intercept-url&gt;</code> 元, 然后一个 <code>ChannelProcessingFilter</code> 将添加到筛选器堆栈中，并将其添加到应用程序上下文中的附加依赖项添加到。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果一个 <code>&lt;port-mappings&gt;</code> 配置添加，他将被用于 <code>SecureChannelProcessor</code> 和 <code>InsecureChannelProcessor</code> beans 用来重定向到 HTTP/HTTPS端口.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
此属性无效 <a href="#nsa-filter-security-metadata-source">filter-security-metadata-source</a>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-jee"><a class="anchor" href="#nsa-jee"></a>&lt;jee&gt;</h4>
<div class="paragraph">
<p>添加到过滤器链j2eepreauthenticatedprocessingfilter提供集成容器认证。</p>
</div>
<div class="sect4">
<h5 id="nsa-jee-parents"><a class="anchor" href="#nsa-jee-parents"></a>父元素 &lt;jee&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-jee-attributes"><a class="anchor" href="#nsa-jee-attributes"></a>&lt;jee&gt; 属性</h5>
<div id="nsa-jee-mappable-roles" class="ulist">
<ul>
<li>
<p><strong>mappable-roles</strong>
逗号隔开要查询传入的HttpServletRequest消息的角色列表。</p>
</li>
</ul>
</div>
<div id="nsa-jee-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
对用户的服务（或userdetailsservice bean）ID</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-logout"><a class="anchor" href="#nsa-logout"></a>&lt;logout&gt;</h4>
<div class="paragraph">
<p>添加一个<code>LogoutFilter</code> 到过滤器堆栈。这是配置一个 <code>SecurityContextLogoutHandler</code>。</p>
</div>
<div class="sect4">
<h5 id="nsa-logout-parents"><a class="anchor" href="#nsa-logout-parents"></a>父元素 &lt;logout&gt;</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-logout-attributes"><a class="anchor" href="#nsa-logout-attributes"></a>&lt;logout&gt; 属性</h5>
<div id="nsa-logout-delete-cookies" class="ulist">
<ul>
<li>
<p><strong>delete-cookies</strong>
当用户登录时，应删除的一个逗号分隔的名称列表。</p>
</li>
</ul>
</div>
<div id="nsa-logout-invalidate-session" class="ulist">
<ul>
<li>
<p><strong>invalidate-session</strong>
映射一个<code>invalidateHttpSession</code>的 <code>SecurityContextLogoutHandler</code>. 默认值为“真”，所以，会话将被作废注销。</p>
</li>
</ul>
</div>
<div id="nsa-logout-logout-success-url" class="ulist">
<ul>
<li>
<p><strong>logout-success-url</strong>
登录后用户将采取目标网址。默认值为 &lt;form-login-login-page&gt;/?logout (i.e. /login?logout)</p>
<div class="paragraph">
<p>设置此属性将注入<code>SessionManagementFilter</code> 和一个<code>SimpleRedirectInvalidSessionStrategy</code>配置属性值。当一个无效的会话ID提交，该战略将调用重定向到配置的URL。</p>
</div>
</li>
</ul>
</div>
<div id="nsa-logout-logout-url" class="ulist">
<ul>
<li>
<p><strong>logout-url</strong>
URL会造成注销 (i.e. 将由过滤器处理). 默认值为 "/logout".</p>
</li>
</ul>
</div>
<div id="nsa-logout-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>success-handler-ref</strong>
可用于提供一个实例 <code>LogoutSuccessHandler</code> 将被调用来控制日志记录后的导航。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-openid-login"><a class="anchor" href="#nsa-openid-login"></a>&lt;openid-login&gt;</h4>
<div class="paragraph">
<p>类似于<code>&lt;form-login&gt;</code>,并且具有相同的属性.  <code>login-processing-url</code>的默认值是"/login/openid".
<code>OpenIDAuthenticationFilter</code>和     <code>OpenIDAuthenticationProvider</code> 将被注册. 后者需要去引用一个 <code>UserDetailsService</code>. 同样, 这样可以被 <code>id</code>指定, 使用 <code>user-service-ref</code> 属性, 或者将在应用程序上下文中被自动定位。</p>
</div>
<div class="sect4">
<h5 id="nsa-openid-login-parents"><a class="anchor" href="#nsa-openid-login-parents"></a>&lt;openid-login&gt;的父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-openid-login-attributes"><a class="anchor" href="#nsa-openid-login-attributes"></a>&lt;openid-login&gt;的属性</h5>
<div id="nsa-openid-login-always-use-default-target" class="ulist">
<ul>
<li>
<p><strong>Always-use-the-default-target</strong>
用户应该总是被重定向到登录后的默认目标网址.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
对将要使用身份验证过滤引用一个身份验证详细信息源</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-failure-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-handler-ref</strong>
引用一个AuthenticationFailureHandler bean,应用于处理身份验证失败的请求.不应该使用与身份验证失败的链接组合,实施执行处理导航到后续的目标.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-failure-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-url</strong>
登录失败页面的网址.如果没有指定登录失败的网址, Spring Security 将自动创建一个失败的登录网址，当请求登录失败的网址时会开出登录错误和一个相应的过滤器.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-success-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-success-forward-url</strong>
在<code>UsernamePasswordAuthenticationFilter</code>属性中将 <code>ForwardAuthenticationSuccessHandler</code> 映射到 <code>authenticationSuccessHandler</code> .</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-failure-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-forward-url</strong>
在<code>UsernamePasswordAuthenticationFilter</code>属性中将 <code>ForwardAuthenticationSuccessHandler</code> 映射到
<code>authenticationSuccessHandler</code> .</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-success-handler-ref</strong>
引用一个AuthenticationSuccessHandler bean应用于处理一个成功的身份验证请求.不应与组合使用. <a href="#nsa-openid-login-default-target-url">default-target-url</a> (or <a href="#nsa-openid-login-always-use-default-target">always-use-default-target</a>) 实现执行是处理导航到后续的目标.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-default-target-url" class="ulist">
<ul>
<li>
<p><strong>default-target-url</strong>
如果用户的前一个动作无法恢复，将被重定向到成功认证后的URL.通常如果用户访问登录页面没有首先要求安全操作,将会触发身份验证.如果未指定，默认为应用程序的根.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-login-page" class="ulist">
<ul>
<li>
<p><strong>login-page</strong>
登录页面URL. 如果没有指定登录的URL, Spring Security将自动创建一个登录网址和一个相应的过滤器，以呈现被请求的登录网址.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-login-processing-url" class="ulist">
<ul>
<li>
<p><strong>login-processing-url</strong>
登录窗口被发布的网址.如果未被指定，它默认为登录.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-password-parameter" class="ulist">
<ul>
<li>
<p><strong>password-parameter</strong>
包含密码的请求参数的名称。默认为"password".</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
参考用户服务（或用户详细信息服务）Id</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-username-parameter" class="ulist">
<ul>
<li>
<p><strong>username-parameter</strong>
包含用户名的请求参数的名称。默认为 "username".</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-openid-login-children"><a class="anchor" href="#nsa-openid-login-children"></a>&lt;openid-login&gt;的子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-attribute-exchange">attribute-exchange</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-attribute-exchange"><a class="anchor" href="#nsa-attribute-exchange"></a>&lt;attribute-exchange&gt;</h4>
<div class="paragraph">
<p><code>attribute-exchange</code>元素定义属性列表应该从身份提供程序中请求. 在<a href="#ns-openid">OpenID Support</a> 命名空间配置章节的部分可以找出一个例子. 不只一个可以使用, 在这种情况下每个必须有 <code>identifier-match</code> 属性, 对所提供的OpenID标识符匹配包含一个正则表达式. 这允许从不同的供应商(Google, Yahoo etc)获取不同的属性列表 .</p>
</div>
<div class="sect4">
<h5 id="nsa-attribute-exchange-parents"><a class="anchor" href="#nsa-attribute-exchange-parents"></a>&lt;attribute-exchange&gt;的父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-openid-login">openid-login</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-attribute-exchange-attributes"><a class="anchor" href="#nsa-attribute-exchange-attributes"></a>&lt;attribute-exchange&gt;属性</h5>
<div id="nsa-attribute-exchange-identifier-match" class="ulist">
<ul>
<li>
<p><strong>identifier-match</strong>
当决定在身份验证过程中使用哪些属性交换配置，将要与所请求的标识进行比较的正则表达式.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-attribute-exchange-children"><a class="anchor" href="#nsa-attribute-exchange-children"></a>&lt;attribute-exchange&gt;的子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-openid-attribute">openid-attribute</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-openid-attribute"><a class="anchor" href="#nsa-openid-attribute"></a>&lt;openid-attribute&gt;</h4>
<div class="paragraph">
<p>用于制造一个OpenID Ax属性 <a href="http://openid.net/specs/openid-attribute-exchange-1_0.html#fetch_request"> Fetch Request</a></p>
</div>
<div class="sect4">
<h5 id="nsa-openid-attribute-parents"><a class="anchor" href="#nsa-openid-attribute-parents"></a>&lt;openid-attribute&gt;的父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-attribute-exchange">attribute-exchange</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-openid-attribute-attributes"><a class="anchor" href="#nsa-openid-attribute-attributes"></a>&lt;openid-attribute&gt; 属性</h5>
<div id="nsa-openid-attribute-count" class="ulist">
<ul>
<li>
<p><strong>count</strong>
指定要返回的属性的数量。例如，返回3个电子邮件. 默认值是 1.</p>
</li>
</ul>
</div>
<div id="nsa-openid-attribute-name" class="ulist">
<ul>
<li>
<p><strong>name</strong>
指定要返回的属性的名称。例如，电子邮件.</p>
</li>
</ul>
</div>
<div id="nsa-openid-attribute-required" class="ulist">
<ul>
<li>
<p><strong>required</strong>
指定此属性是否被要求对操作，但如果操作不返回属性，则不出错。默认为false.</p>
</li>
</ul>
</div>
<div id="nsa-openid-attribute-type" class="ulist">
<ul>
<li>
<p><strong>type</strong>
指定属性类型。例如, <a href="http://axschema.org/contact/email" class="bare">http://axschema.org/contact/email</a>. 查看你的操作的有效属性类型的文档.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-port-mappings"><a class="anchor" href="#nsa-port-mappings"></a>&lt;port-mappings&gt;</h4>
<div class="paragraph">
<p>默认情况下，实例<code>portmapperimpl</code>将被添加到配置中用于安全和不安全的URL重定向到.此元素可以选择地用于重写该类定义的默认映射. 每个 <code>&lt;port-mapping&gt;</code> 元素定义了一对 HTTP:HTTPS 端口. 默认的映射是80:443和8080:8443.重写这些的例子可以在 <a href="#ns-requires-channel">namespace introduction</a>找到.</p>
</div>
<div class="sect4">
<h5 id="nsa-port-mappings-parents"><a class="anchor" href="#nsa-port-mappings-parents"></a>&lt;port-mappings&gt;的父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-port-mappings-children"><a class="anchor" href="#nsa-port-mappings-children"></a>&lt;port-mappings&gt;的子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-port-mapping">port-mapping</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-port-mapping"><a class="anchor" href="#nsa-port-mapping"></a>&lt;port-mappings&gt;</h4>
<div class="paragraph">
<p>当强制重定向提供了一个地图的HTTP端口HTTPS端口方式.</p>
</div>
<div class="sect4">
<h5 id="nsa-port-mapping-parents"><a class="anchor" href="#nsa-port-mapping-parents"></a>&lt;port-mappings&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-port-mappings">port-mappings</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-port-mapping-attributes"><a class="anchor" href="#nsa-port-mapping-attributes"></a>&lt;port-mappings&gt; 属性</h5>
<div id="nsa-port-mapping-http" class="ulist">
<ul>
<li>
<p><strong>http</strong>
HTTP端口使用.</p>
</li>
</ul>
</div>
<div id="nsa-port-mapping-https" class="ulist">
<ul>
<li>
<p><strong>https</strong>
HTTPS端口使用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-remember-me"><a class="anchor" href="#nsa-remember-me"></a>&lt;remember-me&gt;</h4>
<div class="paragraph">
<p>添加 <code>RememberMeAuthenticationFilter</code>到堆栈.根据属性设置，将依次配置一个 <code>TokenBasedRememberMeServices</code>,一个<code>PersistentTokenBasedRememberMeServices</code> 或用户指定实现 <code>RememberMeServices</code> .</p>
</div>
<div class="sect4">
<h5 id="nsa-remember-me-parents"><a class="anchor" href="#nsa-remember-me-parents"></a>&lt;remember-me&gt;的父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-remember-me-attributes"><a class="anchor" href="#nsa-remember-me-attributes"></a>&lt;remember-me&gt; 属性</h5>
<div id="nsa-remember-me-authentication-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-success-handler-ref</strong>
如果需要自定义导航,在<code>RememberMeAuthenticationFilter</code>上设置<code>authenticationSuccessHandler</code>.在应用程序上下文中该值应该是个` authenticationsuccesshandler ` bean的名称.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-data-source-ref" class="ulist">
<ul>
<li>
<p><strong>data-source-ref</strong>
引用一个 <code>DataSource</code> bean. 如果这样设置，<code>persistenttokenbasedremembermeservices `将使用和配置一个</code> jdbctokenrepositoryimpl `实例.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-remember-me-parameter" class="ulist">
<ul>
<li>
<p><strong>remember-me-parameter</strong>
切换 remember-me认证请求的参数名.默认为"remember-me".  映射到"parameter"的<code>AbstractRememberMeServices</code>属性.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-remember-me-cookie" class="ulist">
<ul>
<li>
<p><strong>remember-me-cookie</strong>
cookie的名称为存储remember-me身份验证的令牌. 默认为 "remember-me".  <code>AbstractRememberMeServices</code>属性映射到"cookieName".</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-key" class="ulist">
<ul>
<li>
<p><strong>key</strong>
<code>AbstractRememberMeServices</code>属性映射到"key" . ，以确保remember-me cookies 仅在一个应用程序脚注中有效:[这不影响使用 <code>PersistentTokenBasedRememberMeServices</code>, 令牌存储在服务器端.]. 如果这不是设置一个将产生的安全的随机值. 因为生成安全的随机值可能需要一段时间, 当我们使用remember    me功能时，设置一个明确的值可以改善启动时间.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-services-alias" class="ulist">
<ul>
<li>
<p><strong>services-alias</strong>
输出内部定义的 <code>RememberMeServices</code> 作为 bean 别名,允许它在应用程序上下文中被其它beans使用.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-services-ref" class="ulist">
<ul>
<li>
<p><strong>services-ref</strong>
将被使用的过滤器允许` remembermeservices <code>完全控制实施. 值应该是在应用程序上下文中实现此接口的bean的"id". 如果注销过滤器在使用也应该执行</code> logouthandler `.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-token-repository-ref" class="ulist">
<ul>
<li>
<p><strong>token-repository-ref</strong>
配置一个 <code>PersistentTokenBasedRememberMeServices</code> 但是允许使用一个自定义的 <code>PersistentTokenRepository</code> bean.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-token-validity-seconds" class="ulist">
<ul>
<li>
<p><strong>token-validity-seconds</strong>
<code>AbstractRememberMeServices</code>属性映射到 <code>tokenValiditySeconds</code>  . 指定remember-me cookie在几秒钟内应是有效的. 默认情况下，有效期为14天.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-use-secure-cookie" class="ulist">
<ul>
<li>
<p><strong>use-secure-cookie</strong>
建议remember-me cookies只有通过HTTPS才能提交和因此应该被标记为"secure". 默认情况下，如果登录请求的链接是安全的（应该是），将使用一个secure   cookie. 如果你把这个属性设置为 <code>false</code>, secure cookies 将不会被使用 . 设置它为 <code>true</code> 将始终在cookie上设置安全标志.这 <code>AbstractRememberMeServices</code>属性映射到<code>useSecureCookie</code>.</p>
</li>
<li>
<p><strong>user-service-ref</strong>
remember-me服务的实现需要访问 <code>UserDetailsService</code>, 因此，在应用程序上下文中必须要有一个定义.如果只有一个，它将被选择和自动使用通过命名空间配置.如果有多个实例,你可以指定一个bean <code>id</code> 明确的使用这个属性.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-request-cache"><a class="anchor" href="#nsa-request-cache"></a>&lt;request-cache&gt; 元素</h4>
<div class="paragraph">
<p>集将被 <code>ExceptionTranslationFilter</code>使用的 <code>RequestCache</code>实例去存储在调用<code>AuthenticationEntryPoint</code>前的请求信息.</p>
</div>
<div class="sect4">
<h5 id="nsa-request-cache-parents"><a class="anchor" href="#nsa-request-cache-parents"></a>&lt;request-cache&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-request-cache-attributes"><a class="anchor" href="#nsa-request-cache-attributes"></a>&lt;request-cache&gt; 属性</h5>
<div id="nsa-request-cache-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
对Spring bean定义一个引用，它是一个 <code>RequestCache</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-session-management"><a class="anchor" href="#nsa-session-management"></a>&lt;session-management&gt;</h4>
<div class="paragraph">
<p>通过添加一个 <code>SessionManagementFilter</code> 到过滤器栈，Session-management 相关功能时被实施的.</p>
</div>
<div class="sect4">
<h5 id="nsa-session-management-parents"><a class="anchor" href="#nsa-session-management-parents"></a>&lt;session-management&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-session-management-attributes"><a class="anchor" href="#nsa-session-management-attributes"></a>&lt;session-management&gt; 属性</h5>
<div id="nsa-session-management-invalid-session-url" class="ulist">
<ul>
<li>
<p><strong>invalid-session-url</strong>
设置此属性将会注入 <code>SessionManagementFilter</code> 一个 <code>SimpleRedirectInvalidSessionStrategy</code> 配置属性值.当提交一个无效的ID, 该战略将会被调用到重定向配置的URL.</p>
</li>
</ul>
</div>
<div id="nsa-session-management-session-authentication-error-url" class="ulist">
<ul>
<li>
<p><strong>session-authentication-error-url</strong>
定义的错误页面应该显示在sessionauthenticationstrategy引发异常的URL. 如果没有设置，未经授权的（401）错误代码将返回到客户端. 请注意，如果错误发生在一个基于窗体的登录,此属性不适用.在身份验证失败的网址将优先.</p>
</li>
</ul>
</div>
<div id="nsa-session-management-session-authentication-strategy-ref" class="ulist">
<ul>
<li>
<p><strong>session-authentication-strategy-ref</strong>
允许加入被 SessionManagementFilter使用的SessionAuthenticationStrategy 实例.</p>
</li>
</ul>
</div>
<div id="nsa-session-management-session-fixation-protection" class="ulist">
<ul>
<li>
<p><strong>session-fixation-protection</strong>
说明会话固定保护的应用将在用户认证. 如果设置为"none", 将不会应用保护. "newSession" 将新建一个新的空会话, 只有Spring Security相关属性迁移. "migrateSession" 将创建一个新的会话，并将所有会话属性复制到新会话中. In Servlet 3.1 (Java EE 7) 新的容器, 指定“changesessionid”将保持现有的会话和使用容器提供的会话固定保护（HttpServletRequest # changesessionid()）.默认为“changesessionid在Servlet 3.1和新的容器, “migratesession”在大容器.如果“changesessionid”用于大容器,抛出一个异常.</p>
<div class="paragraph">
<p>如果启用会话固定保护, ` sessionmanagementfilter <code>注入一个适当的配置</code> defaultsessionauthenticationstrategy `.看到这类Javadoc详情.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-session-management-children"><a class="anchor" href="#nsa-session-management-children"></a>&lt;session-management&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-concurrency-control">concurrency-control</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-concurrency-control"><a class="anchor" href="#nsa-concurrency-control"></a>&lt;concurrency-control&gt;</h4>
<div class="paragraph">
<p>添加支持并发会话控制, 允许将限制放置在用户可以拥有的活动会话的数量上. 一个` concurrentsessionfilter <code>将被创建, 并且一个 `ConcurrentSessionControlAuthenticationStrategy</code> 将会可用于 <code>SessionManagementFilter</code>. 如果已声明 <code>form-login</code>元素,则该策略对象也将被注入到所创建的验证筛选器中.一个 <code>SessionRegistry</code>(一个除非用户希望使用一个自定义bean的<code>SessionRegistryImpl</code>实例)将被创建供使用的战略实例.</p>
</div>
<div class="sect4">
<h5 id="nsa-concurrency-control-parents"><a class="anchor" href="#nsa-concurrency-control-parents"></a>&lt;concurrency-control&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-session-management">session-management</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-concurrency-control-attributes"><a class="anchor" href="#nsa-concurrency-control-attributes"></a>&lt;concurrency-control&gt;属性</h5>
<div id="nsa-concurrency-control-error-if-maximum-exceeded" class="ulist">
<ul>
<li>
<p><strong>error-if-maximum-exceeded</strong>
如果设置为"true"，当用户试图超过允许的最大会话数时，<code>SessionAuthenticationException</code>将会被引发. 这默认的行为是使一个原始的会话失效.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-expired-url" class="ulist">
<ul>
<li>
<p><strong>expired-url</strong>
如果他们试图使用一个已被并发会话控制器"expired"的会话，URL用户将被重定向，因为用户已经超过了允许的会话数，并在其他地方再次登录. 除非 <code>exception-if-maximum-exceeded</code>被设置.如果没有提供任何值，一个有效消息将直接返回到响应.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-max-sessions" class="ulist">
<ul>
<li>
<p><strong>max-sessions</strong>
<code>ConcurrentSessionControlAuthenticationStrategy</code>属性映射到<code>maximumSessions</code>.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-session-registry-alias" class="ulist">
<ul>
<li>
<p><strong>session-registry-alias</strong>
他也可以是有用的，对内部会话注册表有一个参考，用于在你自己的beans或管理接口. 使用 <code>session-registry-alias</code>属性，可以使内部bean公开, 给它一个名称，你可以在你的配置中的其他地方使用.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-session-registry-ref" class="ulist">
<ul>
<li>
<p><strong>session-registry-ref</strong>
用户可以提供自己的` sessionregistry <code>实现使用`session-registry-ref</code> 属性. 其他并发会话控制beans将被连接起来使用它.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-x509"><a class="anchor" href="#nsa-x509"></a>&lt;x509&gt;</h4>
<div class="paragraph">
<p>增加了支持X.509认证. 一个 <code>X509AuthenticationFilter</code> 将被添加到堆栈和 <code>Http403ForbiddenEntryPoint</code> bean 被创建. 后者只会在没有其他认证机制的时候使用（它唯一的功能是返回一个HTTP 403错误代码）. ` preauthenticatedauthenticationprovider`也将创建一个将用户权限加载到一个` userdetailsservice `的地方中.</p>
</div>
<div class="sect4">
<h5 id="nsa-x509-parents"><a class="anchor" href="#nsa-x509-parents"></a>&lt;x509&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-x509-attributes"><a class="anchor" href="#nsa-x509-attributes"></a>&lt;x509&gt; 属性</h5>
<div id="nsa-x509-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
引用一个 <code>AuthenticationDetailsSource</code></p>
</li>
</ul>
</div>
<div id="nsa-x509-subject-principal-regex" class="ulist">
<ul>
<li>
<p><strong>subject-principal-regex</strong>
定义一个正则表达式，该表达式将用于从证书中提取用户名 (用于使用 <code>UserDetailsService</code>).</p>
</li>
</ul>
</div>
<div id="nsa-x509-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
允许使用特定的 `UserDetailsService`X.509的情况下配置多个实例.如果没有设置，将试图自动找到一个合适的实例，并使用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-filter-chain-map"><a class="anchor" href="#nsa-filter-chain-map"></a>&lt;filter-chain-map&gt;</h4>
<div class="paragraph">
<p>用于显式配置filterchainproxy与filterchainmap实例</p>
</div>
<div class="sect4">
<h5 id="nsa-filter-chain-map-attributes"><a class="anchor" href="#nsa-filter-chain-map-attributes"></a>&lt;filter-chain-map&gt; 属性</h5>
<div id="nsa-filter-chain-map-request-matcher" class="ulist">
<ul>
<li>
<p><strong>request-matcher</strong>
定义策略用于匹配传入请求的使用. 目前的选项是'ant'（蚂蚁路径模式）, 'regex'正则表达式和'ciRegex' 不区分大小写的正则表达式.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-filter-chain-map-children"><a class="anchor" href="#nsa-filter-chain-map-children"></a>&lt;filter-chain-map&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-filter-chain">filter-chain</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-filter-chain"><a class="anchor" href="#nsa-filter-chain"></a>&lt;filter-chain&gt;</h4>
<div class="paragraph">
<p>用于定义一个特定的URL模式和适用于该模式匹配的URL的过滤器列表.当多个filter-chain元素组合在一个列表中为了配置FilterChainProxy,最具体的模式必须放在列表的顶部，在底部最一般的模式.</p>
</div>
<div class="sect4">
<h5 id="nsa-filter-chain-parents"><a class="anchor" href="#nsa-filter-chain-parents"></a>&lt;filter-chain&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-filter-chain-map">filter-chain-map</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-filter-chain-attributes"><a class="anchor" href="#nsa-filter-chain-attributes"></a>&lt;filter-chain&gt; 属性</h5>
<div id="nsa-filter-chain-filters" class="ulist">
<ul>
<li>
<p><strong>filters</strong>
一个逗号分隔的列表引用Spring bean实现 <code>Filter</code>. 值"none"意味着没有 <code>Filter</code>应该用于` FilterChain `.</p>
</li>
</ul>
</div>
<div id="nsa-filter-chain-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong>
A-pattern创造结合RequestMatcher <a href="#nsa-filter-chain-map-request-matcher">request-matcher</a></p>
</li>
</ul>
</div>
<div id="nsa-filter-chain-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
引用一个` requestmatcher <code>将用于确定是否有一些`Filter</code>来自 <code>filters</code>应该被调用的属性.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-filter-security-metadata-source"><a class="anchor" href="#nsa-filter-security-metadata-source"></a>&lt;filter-security-metadata-source&gt;</h4>
<div class="paragraph">
<p>用于显式配置FilterSecurityMetadataSource FilterSecurityInterceptor bean使用. 如果你正在配置FilterChainProxy,只需要明确的这一个，而不是使用&lt;http&gt;元素.截取只包含方法和访问属性模式的intercept-url.任何其他的将导致配置错误.</p>
</div>
<div class="sect4">
<h5 id="nsa-filter-security-metadata-source-attributes"><a class="anchor" href="#nsa-filter-security-metadata-source-attributes"></a>&lt;filter-security-metadata-source&gt; 属性</h5>
<div id="nsa-filter-security-metadata-source-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
一个bean标识符, 用于指在上下文中的其他地方的bean.</p>
</li>
</ul>
</div>
<div id="nsa-filter-security-metadata-source-lowercase-comparisons" class="ulist">
<ul>
<li>
<p><strong>lowercase-comparisons</strong>
比较后迫使小写</p>
</li>
</ul>
</div>
<div id="nsa-filter-security-metadata-source-request-matcher" class="ulist">
<ul>
<li>
<p><strong>request-matcher</strong>
定义用于匹配传入请求的策略.目前的选择是 'ant'（蚂蚁路径模式）, 'regex' 正则表达式和'ciRegex' 不区分大小写的正则表达式.</p>
</li>
</ul>
</div>
<div id="nsa-filter-security-metadata-source-use-expressions" class="ulist">
<ul>
<li>
<p><strong>use-expressions</strong>
可以使用在&lt;intercept-url&gt;元素中表达式'access'的属性,而不是传统的配置属性的列表.默认为 'true'.如果启用，每个属性应该包含一个单一的布尔表达式. 如果表达式计算结果为'true'，则访问将被授予.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-filter-security-metadata-source-children"><a class="anchor" href="#nsa-filter-security-metadata-source-children"></a>&lt;filter-security-metadata-source&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-intercept-url">intercept-url</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="nsa-websocket-security"><a class="anchor" href="#nsa-websocket-security"></a>WebSocket 安全</h3>
<div class="paragraph">
<p>Spring Security 4.0+为授权消息提供支持.这是一个为WebSocket基础应用程序提供授权有用的例子.</p>
</div>
<div class="sect3">
<h4 id="nsa-websocket-message-broker"><a class="anchor" href="#nsa-websocket-message-broker"></a>&lt;websocket-message-broker&gt;</h4>
<div class="paragraph">
<p>websocket-message-broker元素有两种不同的模式.
如果<a href="#nsa-websocket-message-broker-id">websocket-message-broker@id</a> 没有指定，那么它会做以下事情:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保任何SimpAnnotationMethodMessageHandler AuthenticationPrincipalArgumentResolver注册作为一个自定义参数解析器. 这允许使用 <code>@AuthenticationPrincipal</code> 来解决当前的主要<code>Authentication</code></p>
</li>
<li>
<p>确保securitycontextchannelinterceptor自动注册为clientinboundchannel. 这与用户填充SecurityContextHolder消息中被发现.</p>
</li>
<li>
<p>确保channelsecurityinterceptor与clientinboundchannel注册. 这允许授权规则指定的消息.</p>
</li>
<li>
<p>确保CsrfChannelInterceptor与clientInboundChannel注册.这将确保只有从原来的域的请求被启用.
*确保CsrfTokenHandshakeInterceptor与WebSocketHttpRequestHandler, TransportHandlingSockJsService,或DefaultSockJsService注册.这保证了预期的csrftoken来自消息复制到WebSocket Session属性.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果额外的控制是必要的，可以指定ID和channelsecurityinterceptor将分配给指定的ID. 所有的布线与Spring的消息传递基础设施可以手动完成的.这是比较麻烦的，但提供了更大的配置控制.</p>
</div>
<div class="sect4">
<h5 id="nsa-websocket-message-broker-attributes"><a class="anchor" href="#nsa-websocket-message-broker-attributes"></a>&lt;websocket-message-broker&gt;属性</h5>
<div id="nsa-websocket-message-broker-id" class="ulist">
<ul>
<li>
<p><strong>id</strong> 一个bean的标识符，用于指在channelsecurityinterceptor bean的上下文中的任何地方. 如果指定，Spring Security需要在Spring Messaging内明确的配置. 如果没有指定，Spring Security会自动整合与通讯基础设施,如<a href="#nsa-websocket-message-broker">&lt;websocket-message-broker&gt;</a>描述的.</p>
</li>
</ul>
</div>
<div id="nsa-websocket-message-broker-same-origin-disabled" class="ulist">
<ul>
<li>
<p><strong>same-origin-disabled</strong> 禁用要求CSRF令牌出现在Stomp headers(默认错误). 如果有必要让其他起源SockJS连接，更改默认是有用的.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-websocket-message-broker-children"><a class="anchor" href="#nsa-websocket-message-broker-children"></a>&lt;websocket-message-broker&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-expression-handler">expression-handler</a></p>
</li>
<li>
<p><a href="#nsa-intercept-message">intercept-message</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-intercept-message"><a class="anchor" href="#nsa-intercept-message"></a>&lt;intercept-message&gt;</h4>
<div class="paragraph">
<p>定义消息的授权规则.</p>
</div>
<div class="sect4">
<h5 id="nsa-intercept-message-parents"><a class="anchor" href="#nsa-intercept-message-parents"></a>&lt;intercept-message&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-websocket-message-broker">websocket-message-broker</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-intercept-message-attributes"><a class="anchor" href="#nsa-intercept-message-attributes"></a>&lt;intercept-message&gt; 属性</h5>
<div id="nsa-intercept-message-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong> 一种目的基于匹配Message的蚁群模式.例如, "/<strong>" matches any Message with a destination; "/admin/</strong>" 匹配任何有一个以"/admin/**"开头为目的地的Message".</p>
</li>
</ul>
</div>
<div id="nsa-intercept-message-type" class="ulist">
<ul>
<li>
<p><strong>type</strong> 要匹配的消息的类型.
在simpmessagetype有效值的定义 (i.e. CONNECT, CONNECT_ACK, HEARTBEAT, MESSAGE, SUBSCRIBE, UNSUBSCRIBE, DISCONNECT, DISCONNECT_ACK, OTHER).</p>
</li>
</ul>
</div>
<div id="nsa-intercept-message-access" class="ulist">
<ul>
<li>
<p><strong>access</strong> 用于保护信息的表达式.例如,"DenyAll"将拒绝访问所有的匹配信息;"permitall"将授予访问所有的匹配信息;"hasrole（'admin'）"需要当前用户拥有的角色"role_admin"匹配的信息.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="nsa-authentication"><a class="anchor" href="#nsa-authentication"></a>认证服务</h3>
<div class="paragraph">
<p>在Spring Security 3.0之前, <code>AuthenticationManager</code> 在内部是自动注册的. 现在，你必须使用  <code>&lt;authentication-manager&gt;</code> 元素明确的注册一个. 这将创建Spring Security的 <code>ProviderManager</code>类的一个实例, 需要配置一个或多个` AuthenticationProvider <code>实例. 这些都可以使用命名空间提供的语法元素来创建, 也可以是标准的bean定义, 标记为除了使用 `authentication-provider</code>元素的列表.</p>
</div>
<div class="sect3">
<h4 id="nsa-authentication-manager"><a class="anchor" href="#nsa-authentication-manager"></a>&lt;authentication-manager&gt;</h4>
<div class="paragraph">
<p>每个Spring Security应用程序使用名称空间必须包括这个元素.它负责注册的` authenticationManager <code>为应用提供认证服务. 所有元素的创建</code> AuthenticationProvider `实例应该是这个子元素.</p>
</div>
<div class="sect4">
<h5 id="nsa-authentication-manager-attributes"><a class="anchor" href="#nsa-authentication-manager-attributes"></a>&lt;authentication-manager&gt; 属性</h5>
<div id="nsa-authentication-manager-alias" class="ulist">
<ul>
<li>
<p><strong>alias</strong>
此属性允许你为你自己的配置中使用的内部实例定义别名. 它的用途是描述在<a href="#ns-auth-manager">namespace introduction</a>.</p>
</li>
</ul>
</div>
<div id="nsa-authentication-manager-erase-credentials" class="ulist">
<ul>
<li>
<p><strong>erase-credentials</strong>
如果设置为真, AuthenticationManager将试图清除任何凭据数据在返回的验证对象中, 一旦用户已被身份验证.实际上它映射到<code>eraseCredentialsAfterAuthentication</code>属性的 <code>ProviderManager</code>. 这是在 <a href="#core-services-erasing-credentials">Core Services</a> 章节中讨论的.</p>
</li>
</ul>
</div>
<div id="nsa-authentication-manager-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
此属性允许你为内部实例定义一个用于在自己的配置中使用的标识. 它是相同的别名元素, 但提供了一个更加一致的经验使用id属性的元素.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-authentication-manager-children"><a class="anchor" href="#nsa-authentication-manager-children"></a>&lt;authentication-manager&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-provider">authentication-provider</a></p>
</li>
<li>
<p><a href="#nsa-ldap-authentication-provider">ldap-authentication-provider</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-authentication-provider"><a class="anchor" href="#nsa-authentication-provider"></a>&lt;authentication-provider&gt;</h4>
<div class="paragraph">
<p>除非用` REF <code>属性, 这个元素是缩写配置一个 <a href="#core-services-dao-provider">DaoAuthenticationProvider</a>. `DaoAuthenticationProvider</code> 加载用户信息从一个` userdetailsservice <code>和用户名/密码组合所提供的登录时比较. ` userdetailsservice `实例可以通过使用可用的命名空间元素定义 ( `jdbc-user-service</code> 或者通过使用 <code>user-service-ref</code> 属性指向一个bean定义在应用程序上下文). 在 <a href="#ns-auth-providers">namespace introduction</a>中你可以找到这些变化的例子.</p>
</div>
<div class="sect4">
<h5 id="nsa-authentication-provider-parents"><a class="anchor" href="#nsa-authentication-provider-parents"></a>&lt;authentication-provider&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-manager">authentication-manager</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-authentication-provider-attributes"><a class="anchor" href="#nsa-authentication-provider-attributes"></a>&lt;authentication-provider&gt; 属性</h5>
<div id="nsa-authentication-provider-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义引用一个Spring bean实现<code>AuthenticationProvider</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你写了自己的 <code>AuthenticationProvider</code>实现(或者想配置一个Spring Security的实现作为一个传统的bean,然后，你可以使用下面的语法将它添加到` providermanager ` 内部列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;security:authentication-manager&gt;
&lt;security:authentication-provider ref="myAuthenticationProvider" /&gt;
&lt;/security:authentication-manager&gt;
&lt;bean id="myAuthenticationProvider" class="com.something.MyAuthenticationProvider"/&gt;</code></pre>
</div>
</div>
<div id="nsa-authentication-provider-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
引用bean实现UserDetailsService可以创建使用标准的bean元素或自定义 ser-service 元素.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-authentication-provider-children"><a class="anchor" href="#nsa-authentication-provider-children"></a>&lt;authentication-provider&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-jdbc-user-service">jdbc-user-service</a></p>
</li>
<li>
<p><a href="#nsa-ldap-user-service">ldap-user-service</a></p>
</li>
<li>
<p><a href="#nsa-password-encoder">password-encoder</a></p>
</li>
<li>
<p><a href="#nsa-user-service">user-service</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-jdbc-user-service"><a class="anchor" href="#nsa-jdbc-user-service"></a>&lt;jdbc-user-service&gt;</h4>
<div class="paragraph">
<p>创建一个JDBC-based UserDetailsService.</p>
</div>
<div class="sect4">
<h5 id="nsa-jdbc-user-service-attributes"><a class="anchor" href="#nsa-jdbc-user-service-attributes"></a>&lt;jdbc-user-service&gt; 属性</h5>
<div id="nsa-jdbc-user-service-authorities-by-username-query" class="ulist">
<ul>
<li>
<p><strong>authorities-by-username-query</strong>
一个SQL语句查询用户授予政府给定的用户名.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认为</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select username, authority from authorities where username = ?</code></pre>
</div>
</div>
<div id="nsa-jdbc-user-service-cache-ref" class="ulist">
<ul>
<li>
<p><strong>cache-ref</strong>
定义引用UserDetailsService缓存.</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-data-source-ref" class="ulist">
<ul>
<li>
<p><strong>data-source-ref</strong>
bean ID 提供所需的表的数据源.</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-group-authorities-by-username-query" class="ulist">
<ul>
<li>
<p><strong>group-authorities-by-username-query</strong>
一条SQL语句来查询用户组部门给定的用户名.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认为</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select
g.id, g.group_name, ga.authority
from
groups g, group_members gm, group_authorities ga
where
gm.username = ? and g.id = ga.group_id and g.id = gm.group_id</code></pre>
</div>
</div>
<div id="nsa-jdbc-user-service-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
bean标识符, 用于bean在上下文的任何地方.</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-role-prefix" class="ulist">
<ul>
<li>
<p><strong>role-prefix</strong>
从永久存储(默认是 "ROLE_")中，一个非空字符串前缀字符串将被添加到角色加载.在默认为非空的情况下，使用没有前缀的值"none".</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-users-by-username-query" class="ulist">
<ul>
<li>
<p><strong>users-by-username-query</strong>
一个SQL语句查询用户名、密码，并启用了一个用户名状态. 默认为</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select username, password, enabled from users where username = ?</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-password-encoder"><a class="anchor" href="#nsa-password-encoder"></a>&lt;password-encoder&gt;</h4>
<div class="paragraph">
<p>如<a href="#ns-password-encoder">namespace introduction</a>所描述的，身份验证提供者可以被配置为使用一个密码编码器. 这将导致bean注入到相应的` passwordencoder <code>实例中, 可能可能伴随 `SaltSource</code> bean提供盐散列值.</p>
</div>
<div class="sect4">
<h5 id="nsa-password-encoder-parents"><a class="anchor" href="#nsa-password-encoder-parents"></a>&lt;password-encoder&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-provider">authentication-provider</a></p>
</li>
<li>
<p><a href="#nsa-password-compare">password-compare</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-password-encoder-attributes"><a class="anchor" href="#nsa-password-encoder-attributes"></a>&lt;password-encoder&gt;属性</h5>
<div id="nsa-password-encoder-base64" class="ulist">
<ul>
<li>
<p><strong>base64</strong>
一个字符串是否应该被Base64编码</p>
</li>
</ul>
</div>
<div id="nsa-password-encoder-hash" class="ulist">
<ul>
<li>
<p><strong>hash</strong>
定义用于用户密码的散列算法.我们强烈建议你不要使用MD4,因为它是一个非常弱的散列算法.</p>
</li>
</ul>
</div>
<div id="nsa-password-encoder-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义引用一个Spring bean 实现<code>PasswordEncoder</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-password-encoder-children"><a class="anchor" href="#nsa-password-encoder-children"></a>&lt;password-encoder&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-salt-source">salt-source</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-salt-source"><a class="anchor" href="#nsa-salt-source"></a>&lt;salt-source&gt;</h4>
<div class="paragraph">
<p>口令保护策略. 可以使用来自UserDetails对象的系统常数和属性.</p>
</div>
<div class="sect4">
<h5 id="nsa-salt-source-parents"><a class="anchor" href="#nsa-salt-source-parents"></a>&lt;salt-source&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-password-encoder">password-encoder</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-salt-source-attributes"><a class="anchor" href="#nsa-salt-source-attributes"></a>&lt;salt-source&gt;属性</h5>
<div id="nsa-salt-source-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义引用一个Spring bean Id.</p>
</li>
</ul>
</div>
<div id="nsa-salt-source-system-wide" class="ulist">
<ul>
<li>
<p><strong>system-wide</strong>
一个单一的值，将被用来作为一个密码编码器的salt.</p>
</li>
</ul>
</div>
<div id="nsa-salt-source-user-property" class="ulist">
<ul>
<li>
<p><strong>user-property</strong>
UserDetails对象的属性将被用作salt通过密码编码器. 通常情况下，像"username"可能会被使用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-user-service"><a class="anchor" href="#nsa-user-service"></a>&lt;user-service&gt;</h4>
<div class="paragraph">
<p>从属性文件或列表中的"user"子元素创建一个UserDetailsService内存. 内部转换为小写,允许用户名不区分大小写的查询,所以这个不应使用是否需要区分大小写.</p>
</div>
<div class="sect4">
<h5 id="nsa-user-service-attributes"><a class="anchor" href="#nsa-user-service-attributes"></a>&lt;user-service&gt; 属性</h5>
<div id="nsa-user-service-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
bean标识符,用于指bean在上下文的任何地方.</p>
</li>
</ul>
</div>
<div id="nsa-user-service-properties" class="ulist">
<ul>
<li>
<p><strong>properties</strong>
其中属性文件的位置，每一行的格式为</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>username=password,grantedAuthority[,grantedAuthority][,enabled|disabled]</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-user-service-children"><a class="anchor" href="#nsa-user-service-children"></a>&lt;user-service&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-user">user</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-user"><a class="anchor" href="#nsa-user"></a>&lt;user&gt;</h4>
<div class="paragraph">
<p>表示应用程序中的用户.</p>
</div>
<div class="sect4">
<h5 id="nsa-user-parents"><a class="anchor" href="#nsa-user-parents"></a>&lt;user&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-user-service">user-service</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-user-attributes"><a class="anchor" href="#nsa-user-attributes"></a>&lt;user&gt; 属性</h5>
<div id="nsa-user-authorities" class="ulist">
<ul>
<li>
<p><strong>authorities</strong>
一个或多个authorities授予的用户. 用逗号隔开authorities (但没有空间).例如, "ROLE_USER,ROLE_ADMINISTRATOR"</p>
</li>
</ul>
</div>
<div id="nsa-user-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
可以设置为"true"来标记一个帐户禁用，无法使用.</p>
</li>
</ul>
</div>
<div id="nsa-user-locked" class="ulist">
<ul>
<li>
<p><strong>locked</strong>
可以设置为"true"来标记一个帐户锁定，无法使用.</p>
</li>
</ul>
</div>
<div id="nsa-user-name" class="ulist">
<ul>
<li>
<p><strong>name</strong>
分配给用户的用户名.</p>
</li>
</ul>
</div>
<div id="nsa-user-password" class="ulist">
<ul>
<li>
<p><strong>password</strong>
分配给用户的密码. 如果相应的认证供应商支持哈希(记得设置"user-service"的 "hash"属性元素)，这可能是散列.此属性被省略的情况下,该数据将不会被用于身份验证.但仅用于访问authorities.如果省略，命名空间将生成一个随机值，防止其意外使用身份验证。不能为空.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="nsa-method-security"><a class="anchor" href="#nsa-method-security"></a>方法安全性</h3>
<div class="sect3">
<h4 id="nsa-global-method-security"><a class="anchor" href="#nsa-global-method-security"></a>&lt;global-method-security&gt;</h4>
<div class="paragraph">
<p>这个元素的主要手段是在Spring Security beans中添加支持安全方法.可以通过使用注释担保（在接口或类定义）或通过定义一组的切入点作为子元素的方法,使用AspectJ语法.</p>
</div>
<div class="sect4">
<h5 id="nsa-global-method-security-attributes"><a class="anchor" href="#nsa-global-method-security-attributes"></a>&lt;global-method-security&gt; 属性</h5>
<div id="nsa-global-method-security-access-decision-manager-ref" class="ulist">
<ul>
<li>
<p><strong>access-decision-manager-ref</strong>
使用与<code>AccessDecisionManager</code>相同的安全方法配置网络安全, 但这可以使用此属性覆盖.默认情况下AffirmativeBased实现用于RoleVoter和AuthenticatedVoter.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-authentication-manager-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-manager-ref</strong>
引用一个 <code>AuthenticationManager</code> ,应该用于方法安全性.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-jsr250-annotations" class="ulist">
<ul>
<li>
<p><strong>jsr250-annotations</strong>
指定是否使用JSR-250样式属性(例如"RolesAllowed"). 这将需要javax.annotation.安全类在类路径中.将此设置为真也增加一个 <code>Jsr250Voter</code>到<code>AccessDecisionManager</code>,所以你需要确保你这样做，如果你正在使用一个自定义的实现和想要使用这些注释.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-metadata-source-ref" class="ulist">
<ul>
<li>
<p><strong>metadata-source-ref</strong>
外部<code>methodsecuritymetadatasource</code>实例可以提供优先于其他来源（如默认的注释）.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-mode" class="ulist">
<ul>
<li>
<p><strong>mode</strong>
该属性可以设置为"AspectJ"指定AspectJ应该用来代替默认的Spring AOP. 方法安全性必须被来自<code>spring-security-aspects</code>组件<code>AnnotationSecurityAspect</code>编排.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>需要注意的是AspectJ遵循Java接口上的注释不是继承的.这意味着定义接口的Security annotaitons方法将是不安全的. 相反, 当在使用AspectJ时,你必须把Security annotation放在类上.</p>
</div>
<div id="nsa-global-method-security-order" class="ulist">
<ul>
<li>
<p><strong>order</strong>
允许建议"order"将被设置为方法安全拦截.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-pre-post-annotations" class="ulist">
<ul>
<li>
<p><strong>pre-post-annotations</strong>
指定是否使用Spring Security的前后调用注释 (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) 应该支持这个应用程序上下文。默认为"disabled".</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-proxy-target-class" class="ulist">
<ul>
<li>
<p><strong>proxy-target-class</strong>
如果这是真的,将使用基于类的代理,而不是基于接口的代理.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-run-as-manager-ref" class="ulist">
<ul>
<li>
<p><strong>run-as-manager-ref</strong>
引用一个可选的<code>RunAsManager</code>实现可通过配置的<code>MethodSecurityInterceptor</code></p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-secured-annotations" class="ulist">
<ul>
<li>
<p><strong>secured-annotations</strong>
指定是否使用Spring Security的 @Secured annotations 启用应用程序上下文. 默认为 "disabled".</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-global-method-security-children"><a class="anchor" href="#nsa-global-method-security-children"></a>&lt;global-method-security&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-after-invocation-provider">after-invocation-provider</a></p>
</li>
<li>
<p><a href="#nsa-expression-handler">expression-handler</a></p>
</li>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
<li>
<p><a href="#nsa-protect-pointcut">protect-pointcut</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-after-invocation-provider"><a class="anchor" href="#nsa-after-invocation-provider"></a>&lt;after-invocation-provider&gt;</h4>
<div class="paragraph">
<p>通过 <code>&lt;global-method-security&gt;</code>的命名空间，这个元素可以用来装饰一个 <code>AfterInvocationProvider</code>用于维护的安全拦截器.你可以定义零个或多个 <code>global-method-security</code> 内的元素,在应用程序上下文中,每一个都有 <code>ref</code>属性指向一个 <code>AfterInvocationProvider</code> bean实例.</p>
</div>
<div class="sect4">
<h5 id="nsa-after-invocation-provider-parents"><a class="anchor" href="#nsa-after-invocation-provider-parents"></a>&lt;after-invocation-provider&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-after-invocation-provider-attributes"><a class="anchor" href="#nsa-after-invocation-provider-attributes"></a>&lt;after-invocation-provider&gt; 属性</h5>
<div id="nsa-after-invocation-provider-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义引用一个Spring bean 实现 <code>AfterInvocationProvider</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-pre-post-annotation-handling"><a class="anchor" href="#nsa-pre-post-annotation-handling"></a>&lt;pre-post-annotation-handling&gt;</h4>
<div class="paragraph">
<p>允许默认表达式的机制来处理Spring Security的前后调用注释 (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) 去完全取代. 仅适用于这些被启用了的注释.</p>
</div>
<div class="sect4">
<h5 id="nsa-pre-post-annotation-handling-parents"><a class="anchor" href="#nsa-pre-post-annotation-handling-parents"></a>&lt;pre-post-annotation-handling&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-pre-post-annotation-handling-children"><a class="anchor" href="#nsa-pre-post-annotation-handling-children"></a>&lt;pre-post-annotation-handling&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-invocation-attribute-factory">invocation-attribute-factory</a></p>
</li>
<li>
<p><a href="#nsa-post-invocation-advice">post-invocation-advice</a></p>
</li>
<li>
<p><a href="#nsa-pre-invocation-advice">pre-invocation-advice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-invocation-attribute-factory"><a class="anchor" href="#nsa-invocation-attribute-factory"></a>&lt;invocation-attribute-factory&gt;</h4>
<div class="paragraph">
<p>定义了PrePostInvocationAttributeFactory实例用于生成前后调用元数据注释的方法.</p>
</div>
<div class="sect4">
<h5 id="nsa-invocation-attribute-factory-parents"><a class="anchor" href="#nsa-invocation-attribute-factory-parents"></a>&lt;invocation-attribute-factory&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-invocation-attribute-factory-attributes"><a class="anchor" href="#nsa-invocation-attribute-factory-attributes"></a>&lt;invocation-attribute-factory&gt; 属性</h5>
<div id="nsa-invocation-attribute-factory-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义引用一个 Spring bean Id.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-post-invocation-advice"><a class="anchor" href="#nsa-post-invocation-advice"></a>&lt;post-invocation-advice&gt;</h4>
<div class="paragraph">
<p>对于&lt;pre-post-annotation-handling&gt; 元素，定制 <code>PostInvocationAdviceProvider</code> 编号为 <code>PostInvocationAuthorizationAdvice</code>.</p>
</div>
<div class="sect4">
<h5 id="nsa-post-invocation-advice-parents"><a class="anchor" href="#nsa-post-invocation-advice-parents"></a>&lt;post-invocation-advice&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-post-invocation-advice-attributes"><a class="anchor" href="#nsa-post-invocation-advice-attributes"></a>&lt;post-invocation-advice&gt; 属性</h5>
<div id="nsa-post-invocation-advice-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义引用一个Spring bean Id.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-pre-invocation-advice"><a class="anchor" href="#nsa-pre-invocation-advice"></a>&lt;pre-invocation-advice&gt;</h4>
<div class="paragraph">
<p>对于&lt;pre-post-annotation-handling&gt;元素,定制 <code>PreInvocationAuthorizationAdviceVoter</code> 编号为 <code>PreInvocationAuthorizationAdviceVoter</code> .</p>
</div>
<div class="sect4">
<h5 id="nsa-pre-invocation-advice-parents"><a class="anchor" href="#nsa-pre-invocation-advice-parents"></a>&lt;pre-invocation-advice&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-pre-invocation-advice-attributes"><a class="anchor" href="#nsa-pre-invocation-advice-attributes"></a>&lt;pre-invocation-advice&gt;属性</h5>
<div id="nsa-pre-invocation-advice-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义引用一个Spring bean Id.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-protect-pointcut"><a class="anchor" href="#nsa-protect-pointcut"></a>方法安全性的使用</h4>
<div class="paragraph">
<p><code>&lt;protect-pointcut&gt;</code>
而不是定义一个单独的方法或类基础的安全属性使用 <code>@Secured</code> 注释, 你可以跨整个定义横切安全约束集的方法和接口服务层中使用 <code>&lt;protect-pointcut&gt;</code>元素.你可以在 <a href="#ns-protect-pointcut">namespace introduction</a>中找到一个例子.</p>
</div>
<div class="sect4">
<h5 id="nsa-protect-pointcut-parents"><a class="anchor" href="#nsa-protect-pointcut-parents"></a>&lt;protect-pointcut&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-protect-pointcut-attributes"><a class="anchor" href="#nsa-protect-pointcut-attributes"></a>&lt;protect-pointcut&gt; 属性</h5>
<div id="nsa-protect-pointcut-access" class="ulist">
<ul>
<li>
<p><strong>access</strong>
访问适用于所有的匹配方法的切入点的配置属性列表, 例如. "ROLE_A,ROLE_B"</p>
</li>
</ul>
</div>
<div id="nsa-protect-pointcut-expression" class="ulist">
<ul>
<li>
<p><strong>expression</strong>
一个AspectJ的表达式, 包括'execution'关键字. 例如, 'execution(int com.foo.TargetObject.countLength(String))' (没有引号).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-intercept-methods"><a class="anchor" href="#nsa-intercept-methods"></a>&lt;intercept-methods&gt;</h4>
<div class="paragraph">
<p>可以使用在bean内的定义去添加一个安全拦截器到bean可以使用在bean定义安全拦截器添加到bean并，设置访问bean的配置属性的方法.</p>
</div>
<div class="sect4">
<h5 id="nsa-intercept-methods-attributes"><a class="anchor" href="#nsa-intercept-methods-attributes"></a>&lt;intercept-methods&gt; 属性</h5>
<div id="nsa-intercept-methods-access-decision-manager-ref" class="ulist">
<ul>
<li>
<p><strong>access-decision-manager-ref</strong>
可选AccessDecisionManager bean ID创建的方法安全性拦截器使用.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-intercept-methods-children"><a class="anchor" href="#nsa-intercept-methods-children"></a>&lt;intercept-methods&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-protect">protect</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-method-security-metadata-source"><a class="anchor" href="#nsa-method-security-metadata-source"></a>&lt;method-security-metadata-source&gt;</h4>
<div class="paragraph">
<p>创建一个MethodSecurityMetadataSource 实例</p>
</div>
<div class="sect4">
<h5 id="nsa-method-security-metadata-source-attributes"><a class="anchor" href="#nsa-method-security-metadata-source-attributes"></a>&lt;method-security-metadata-source&gt;属性</h5>
<div id="nsa-method-security-metadata-source-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
bean标识符, 用于指向bean的上下文中.</p>
</li>
</ul>
</div>
<div id="nsa-method-security-metadata-source-use-expressions" class="ulist">
<ul>
<li>
<p><strong>use-expressions</strong>
可以使用 &lt;intercept-url&gt;元素 'access'属性表达式,而不是传统的配置属性列表. 默认为 'false'. 如果启用了, 每个属性应该包含一个boolean表达式. 如果表达式计算结果为'true', 访问将被授予.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-method-security-metadata-source-children"><a class="anchor" href="#nsa-method-security-metadata-source-children"></a>&lt;method-security-metadata-source&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-protect">protect</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-protect"><a class="anchor" href="#nsa-protect"></a>&lt;protect&gt;</h4>
<div class="paragraph">
<p>定义一个应用于它的受保护方法和访问控制配置属性. 我们强烈建议你不要将"protect"申明与提供的"global-method-security"的任何服务混合在一起.</p>
</div>
<div class="sect4">
<h5 id="nsa-protect-parents"><a class="anchor" href="#nsa-protect-parents"></a>&lt;protect&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-intercept-methods">intercept-methods</a></p>
</li>
<li>
<p><a href="#nsa-method-security-metadata-source">method-security-metadata-source</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-protect-attributes"><a class="anchor" href="#nsa-protect-attributes"></a>&lt;protect&gt; 属性</h5>
<div id="nsa-protect-access" class="ulist">
<ul>
<li>
<p><strong>access</strong>
一种适用于该方法的访问配置属性列表,例如. "ROLE_A,ROLE_B".</p>
</li>
</ul>
</div>
<div id="nsa-protect-method" class="ulist">
<ul>
<li>
<p><strong>method</strong>
方法名称</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="nsa-ldap"><a class="anchor" href="#nsa-ldap"></a>LDAP命名空间选项</h3>
<div class="paragraph">
<p>LDAP是覆盖一些细节在<a href="#ldap">its own chapter</a>. 我们将扩大在一些解释的名称空间映射到Spring bean的选项.LDAP 广泛的实现使用Spring  LDAP,因此,一些熟悉该项目的API可能是有用的.</p>
</div>
<div class="sect3">
<h4 id="nsa-ldap-server"><a class="anchor" href="#nsa-ldap-server"></a>定义LDAP服务器使用</h4>
<div class="paragraph">
<p><code>&lt;ldap-server&gt;</code> 元素
该元素设置了一个 Spring LDAP <code>ContextSource</code> 用于其他 LDAP beans, 定义LDAP服务器的位置和其他信息(如用户名和密码,如果它不允许匿名访问) 用于连接到它.它也可以被用来创建一个嵌入式服务器进行测试. 两个选项的语法的细节是在 <a href="#ldap-server">LDAP chapter</a>. 实际的 <code>ContextSource</code> 实施是 <code>DefaultSpringSecurityContextSource</code> 延伸 Spring LDAP的 <code>LdapContextSource</code> 类. <code>manager-dn</code> 和 <code>manager-password</code> 属性映射到后面的 <code>userDn</code> 和 <code>password</code>属性分别.</p>
</div>
<div class="paragraph">
<p>如果你的应用程序上下文中定义了一个服务器, 其他的 LDAP namespace-defined beans将自动使用. 否则, 你可以给这个元素一个 "id"属性和从其他命名空间bean引用它使用 <code>server-ref</code> 属性. 这实际上是 <code>ContextSource</code>的bean`id`实例, 如果你想在其它传统的Spring beans使用它.</p>
</div>
<div class="sect4">
<h5 id="nsa-ldap-server-attributes"><a class="anchor" href="#nsa-ldap-server-attributes"></a>&lt;ldap-server&gt; 属性</h5>
<div id="nsa-ldap-server-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
bean标识符, 用于指向bean的上下文中.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-ldif" class="ulist">
<ul>
<li>
<p><strong>ldif</strong>
显式指定LDIF文件资源加载到嵌入式LDAP服务器.ldif应该是一个Spring资源模式(i.e. classpath:init.ldiff). 默认为 classpath*:*.ldiff</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-manager-dn" class="ulist">
<ul>
<li>
<p><strong>manager-dn</strong>
用户名 (DN) 的 "manager" 用户标识 将用于验证(non-embedded) LDAP 服务. 如果省略, 将使用匿名访问.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-manager-password" class="ulist">
<ul>
<li>
<p><strong>manager-password</strong>
密码管理器DN. 如果 manager-dn被指定，这是必需的.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-port" class="ulist">
<ul>
<li>
<p><strong>port</strong>
指定一个IP端口号码. 用于配置嵌入式LDAP服务器, 例如. 默认值为 33389.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-root" class="ulist">
<ul>
<li>
<p><strong>root</strong>
对于嵌入式LDAP服务器可选根后缀. 默认为 "dc=springframework,dc=org"</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-url" class="ulist">
<ul>
<li>
<p><strong>url</strong>
指定LDAP服务器URL时不使用嵌入式LDAP服务器.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-ldap-authentication-provider"><a class="anchor" href="#nsa-ldap-authentication-provider"></a>&lt;ldap-authentication-provider&gt;</h4>
<div class="paragraph">
<p>这元素是速记 <code>LdapAuthenticationProvider</code> 实例的创建.默认情况下这将配置一个` bindauthenticator <code>实例和一个 `DefaultAuthoritiesPopulator</code>.和所有命名空间身份验证提供程序一样, 它必须包含作为 <code>authentication-provider</code> 元素的子元素.</p>
</div>
<div class="sect4">
<h5 id="nsa-ldap-authentication-provider-parents"><a class="anchor" href="#nsa-ldap-authentication-provider-parents"></a>&lt;ldap-authentication-provider&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-manager">authentication-manager</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-ldap-authentication-provider-attributes"><a class="anchor" href="#nsa-ldap-authentication-provider-attributes"></a>&lt;ldap-authentication-provider&gt; 属性</h5>
<div id="nsa-ldap-authentication-provider-group-role-attribute" class="ulist">
<ul>
<li>
<p><strong>group-role-attribute</strong>
包含角色名的LDAP属性名将用于Spring Security. 映射到<code>DefaultLdapAuthoritiesPopulator</code>的 <code>groupRoleAttribute</code> 属性. 默认到 "cn".</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-group-search-base" class="ulist">
<ul>
<li>
<p><strong>group-search-base</strong>
组成员搜索. 映射 <code>DefaultLdapAuthoritiesPopulator</code>的 <code>groupSearchBase</code> 构造函数的参数. 默认为 "" (从根搜索).</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-group-search-filter" class="ulist">
<ul>
<li>
<p><strong>group-search-filter</strong>
组搜索过滤器. 映射到 <code>DefaultLdapAuthoritiesPopulator</code>的 <code>groupSearchFilter</code> 属性. 默认为 (uniqueMember={0}). 替换参数是用户的DN.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-role-prefix" class="ulist">
<ul>
<li>
<p><strong>role-prefix</strong>
一个非空字符串前缀将被添加到从持久性加载的角色字符串中. 映射到 <code>DefaultLdapAuthoritiesPopulator</code>的 <code>rolePrefix</code> 属性. 默认为 "ROLE_".在默认为非空的情况下,使用没有前缀的值"none".</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-server-ref" class="ulist">
<ul>
<li>
<p><strong>server-ref</strong>
可选的服务器使用. 如果省略, 和一个默认注册的LDAP 服务 (使用没ID的 &lt;ldap-server&gt;), that server will be used.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-context-mapper-ref" class="ulist">
<ul>
<li>
<p><strong>user-context-mapper-ref</strong>
允许用户定制的加载对象明确指定userdetailscontextmapper bean将被称为来自用户目录项的上下文信息</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-details-class" class="ulist">
<ul>
<li>
<p><strong>user-details-class</strong>
允许用户输入的类被指定。如果设置，框架会尝试加载标准属性的定义的类的对象返回到userdetails</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-dn-pattern" class="ulist">
<ul>
<li>
<p><strong>user-dn-pattern</strong>
如果你的用户在目录中的一个固定的位置（即你可以直接从用户名DN不做目录搜索）, 您可以使用此属性直接映射到DN. 它直接映射到<code>userDnPatterns</code> 属性 <code>AbstractLdapAuthenticator</code>. 值是一个特定的模式用于构建用户的DN, 例如"uid={0},ou=people". The key "{0}" 必须存在，并将被替换的用户名.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-search-base" class="ulist">
<ul>
<li>
<p><strong>user-search-base</strong>
搜索用户搜索库. 默认为 "". 只使用一个 'user-search-filter'.</p>
<div class="paragraph">
<p>如果你需要执行搜索来定位目录中的用户,然后，您可以设置这些属性来控制搜索. <code>BindAuthenticator</code> 将配置一个 <code>FilterBasedLdapUserSearch</code>和属性值直接映射到bean的构造函数的前两个参数. 如果这些属性没有设置并没有"user-dn-pattern"提供作为替代, 然后默认搜索值 <code>user-search-filter="(uid={0})"</code> 和 <code>user-search-base=""</code> 将被使用.</p>
</div>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-search-filter" class="ulist">
<ul>
<li>
<p><strong>user-search-filter</strong>
LDAP筛选器用于搜索用户（可选）.例如"(uid={0})".被替换的参数是用户的登录名.</p>
<div class="paragraph">
<p>如果你需要执行搜索来定位目录中的用户,然后，你可以设置这些属性来控制搜索.<code>BindAuthenticator</code> 将配置一个 <code>FilterBasedLdapUserSearch</code> 并且属性值将直接映射到bean构造函数的前两个参数. 如果还没有设置这些属性和没有提供给 <code>user-dn-pattern</code> 作为替代, 然后默认搜索值 <code>user-search-filter="(uid={0})"</code> 和<code>user-search-base=""</code>将被使用.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-ldap-authentication-provider-children"><a class="anchor" href="#nsa-ldap-authentication-provider-children"></a>&lt;ldap-authentication-provider&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-password-compare">password-compare</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-password-compare"><a class="anchor" href="#nsa-password-compare"></a>&lt;password-compare&gt;</h4>
<div class="paragraph">
<p>作为子元素被用于 <code>&lt;ldap-provider&gt;</code> 与从` bindauthenticator <code>到</code> passwordcomparisonauthenticator `交换机的认证策略.</p>
</div>
<div class="sect4">
<h5 id="nsa-password-compare-parents"><a class="anchor" href="#nsa-password-compare-parents"></a>&lt;password-compare&gt;父元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-ldap-authentication-provider">ldap-authentication-provider</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-password-compare-attributes"><a class="anchor" href="#nsa-password-compare-attributes"></a>&lt;password-compare&gt; 属性</h5>
<div id="nsa-password-compare-hash" class="ulist">
<ul>
<li>
<p><strong>hash</strong>
定义用于用户密码的散列算法.我们强烈建议不要使用MD4,因为它是一个非常弱的散列算法.</p>
</li>
</ul>
</div>
<div id="nsa-password-compare-password-attribute" class="ulist">
<ul>
<li>
<p><strong>password-attribute</strong>
包含用户密码的目录中的属性. 默认为 "userPassword".</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nsa-password-compare-children"><a class="anchor" href="#nsa-password-compare-children"></a>&lt;password-compare&gt;子元素</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-password-encoder">password-encoder</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-ldap-user-service"><a class="anchor" href="#nsa-ldap-user-service"></a>&lt;ldap-user-service&gt;</h4>
<div class="paragraph">
<p>这个元素配置一个LDAP <code>UserDetailsService</code>. 使用的类 <code>LdapUserDetailsService</code> 是 <code>FilterBasedLdapUserSearch</code> 和 <code>DefaultLdapAuthoritiesPopulator</code>的组合. 它支持的属性如在<code>&lt;ldap-provider&gt;</code>中有相同的用法.</p>
</div>
<div class="sect4">
<h5 id="nsa-ldap-user-service-attributes"><a class="anchor" href="#nsa-ldap-user-service-attributes"></a>&lt;ldap-user-service&gt; 属性</h5>
<div id="nsa-ldap-user-service-cache-ref" class="ulist">
<ul>
<li>
<p><strong>cache-ref</strong>
定义引用一个缓存用于 UserDetailsService.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-group-role-attribute" class="ulist">
<ul>
<li>
<p><strong>group-role-attribute</strong>
包含角色名的LDAP属性名将用于Spring Security. 默认为 "cn".</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-group-search-base" class="ulist">
<ul>
<li>
<p><strong>group-search-base</strong>
组成员搜索.默认为"" (从根搜索).</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-group-search-filter" class="ulist">
<ul>
<li>
<p><strong>group-search-filter</strong>
组过滤搜索器. 默认为 (uniqueMember={0}). 替代参数是用户的DN.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
bean标识符, 用于指向bean的上下文中.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-role-prefix" class="ulist">
<ul>
<li>
<p><strong>role-prefix</strong>
一个非空字符串前缀将被添加到从持久性加载的角色字符串中(例如. "ROLE_"). 在默认为非空的情况下,使用没有前缀的值 "none" .</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-server-ref" class="ulist">
<ul>
<li>
<p><strong>server-ref</strong>
可选服务器使用. 如果省略, 和一个被默认注册的LDAP服务器(使用 没有ID的&lt;ldap-server&gt;), 该服务器将被使用.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-context-mapper-ref" class="ulist">
<ul>
<li>
<p><strong>user-context-mapper-ref</strong>
通过指定一个可加载的用户对象的显式定制一个UserDetailsContextMapper bean，从用户的目录条目调用上下文信息.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-details-class" class="ulist">
<ul>
<li>
<p><strong>user-details-class</strong>
允许用户输入指定的对象类.如果设置，该框架将会尝试加载标准属性的定义的类的对象返回到UserDetails</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-search-base" class="ulist">
<ul>
<li>
<p><strong>user-search-base</strong>
搜索用户搜索库. 默认为 "". 只使用一个 'user-search-filter'.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-search-filter" class="ulist">
<ul>
<li>
<p><strong>user-search-filter</strong>
LDAP筛选器用于搜索用户(可选).例如"(uid={0})".被替换的参数是用户的登录名.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix-dependencies"><a class="anchor" href="#appendix-dependencies"></a>Spring Security依赖关系</h2>
<div class="sectionbody">
<div class="paragraph">
<p>T他的附录提供了一个 Spring Security参考模块和附加的依赖关系,他们需要在运行中的应用程序的功能. 我们不包括只用来构建或测试Spring Security 本身的依赖关系. 也不包括了依赖关系所必需的外部依赖.</p>
</div>
<div class="paragraph">
<p>在项目网站上列出了所需的Spring 版本, 因此，Spring依赖之下 特定的版本被省略.注意，下面列出的一些作为“可选”依赖关系下可能仍然需要在一个Spring应用程序中的其他非安全功能.如果它们在大多数应用中使用也被列为"optional"的依赖关系，实际上可能不被标记为在项目的Maven POM文件.只有在某种意义上他们是"optional" 他们是“可选的”只有在某种意义上,你不需要他们,除非你是使用指定的功能.</p>
</div>
<div class="paragraph">
<p>其中一个模块依赖于另一个Spring Security模块,模块的非可选依赖关系取决于被假定为是必需的和没有单独列出的.</p>
</div>
<div class="sect2">
<h3 id="truespring-security-core"><a class="anchor" href="#truespring-security-core"></a>spring-security-core</h3>
<div class="paragraph">
<p>使用Spring Security核心模块必须包含在任何项目中.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 4. Core Depenendencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">版本</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aopalliance</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所需的安全实现方法.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ehcache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要求 ehcache-based基于用户缓存实现（可选）.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-aop</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">基于Spring AOP的方法安全性</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-beans</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring配置所需</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-expression</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">基于表达式所需的方法安全性（可选）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-jdbc</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要使用一个数据库来存储用户数据(可选).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-tx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要使用一个数据库来存储用户数据(可选).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aspectjrt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要使用AspectJ支持(可选).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">jsr250-api</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你使用JSR-250方法安全性注释（可选）.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="truespring-security-remoting"><a class="anchor" href="#truespring-security-remoting"></a>spring-security-remoting</h3>
<div class="paragraph">
<p>这个模块通常需要在Web应用程序中使用Servlet API.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 5. Remoting Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">版本</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用HTTP的客户所需的远程支持.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="truespring-security-web"><a class="anchor" href="#truespring-security-web"></a>spring-security-web</h3>
<div class="paragraph">
<p>这个模块通常需要在Web应用程序中使用Servlet API.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 6. Web Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">版本</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">广泛使用Spring web支持类.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-jdbc</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">需要基于JDBC的免登陆标记库（可选）.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-tx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">需要通过免登陆持久标记库实现（可选）.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="truespring-security-ldap"><a class="anchor" href="#truespring-security-ldap"></a>spring-security-ldap</h3>
<div class="paragraph">
<p>这个模块是如果需要你使用LDAP认证.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 7. LDAP Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">版本</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-ldap-core</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.3.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP仅支持于Spring LDAP.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-tx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据异常类是必需的.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">apache-ds  <sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnote_13" title="View footnote.">13</a>]</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你使用嵌入式LDAP服务器（可选）.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">shared-ldap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9.15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你使用嵌入式LDAP服务器（可选）.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ldapsdk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mozilla LdapSDK.如果你使用OpenLDAP的密码策略功能，用于解码LDAP密码策略控制,例如.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="truespring-security-config"><a class="anchor" href="#truespring-security-config"></a>spring-security-config</h3>
<div class="paragraph">
<p>这个模块是如果需要你使用Spring Security命名空间的配置.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 8. Config Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">版本</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你使用任何与Web相关的命名空间配置（可选）.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-ldap</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你使用LDAP命名空间选项（可选）.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-openid</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你使用OpenID认证(可选).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aspectjweaver</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你使用命名空间的语法点的保护（可选）.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="truespring-security-acl"><a class="anchor" href="#truespring-security-acl"></a>spring-security-acl</h3>
<div class="paragraph">
<p>ACL模块.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 9. ACL Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">版本</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ehcache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要实现使用基于ACL的Ehcache缓存 (optional if you are using your own implementation).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-jdbc</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你使用默认的基于JDBC的aclservice (optional if you implement your own).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-tx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你使用默认的基于JDBC的aclservice AclService (optional if you implement your own).</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="truespring-security-cas"><a class="anchor" href="#truespring-security-cas"></a>spring-security-cas</h3>
<div class="paragraph">
<p>CAS模块提供集成JA-SIG CAS.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 10. CAS Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">版本</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cas-client-core</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.1.12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JA-SIG CAS客户端. 这是Spring Security集成的基础.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ehcache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你基于缓存Ehcache标签 (可选).</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="truespring-security-openid"><a class="anchor" href="#truespring-security-openid"></a>spring-security-openid</h3>
<div class="paragraph">
<p>OpenID模块.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 11. OpenID Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">版本</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">openid4java-nodeps</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9.6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Security的OpenID集成使用OpenID4Java.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">httpclient</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">openid4java-nodeps 取决于 HttpClient 4.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">guice</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">openid4java-nodeps 取决于 Guice 2.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="truespring-security-taglibs"><a class="anchor" href="#truespring-security-taglibs"></a>spring-security-taglibs</h3>
<div class="paragraph">
<p>提供Spring Security的JSP标记的实现.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 12. Taglib Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">版本</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-acl</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你使用 <code>accesscontrollist</code> 标记或 <code>hasPermission()</code> ACLs表达式 (可选).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-expression</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果需要你在标签访问限制中使用SPEL表达式</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>包括::_includes/faq.adoc[]</p>
</div>
<div class="paragraph">
<p>包括::_includes/migrating.adoc[]</p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. 一旦响应已提交，不可能创建一个会话
</div>
<div class="footnote" id="_footnote_2">
<a href="#_footnoteref_2">2</a>. 请注意，您需要在您的应用程序上下文中包括安全命名空间的XML文件，才能使用此语法。旧的语法仍然支持使用<code>filter-chain-map</code>，但弃用构造函数参数的注入。
</div>
<div class="footnote" id="_footnote_3">
<a href="#_footnoteref_3">3</a>. 而不是一个路径模式的要求，<code>request-matcher-ref</code>属性可以用来指定一个更强大的匹配<code>requestmatcher</code>的实例
</div>
<div class="footnote" id="_footnote_4">
<a href="#_footnoteref_4">4</a>. 你可能已经看过这浏览器不支持Cookie和` JSESSIONID <code>参数附加到URL分号后。然而，RFC允许这些参数的URL中的任何路径段的存在
</div>
<div class="footnote" id="_footnote_5">
<a href="#_footnoteref_5">5</a>. 一旦请求离开<code>FilterChainProxy</code>的原始值将被退回，仍然会提供给应用程序。
</div>
<div class="footnote" id="_footnote_6">
<a href="#_footnoteref_6">6</a>. 因此，例如，原来的请求路径 <code>/secure;hack=1/somefile.html;hack=2</code> 将返回为 <code>/secure/somefile.html</code>.
</div>
<div class="footnote" id="_footnote_7">
<a href="#_footnoteref_7">7</a>. 我们使用了进行，这样SecurityContextHolder仍然包含主体，其可以是用于显示对用户有用的信息。在Spring Security的老版本中，我们让servlet容器处理403错误信息，缺乏这种有用的上下文信息。
</div>
<div class="footnote" id="_footnote_8">
<a href="#_footnoteref_8">8</a>. 在Spring Security2.0和更早的版本，此过滤器被称为<code>HttpSessionContextIntegrationFilter</code>和存储方面的全部工作由过滤器本身进行执行。如果你熟悉这个类，那么其中大部分可用的配置选项现在可以在<code>HttpSessionSecurityContextRepository</code>找到。
</div>
<div class="footnote" id="_footnote_9">
<a href="#_footnoteref_9">9</a>. 由于历史原因,Spring Security 3.0之前,这个过滤器被称为<code>AuthenticationProcessingFilter</code>和入口点被称为<code>AuthenticationProcessingFilterEntryPoint</code>。由于框架现在支持多种不同形式的身份验证，他们在3.0都被给出更具体的名称。
</div>
<div class="footnote" id="_footnote_10">
<a href="#_footnoteref_10">10</a>. 在版本3.0之前,在这一点上，应用程序流程已经演变到一个阶段由这个类和策略插件属性混合来控制，3.0重构代码的决定使这两个策略完全负责。
</div>
<div class="footnote" id="_footnote_11">
<a href="#_footnoteref_11">11</a>. 有可能以十六进制编码的密码格式( MD5(username:realm:password) )提供 <code>DigestAuthenticationFilter.passwordAlreadyEncoded</code>设置为<code>true</code>。然而,其他密码编码不会使用摘要式身份验证。
</div>
<div class="footnote" id="_footnote_12">
<a href="#_footnoteref_12">12</a>. 本质上，用户名不包括在该cookie，以防止不必要的暴露有效登录名。有一个讨论这篇文章的评论部分。
</div>
<div class="footnote" id="_footnote_13">
<a href="#_footnoteref_13">13</a>. The modules <code>apacheds-core</code>, <code>apacheds-core-entry</code>, <code>apacheds-protocol-shared</code>, <code>apacheds-protocol-ldap</code> and <code>apacheds-server-jndi</code> are required.
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2016-09-05 22:11:51
</div>
</div>
</body>
</html>
